<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="周琦茗在 Github 上的个人博客">
    <meta name="keyword" content="周琦茗">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://s3.bmp.ovh/imgs/2022/03/1f0227bacbd74e15.png">
    <link rel="alternate" type="application/atom+xml" title="ChowMe" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        我的vue3.x公司宣讲会文档｜Chow&#39;s blog
        
    </title>

    <link rel="canonical" href="http://localhost:4000/BeCoderQ.github.io/2022/01/05/我的vue3-x公司宣讲会文档/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/BeCoderQ.github.io/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/BeCoderQ.github.io/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/BeCoderQ.github.io/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/BeCoderQ.github.io/">
                <span class="brand-logo">
                    ChowMe
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/BeCoderQ.github.io/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/BeCoderQ.github.io/categories/">categories</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/BeCoderQ.github.io/tags/">tags</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="https://s3.bmp.ovh/imgs/2022/01/c7d7cb65a170cd10.jpg">


<style>
    
    header.intro-header {
        background-image: url('https://s3.bmp.ovh/imgs/2022/01/c7d7cb65a170cd10.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>我的vue3.x公司宣讲会文档</h1>
                    
                    <span class="meta">
                         作者 Chow
                        <span>
                          日期 2022-01-05
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/BeCoderQ.github.io/tags/#Vue3"
                           title="Vue3">Vue3</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            我的vue3.x公司宣讲会文档
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h2 id="Vue3与Vue2的主要区别"><a href="#Vue3与Vue2的主要区别" class="headerlink" title="Vue3与Vue2的主要区别"></a>Vue3与Vue2的主要区别</h2><p>从以下6个点来阐述区别：</p>
<h3 id="入口文件写法区别"><a href="#入口文件写法区别" class="headerlink" title="入口文件写法区别"></a>入口文件写法区别</h3><ul>
<li><p>Vue2.x:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  <span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line">  <span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">"./router"</span></span><br><span class="line">  <span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"./store"</span></span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  &#125;).$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line">- Vue3.x:</span><br><span class="line"></span><br><span class="line">  <span class="string">``</span><span class="string">`typescript</span></span><br><span class="line"><span class="string">  import &#123; createApp &#125; from 'vue'</span></span><br><span class="line"><span class="string">  import App from './App.vue'</span></span><br><span class="line"><span class="string">  import router from './router'</span></span><br><span class="line"><span class="string">  import store from './store'</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  createApp(App)</span></span><br><span class="line"><span class="string">    .use(store)</span></span><br><span class="line"><span class="string">    .use(router)</span></span><br><span class="line"><span class="string">    .mount('#app')</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Vue3不再直接暴露Vue的实例，创建Vue模板使用`</span>createApp<span class="string">`这个工厂函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 组件声明的区别</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Vue2.x:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">	export default &#123;</span></span><br><span class="line"><span class="regexp">    data() &#123;</span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        name: "",</span></span><br><span class="line"><span class="regexp">        age: 0</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Vue3.x:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="line">	export default defineComponent(&#123;</span><br><span class="line">    // 这里依然可以像2.x一样写钩子</span><br><span class="line">    // ...</span><br><span class="line">    setup(props, &#123; attrs, emit, slots, expose &#125;) &#123;</span><br><span class="line">      // code</span><br><span class="line">      </span><br><span class="line">      return &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>Vue3中我们依然可以像2那样写代码，这是为了平稳过渡。Vue3的推荐写法是使用<code>defineComponent</code>工厂函数中的<code>setup</code>回调来书写页面代码。</p>
<h3 id="数据响应式"><a href="#数据响应式" class="headerlink" title="数据响应式"></a>数据响应式</h3><p>不同于Vue2的<code>Object.defineProperty</code>使用<code>getter</code>与<code>setter</code>来劫持数据，Vue3的双向绑定是使用<code>Proxy</code>这个更全面的API来实现：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prop <span class="keyword">in</span> obj ? obj[prop] : <span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Proxy(&#123;&#125;, handler);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b);      <span class="comment">// 1, undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span> <span class="keyword">in</span> p, p.c); <span class="comment">// false, 37</span></span><br></pre></td></tr></table></figure>
<p>相对于<code>Object.defineProperty</code>，后者不止有<code>setter</code>、<code>getter</code>，还有诸如<code>apply</code>、<code>construct</code>、<code>has</code>等诸多捕获器。</p>
<h3 id="数据的声明"><a href="#数据的声明" class="headerlink" title="数据的声明"></a>数据的声明</h3><p>在Vue2中我们直接将数据写入data中实现双向绑定，优点是方便，缺点是与组件<strong>强耦合</strong>，与之相对的，在Vue3中，响应式数据不再依赖于钩子函数，而是在<code>setup</code>使用<strong>Hook</strong>进行显式的声明，并且与组件<strong>无耦合关系</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue2.x</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">""</span>,</span><br><span class="line">      age: <span class="number">0</span>,</span><br><span class="line">      fruit: [<span class="string">"apple"</span>, <span class="string">"banana"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue3.x</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, reactive &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">"周"</span>),</span><br><span class="line">          age = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">25</span>),</span><br><span class="line">          fruit = reactive(&#123;</span><br><span class="line">            name: <span class="string">"周"</span>,</span><br><span class="line">            age: <span class="number">25</span></span><br><span class="line">          &#125;);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">    	name,</span><br><span class="line">      age,</span><br><span class="line">      fruit</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="选项式API与组合式API"><a href="#选项式API与组合式API" class="headerlink" title="选项式API与组合式API"></a>选项式API与组合式API</h3><p>在使用<code>watch</code>、<code>computed</code>、<code>mounted</code>这些API时，在2.x里是用选项回调的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>而在3.x中，一切都是<code>Hook</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	import &#123; defineComponent, onMounted, ref, watch, computed &#125;</span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    setup(props) &#123;</span><br><span class="line">      const name = ref&lt;string&gt;(&quot;周&quot;),</span><br><span class="line">          age = ref&lt;number&gt;(25);</span><br><span class="line">      </span><br><span class="line">      onMounted(()=&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      watch(()=&gt; name.value, (value: string)=&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      const ageCompute = computed(()=&gt; age.value + &quot;岁&quot;);</span><br><span class="line">      </span><br><span class="line">      return &#123; </span><br><span class="line">        name,</span><br><span class="line">        ageCompute,</span><br><span class="line">        fruit</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>因为前面我们说的<strong>数据不在与组件耦合</strong>，因此这里除了<code>onMounted</code>，诸如<code>watch</code>、<code>watchEffect</code>、<code>computed</code>这类的组合式API也可以<code>不与组件耦合</code>，个人认为，这是一面双刃剑。</p>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p>父子组件依然是使用<code>props</code>和<code>emit</code>通信，这里我就不写2.x的例子了，直接看3.x:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, toRefs &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">    setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">sendBackToFather</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        emit(<span class="string">"xxx"</span>, <span class="string">"子传父亲"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 不能这样写</span></span><br><span class="line">        ...props</span><br><span class="line">        <span class="comment">// 应该这样写</span></span><br><span class="line">        ...toRefs(props)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>需要注意的是props也是<code>Proxy</code>的实例，因此我们不能直接用展开符，这样会导致props失活，这里需要一个新的API，<code>toRefs</code>，就如它的名字，它是将属性转为ref值的函数。</p>
<h2 id="Vue3基础与实践"><a href="#Vue3基础与实践" class="headerlink" title="Vue3基础与实践"></a>Vue3基础与实践</h2><p>我使用过最早的release版本，结合现在最新的文档，给大家整理了一些API的基础使用与实践问题。</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>功能没有任何改变，但是使用上完全不同了：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, watch, ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">    setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> name = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">"周"</span>);</span><br><span class="line">      </span><br><span class="line">      watch(name, <span class="function">(<span class="params">newVal, oldVal</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;, &#123; immediate: <span class="literal">true</span> &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 或者你可以这样写</span></span><br><span class="line">      watch(<span class="function"><span class="params">()</span>=&gt;</span> name.value, <span class="function">(<span class="params">newVal, oldVal</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;, &#123; immediate: <span class="literal">true</span> &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 支持同时监听多个</span></span><br><span class="line">      watch([<span class="function"><span class="params">()</span>=&gt;</span> name.value, <span class="function"><span class="params">()</span>=&gt;</span> xxx.value], <span class="function">(<span class="params">[newVal, oldVal, ...]</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;, &#123; immediate: <span class="literal">true</span> &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">       	...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数是监听的对象，理所当然 我们不能直接把ref的value传进去，因此直接传入了name，如果你一定要.value，那么可以用第二种回调写法，如前面我写的，所有数据都被Proxy劫持，如果我们直接把name.value扔进去，那么这就是单纯的一个常量了，不具有响应式结构，因此可以把它放到回调中，watch每次会执行回调获取到最新的响应式结果。</li>
<li>第二个参数与以前的watch回调一样，就不单独说了。</li>
<li>第三个参数也是同以前的watch options。</li>
</ul>
<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>除了watch，Vue3还引入了这个新的API，目的是解决<strong>副作用</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, onMounted, watchEffect, ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">    setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> age = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 立即执行输出 0 返回值为结束函数</span></span><br><span class="line">      <span class="keyword">const</span> stop = watchEffect(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(age.value);</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        age.value++</span><br><span class="line">        <span class="comment">// 这里会输出1</span></span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">       	...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对于watchEffect：</p>
<ul>
<li>不用传入监测对象</li>
<li>会立即执行并从回调中获取依赖值</li>
<li>只能拿到变化后的值，无法像watch那样拿到旧值</li>
</ul>
<p>实践：假设有一个防抖下限很低的输入框，需求是每次输入内容更改后就发送请求获取搜索结果，这样的场景下会有一个很明显的问题，那就是我们无法保证请求的返回顺序，对此，我们可能会设置更高的防抖值，但这也是治标不治本。如果使用watchEffect就可以很优雅的解决这个问题：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, onMounted, watchEffect, ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">    setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> keyword = ref&lt;<span class="built_in">string</span>&gt;(<span class="string">""</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fetchSearchApi</span>(<span class="params">keyword: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        getSearch(<span class="string">"xxx.com"</span>, &#123; keyword &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// onInvalidate这个回调函数中的回调函数会在watchEffect重新运行或者停止前执行</span></span><br><span class="line">      watchEffect(<span class="function">(<span class="params">onInvalidate</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> request = fetchSearchApi(keyword.value);</span><br><span class="line">        onInvalidate(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">          request.cancel();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">       	...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>个人认为这个解决方案真的非常优雅，利用<code>onInvalidate</code>，我们在下一次请求发起后马上abort上一次请求(如果上一次请求还是pedding状态)，实现接口的顺序调用。我们可以把这个过程想像成一个先进先出的队列结构，可以说非常非常优雅了。</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>Vue3中的computed本质上也是一个ref：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, onMounted , computed &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> age = ref&lt;<span class="built_in">number</span>&gt;(<span class="number">25</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ageCompute = computed(<span class="function"><span class="params">()</span>=&gt;</span> age.value + <span class="string">"岁"</span>);</span><br><span class="line">    </span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ageCompute.value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      ageCompute</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>computed会返回一个ref对象，接受的也是包含ref对象的对象或回调，下面来看一个高级一点的用法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent , computed &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _visible = computed(&#123;</span><br><span class="line">      <span class="keyword">get</span>: <span class="function"><span class="params">()</span>=&gt;</span> props.visible,</span><br><span class="line">      <span class="keyword">set</span>: <span class="function">(<span class="params">value</span>)=&gt;</span> emit(<span class="string">'update:visible'</span>, value)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      _visible</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了可以传回调，我们也可以传一个对象进去，并重写它的<code>setter</code>与<code>getter</code>，这个地方仅用四行代码就实现了props数据的双向绑定。</p>
<h3 id="Provide与Inject"><a href="#Provide与Inject" class="headerlink" title="Provide与Inject"></a>Provide与Inject</h3><p>3.x里这两个API和2.x的class写法差不多：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, provide, ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> text = ref(<span class="string">"文本"</span>);</span><br><span class="line">		<span class="comment">// value使用ref值实现响应式依赖注入</span></span><br><span class="line">    provide(<span class="string">"text"</span>, text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, inject &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> text = inject(<span class="string">"text"</span>);</span><br><span class="line">    <span class="comment">// 设置默认值</span></span><br><span class="line">    <span class="keyword">const</span> text2 = inject(<span class="string">"text"</span>, <span class="string">"default-value"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了保证数据的单一性，也是为了代码的可读性、可维护性，推荐任何情况下都不要在被注入的子组件内修改值，作为解决方案，我们可以往子组件注入修改值的函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, provide, ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> text = ref(<span class="string">"文本"</span>);</span><br><span class="line">		<span class="comment">// value使用ref值实现响应式依赖注入</span></span><br><span class="line">    provide(<span class="string">"text"</span>, text);</span><br><span class="line">    provide(<span class="string">"setText"</span>, <span class="function">(<span class="params">newText: <span class="built_in">string</span></span>)=&gt;</span> &#123;</span><br><span class="line">      text.value = newText;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, onMounted, inject &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> text = inject(<span class="string">"text"</span>);</span><br><span class="line">    <span class="comment">// 设置默认值</span></span><br><span class="line">    <span class="keyword">const</span> text2 = inject(<span class="string">"text"</span>, <span class="string">"default-value"</span>);</span><br><span class="line">    <span class="comment">// 获取遵循单一数据源的修改函数</span></span><br><span class="line">    <span class="keyword">const</span> setText = inject(<span class="string">"setText"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 做修改：</span></span><br><span class="line">    onMounted(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      setText(<span class="string">"xxxx"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实际上为了保证一个团队严格遵循上述的编码规范，我们可以使用Vue3提供的一个只读函数<code>readonly</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, provide, ref, readonly &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> text = ref(<span class="string">"文本"</span>);</span><br><span class="line">		<span class="comment">// value使用ref值实现响应式依赖注入</span></span><br><span class="line">    provide(<span class="string">"text"</span>, readonly(text));</span><br><span class="line">    provide(<span class="string">"setText"</span>, <span class="function">(<span class="params">newText: <span class="built_in">string</span></span>)=&gt;</span> &#123;</span><br><span class="line">      text.value = newText;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p>此ref非彼ref，这个是指元素上的ref钩子，用来获取组件上下文的ref，它的声明和使用方式和以往有点不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    &lt;AComp ref=&quot;comp&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import &#123; defineComponent, ref, onMounted &#125; from &quot;vue&quot;</span><br><span class="line">  import AComp from &quot;Xxx&quot;;</span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    components: &#123; AComp &#125;,</span><br><span class="line">    setup(props) &#123;</span><br><span class="line">      const compRef = ref&lt;AComp | null&gt;(null);</span><br><span class="line">      </span><br><span class="line">     	onMounted(()=&gt; &#123;</span><br><span class="line">        compRef.AComp组件暴露的方法或属性</span><br><span class="line">      &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="NextTick"><a href="#NextTick" class="headerlink" title="NextTick"></a>NextTick</h3><p>nexttick也变成了Hook，但使用上没有任何改变：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, nextTick &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    nextTick(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>混入没有单独的Hook函数，但这次可以定制混入策略：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  custom: <span class="string">'hello!'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.config.optionMergeStrategies.custom = <span class="function">(<span class="params">toVal, fromVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fromVal, toVal)</span><br><span class="line">  <span class="comment">// =&gt; "goodbye!", undefined</span></span><br><span class="line">  <span class="comment">// =&gt; "hello", "goodbye!"</span></span><br><span class="line">  <span class="keyword">return</span> fromVal || toVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.mixin(&#123;</span><br><span class="line">  custom: <span class="string">'goodbye!'</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.custom) <span class="comment">// =&gt; "hello!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里定制了app这个Vue实例的混入策略，如果有fromVal的话永远返回fromVal，因此后面混入的created里打印custom会是hello。</p>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>在<code>setup</code>中第二个参数其实就是上下文，但这和以往的不太一样。比如我在入口文件引入了<code>dayjs</code>库，并想挂载到全局后让每个组件都能用，那么使用这个context是拿不到的，这时候我们需要在<code>app.config</code>上操作：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"@/store"</span></span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">'dayjs'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(app.config.globalProperties,&#123;</span><br><span class="line">	$dayjs: dayjs,</span><br><span class="line">  <span class="comment">// 在这里还可以挂载其他的</span></span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在组件内这样使用：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = getCurrentInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNowDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> context.proxy.dayjs().format(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不过这样我们无法拿到上下文的类型推断，这里我写了一个推断：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 映射拿到currentInstance中的上下文</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ProxyContext = &#123;</span><br><span class="line">    proxy: NonNullable&lt;IncludeType&lt;<span class="keyword">import</span>(<span class="string">'vue'</span>).ComponentInternalInstance, <span class="string">'proxy'</span>&gt;[<span class="string">'proxy'</span>]&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们封装一个Hook:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ComponentPublicInstance, getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useContext</span>(<span class="params"></span>): <span class="title">ComponentPublicInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; proxy: context &#125; = &lt;ProxyContext&gt;getCurrentInstance();</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">"@/hook/use-context"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = useContext();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getNowDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> context.dayjs().format(<span class="string">"YYYY-MM-DD HH:mm:ss"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="多个双向绑定值"><a href="#多个双向绑定值" class="headerlink" title="多个双向绑定值"></a>多个双向绑定值</h3><p>Vue3不仅支持多个根元素，还支持多个v-model绑定值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    &lt;FileUpLoad v-model:list=&quot;fileList&quot; v-model:check=&quot;check&quot;&gt;&lt;/FileUpLoad&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>而在子组件内，就按照冒号后面的字符串来为props命名：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, PropType, computed &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="built_in">Array</span> <span class="keyword">as</span> PropType&lt;FileItem[]&gt;,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> [],</span><br><span class="line">    &#125;,</span><br><span class="line">    check: &#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="comment">// 合理利用computed事半功倍</span></span><br><span class="line">    <span class="keyword">const</span> fileList = computed(&#123;</span><br><span class="line">      <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> props.list,</span><br><span class="line">      <span class="keyword">set</span>: <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">        emit(<span class="string">'update:list'</span>, v);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setFileList</span>(<span class="params">list: FileItem[]</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 将同步到父组件实现双向绑定</span></span><br><span class="line">      fileList.value = list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个语法糖实际就是<code>list.sync=&quot;list&quot;</code>，使用起来比较方便。</p>
<h2 id="使用JSX"><a href="#使用JSX" class="headerlink" title="使用JSX"></a>使用JSX</h2><p>实际上我用Vue3更多的都是在写JSX，它很方便，但我作为初代受害者也踩到了很多坑。</p>
<h3 id="让项目支持jsx"><a href="#让项目支持jsx" class="headerlink" title="让项目支持jsx"></a>让项目支持jsx</h3><p>Vue3的jsx是使用的<strong>jsx-next</strong>这个库，准确的说是一个babel插件，使用就只需要两步：</p>
<ul>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @vue/babel-plugin-jsx -D</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在babel.config中配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"@vue/babel-plugin-jsx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="编写jsx代码"><a href="#编写jsx代码" class="headerlink" title="编写jsx代码"></a>编写jsx代码</h3><p>我们的代码还是写在defineComponent函数里面，不过返回值变成了jsx-element：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineComponent, ref &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const text = ref(&quot;text&quot;);</span><br><span class="line">    return ()=&gt; (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      	&lt;div class=&quot;my-div&quot;&gt;</span><br><span class="line">        	&lt;CustomComponent propsValue=&#123; text.value &#125;&gt;&lt;/CustomComponent&gt;</span><br><span class="line">          &lt;span&gt;&#123; text.value &#125;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>现在的版本大部分指令是可以直接使用的，除了v-if，因为没有必要去使用v-if，参考React，我们可以使用逻辑与实现v-if：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> text = ref(<span class="string">"text"</span>),</span><br><span class="line">          show = ref(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      	&lt;div <span class="keyword">class</span>=<span class="string">"my-div"</span>&gt;</span><br><span class="line">          &#123;</span><br><span class="line">      			show.value &amp;&amp; &lt;span&gt;&#123; text.value &#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      		&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
<h3 id="插槽使用"><a href="#插槽使用" class="headerlink" title="插槽使用"></a>插槽使用</h3><p>使用上分默认插槽和具名插槽：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineComponent, ref &#125; from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">// 无状态函数组件</span><br><span class="line">const Comp = (props, &#123; slots &#125;)=&gt; &#123;</span><br><span class="line">  &lt;div class=&quot;comp&quot;&gt;</span><br><span class="line">    &lt;DropDown&gt;</span><br><span class="line">    	&#123; slots.default &amp;&amp; slots.default() &#125;</span><br><span class="line">    &lt;/DropDown&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">    	&#123; slots.title &amp;&amp; slots.title() &#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const text = ref(&quot;text&quot;);</span><br><span class="line">    </span><br><span class="line">    return ()=&gt; (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      	&lt;div class=&quot;my-div&quot;&gt;</span><br><span class="line">          &lt;Comp&gt;&#123;&#123;</span><br><span class="line">              default: ()=&gt; someList.map(item=&gt; &lt;div class=&quot;item&quot;&gt;&#123; item.name &#125;&lt;/div&gt;),</span><br><span class="line">              title: ()=&gt; &lt;span&gt;&#123; text.value &#125;&lt;/span&gt;                           </span><br><span class="line">            &#125;&#125;&lt;/Comp&gt;</span><br><span class="line">          </span><br><span class="line">        	&#123; /* 默认插槽也可直接这样写 */ &#125;</span><br><span class="line">        	&lt;Comp&gt;</span><br><span class="line">        		&#123; someList.map(item=&gt; &lt;div class=&quot;item&quot;&gt;&#123; item.name &#125;&lt;/div&gt;) &#125;</span><br><span class="line">        	&lt;/Comp&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对于多个插槽还可以使用<code>v-slots</code>指令，这里就不单独说了。</p>
<h3 id="KeepAlive的方案"><a href="#KeepAlive的方案" class="headerlink" title="KeepAlive的方案"></a>KeepAlive的方案</h3><p>在Vue3中，<code>&lt;keep-alive&gt;</code>标签不能再包着<code>&lt;router-view&gt;</code>标签了这是基于设计思想上的更改，对于模板，可以用作用域插槽解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;component :is=&quot;Component&quot;/&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>但在jsx里面是没有<code>component :is</code>这种写法的，因此要在作用域插槽的基础上使用<code>resolveDynamicComponent</code>这个功能函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  return ()=&gt; (</span><br><span class="line">  	&lt;RouterView&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        (&#123; Component &#125;: &#123; Component: Component &#125;) =&gt; (</span><br><span class="line">          &lt;KeepAlive exclude=&quot;[&apos;HomePage&apos;]&quot;&gt;</span><br><span class="line">            &#123; resolveDynamicComponent(Component)&#125;</span><br><span class="line">          &lt;/KeepAlive&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">  	&lt;/RouterView&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="早期无法实现的操作"><a href="#早期无法实现的操作" class="headerlink" title="早期无法实现的操作"></a>早期无法实现的操作</h3><p>实际上我是要在这里讲<code>expose</code>这个函数，在早期版本Vue官方并没有给出这个函数，因此会导致下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const msg = ref(&quot;text&quot;);</span><br><span class="line"></span><br><span class="line">    return ()=&gt; (</span><br><span class="line">      &lt;div class=&quot;my-div&quot;&gt;</span><br><span class="line">        &#123; msg.value &#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 父组件</span><br><span class="line">import TextComp from &quot;xxx&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const text = ref(&quot;text&quot;);</span><br><span class="line">    	textRef = ref&lt;typeof TextComp | null&gt;(null);</span><br><span class="line">                    </span><br><span class="line">    onMounted(()=&gt; &#123;</span><br><span class="line">      // undefined</span><br><span class="line">      console.log(textRef.value.msg);</span><br><span class="line">    &#125;)                </span><br><span class="line"></span><br><span class="line">    return ()=&gt; (</span><br><span class="line">      &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">        &lt;TextComp ref=&#123; textRef &#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在setup的第二个参数有了<code>expose</code>就能解决这个问题了: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup(props, &#123; expose &#125;) &#123;</span><br><span class="line">    const msg = ref(&quot;text&quot;);</span><br><span class="line">		</span><br><span class="line">    expose(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return ()=&gt; (</span><br><span class="line">      &lt;div class=&quot;my-div&quot;&gt;</span><br><span class="line">        &#123; msg.value &#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在父组件可以拿到msg了。</p>
<h2 id="两行代码让Vuex直呼内行"><a href="#两行代码让Vuex直呼内行" class="headerlink" title="两行代码让Vuex直呼内行"></a>两行代码让Vuex直呼内行</h2><p>得益于组合式API的加入，数据与组件解耦合，让我们可以放飞自我的声明数据，下面有个例子，假设我有个list变量在好几个组件里都会使用来渲染组件，并且这几个组件都有修改它的需求：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data.ts文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> list = ref([]);</span><br></pre></td></tr></table></figure>
<p>对于这n个使用它的组件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; list &#125; <span class="keyword">from</span> <span class="string">"@/data"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      list.value = [<span class="string">"xxx"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>他们可以在内部直接修改并直接返回后渲染到页面上，实现了和vuex同样的效果。不过这当然是不可取的，在多人协作的项目中这样会写出不可维护的代码。</p>
<h3 id="也不是不行"><a href="#也不是不行" class="headerlink" title="也不是不行"></a>也不是不行</h3><p>我们可以像Vuex那样写一个commit函数解决数据修改源混乱的问题：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data.ts文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, nextTick &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> list = ref([]);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setList = <span class="function">(<span class="params">newList</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里可能是一些依赖采集的工作 </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 这里可能是一些依赖采集的工作</span></span><br><span class="line">  nextTick(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    list.value = newList;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2新的展望"><a href="#3-2新的展望" class="headerlink" title="3.2新的展望"></a>3.2新的展望</h2><p>在两个半月前3.2正式发布，带来了一些很屌的特性。</p>
<h3 id="setup-SFC"><a href="#setup-SFC" class="headerlink" title="setup SFC"></a>setup SFC</h3><p>现在早期处于stage-1的特性<code>&lt;script setup&gt;</code>发布出来了，它让我们不必每次都引入<code>defineComponent</code>，也不用再return在模板类要是用的数据与函数。它实际是<code>compile-time</code>的一种黑魔法，也就是编译时修改我们的源码。</p>
<h3 id="css样式的v-bind"><a href="#css样式的v-bind" class="headerlink" title="css样式的v-bind"></a>css样式的v-bind</h3><p>这个个人认为很实用，这非常符合现在最流行的声明式构建ui：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;color = color === &apos;red&apos; ? &apos;green&apos; : &apos;red&apos;&quot;&gt;</span><br><span class="line">    Color is: &#123;&#123; color &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; ref &#125; from &apos;vue&apos;</span><br><span class="line">  const color = ref(&apos;red&apos;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  button &#123;</span><br><span class="line">    color: v-bind(color);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="defineCustomElement"><a href="#defineCustomElement" class="headerlink" title="defineCustomElement"></a>defineCustomElement</h3><p>这个API的用途很像我们现在class写法2.x的实例化组件，它用来动态创造一个自定义组件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineCustomElement &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyVueElement = defineCustomElement(&#123;</span><br><span class="line">  <span class="comment">// 这里就是Vue组件的选项</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="v-memo"><a href="#v-memo" class="headerlink" title="v-memo"></a>v-memo</h3><p>在元素上加上这个指令后，这棵dom树将会被缓存，后续虚拟dom的更新、VNode的创建都会被跳过，用于对性能有极致追求的业务场景。</p>
<h3 id="defineProps、defineEmits等语法糖"><a href="#defineProps、defineEmits等语法糖" class="headerlink" title="defineProps、defineEmits等语法糖"></a>defineProps、defineEmits等语法糖</h3><p>前面说了setUp没了，那么再想获取Props等就需要另辟蹊径了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; defineEmits, defineProps, defineExpose &#125; from &apos;vue&apos;</span><br><span class="line">	</span><br><span class="line">  const props = defineProps(&#123;</span><br><span class="line">    fileList: FileItem[],</span><br><span class="line">    check: Boolean</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  const emit = defineEmits([&quot;setCheck&quot;]);</span><br><span class="line">  </span><br><span class="line">  function setCheck() &#123;</span><br><span class="line">    emit(&quot;setCheck&quot;, &quot;xxx&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  defineExpose(&#123;</span><br><span class="line">    setCheck</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>个人觉得挺麻烦的。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对于在顶层的函数，在3.2里可以不用async直接await：</p>
<p><img src="https://img-blog.csdnimg.cn/20210623162616858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODE2NDIxNw==,size_16,color_FFFFFF,t_70" alt="图"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一次向函数式编程的迁徙，我2月份在生产环境使用了3.0初代的release版本，最后写得魂飞魄散，诚然，组合式API很自由，但带来的副作用就是写出来的代码很容易“东一榔头西一句”。因此我认为Vue3.0是一个更需要团队规范的框架，我似乎理解到了React哲学里提到的immutable以及为什么immutable，条条框框的规则带来的是规范的代码。</p>
<p><strong>但是不得不说写Vue3是真的很爽。</strong></p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/BeCoderQ.github.io/2022/03/10/无痛处理async-await的异常，告别一个请求一个try-catch/" data-toggle="tooltip" data-placement="top"
                           title="无痛处理async-await的异常，告别一个请求一个try-catch">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/BeCoderQ.github.io/2021/10/27/React-Hook函数式编程学习笔记/" data-toggle="tooltip" data-placement="top"
                           title="React Hook函数式编程问题笔记">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3与Vue2的主要区别"><span class="toc-text">Vue3与Vue2的主要区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#入口文件写法区别"><span class="toc-text">入口文件写法区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据响应式"><span class="toc-text">数据响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据的声明"><span class="toc-text">数据的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选项式API与组合式API"><span class="toc-text">选项式API与组合式API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件通信"><span class="toc-text">组件通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3基础与实践"><span class="toc-text">Vue3基础与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#watch"><span class="toc-text">watch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watchEffect"><span class="toc-text">watchEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed"><span class="toc-text">computed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Provide与Inject"><span class="toc-text">Provide与Inject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref"><span class="toc-text">Ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NextTick"><span class="toc-text">NextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixin"><span class="toc-text">Mixin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文"><span class="toc-text">上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个双向绑定值"><span class="toc-text">多个双向绑定值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用JSX"><span class="toc-text">使用JSX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#让项目支持jsx"><span class="toc-text">让项目支持jsx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写jsx代码"><span class="toc-text">编写jsx代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令"><span class="toc-text">指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插槽使用"><span class="toc-text">插槽使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeepAlive的方案"><span class="toc-text">KeepAlive的方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#早期无法实现的操作"><span class="toc-text">早期无法实现的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两行代码让Vuex直呼内行"><span class="toc-text">两行代码让Vuex直呼内行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#也不是不行"><span class="toc-text">也不是不行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2新的展望"><span class="toc-text">3.2新的展望</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-SFC"><span class="toc-text">setup SFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css样式的v-bind"><span class="toc-text">css样式的v-bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defineCustomElement"><span class="toc-text">defineCustomElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-memo"><span class="toc-text">v-memo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defineProps、defineEmits等语法糖"><span class="toc-text">defineProps、defineEmits等语法糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/BeCoderQ.github.io/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/BeCoderQ.github.io/tags/#Vue3"
                           title="Vue3">Vue3</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/zyyzg">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/zhouqi">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/St7Paul-">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/becoderq">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; ChowMe 2022
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/BeCoderQ.github.io/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/BeCoderQ.github.io/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/BeCoderQ.github.io/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://localhost:4000/BeCoderQ.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->

<script>
    var _baId = 'ac1ba4c0c5c675cde36fb506beabca37';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="https://s3.bmp.ovh/imgs/2022/03/28127cf467601df7.gif">
</body>

</html>

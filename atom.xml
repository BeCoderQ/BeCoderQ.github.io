<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>ChowMe</title>
  <icon>https://www.gravatar.com/avatar/a73d30b0d26382bb941766ce55d0904e</icon>
  <subtitle>Hello,World</subtitle>
  <link href="/BeCoderQ.github.io/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2020-09-30T05:59:52.517Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>Chow</name>
    <email>zhouqm814@sina.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Vue包装一个链式注销的全局事件总线</title>
    <link href="http://localhost:4000/2020/09/30/%E5%9F%BA%E4%BA%8EVue%E5%8C%85%E8%A3%85%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E6%B3%A8%E9%94%80%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <id>http://localhost:4000/2020/09/30/%E5%9F%BA%E4%BA%8EVue%E5%8C%85%E8%A3%85%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E6%B3%A8%E9%94%80%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</id>
    <published>2020-09-30T05:45:27.000Z</published>
    <updated>2020-09-30T05:59:52.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>公司的某个项目组件封装得不是很好，到处都在用全局事件总线，并且<code>@on</code>注册后还从来都不注销，虽然项目不大不存在爆栈的问题，但是这不是一个好习惯，因此决定写一个工厂函数来让注销事件简单一点。</p><h2 id="目标效果"><a href="#目标效果" class="headerlink" title="目标效果"></a>目标效果</h2><p>最后实现的效果大概是这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$bus.$on(<span class="string">'customize-event'</span>, msg=&gt; &#123;</span><br><span class="line">      <span class="comment">// do sth</span></span><br><span class="line">    &#125;).off(<span class="keyword">this</span>, <span class="string">'customize-event'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在往Vue实例中_events属性中推入事件后，直接在<code>@on</code>后面调用off事件注销事件，当然这个注销不是马上注销，而是在<code>beforeDestory</code>钩子函数触发时注销。另外，我们还要向下兼容原生的事件。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ExtendGlobalEvent,继承自Vue,调用全局总线调用同原生事件总线相同，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendGlobalEvent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @override</span></span><br><span class="line">  <span class="comment">// 注意名字别写重了</span></span><br><span class="line">    _on(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>.$on(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    _emit(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>.$emit(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局事件的工厂函数，为了兼容原生$on的调用方式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">EventGloablFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Event = <span class="keyword">new</span> ExtendGlobalEvent()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        $on(...args) &#123;</span><br><span class="line">            Event._on(...args)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;,</span><br><span class="line">        $emit(...args) &#123;</span><br><span class="line">            Event._emit(...args)</span><br><span class="line">        &#125;,</span><br><span class="line">        $off(...args) &#123;</span><br><span class="line">            Event.$off(...args)</span><br><span class="line">        &#125;,</span><br><span class="line">        off(context, eventName) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context &amp;&amp; context._isVue) &#123;</span><br><span class="line">                context.$once(<span class="string">'hook:beforeDestroy'</span>, () =&gt; &#123;</span><br><span class="line">                    <span class="keyword">this</span>.$off(eventName)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们暴露出去的实际是一个对象，这个对象的key与原生的全局事件的key相同，他们会执行被ExtendGlobalEvent实例化后的Event，而ExtendGlobalEvent内部又是继承自Vue，它触发的也是原生的$emit、$on、$off。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;公司的某个项目组件封装得不是很好，到处都在用全局事件总线，并且&lt;code&gt;@on&lt;/code&gt;注册后还从来都不注销，虽然项目不大不存在爆栈的
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="bus" scheme="http://localhost:4000/tags/bus/"/>
    
      <category term="Vue" scheme="http://localhost:4000/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>最近项目中遇到的一些问题或一些总结</title>
    <link href="http://localhost:4000/2020/09/30/%E6%9C%80%E8%BF%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%88%96%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://localhost:4000/2020/09/30/%E6%9C%80%E8%BF%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%88%96%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-30T02:31:10.000Z</published>
    <updated>2020-09-30T05:28:48.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="uni-app的scroll-view组件触底概率不触发问题"><a href="#uni-app的scroll-view组件触底概率不触发问题" class="headerlink" title="uni-app的scroll-view组件触底概率不触发问题"></a>uni-app的scroll-view组件触底概率不触发问题</h2><p>前段时间用uni-app做移动端遇到一个问题，使用<code>scroll-view</code>标签<code>@scrolltolower</code>事件时，会有一定概率不触发触底事件，至于原因我没有去研究，不过暂时找到一个解决办法:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scroll-view</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:scroll-top</span>=<span class="string">"prevScrollTop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"load-more-list"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">scroll-y</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">@<span class="attr">scrolltolower</span>=<span class="string">"reachBottom"</span></span></span><br><span class="line"><span class="tag">@<span class="attr">scroll</span>=<span class="string">"onScroll"</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-on</span>=<span class="string">"$listeners"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:style</span>=<span class="string">"&#123; height: height || `calc(100vh - $&#123;_cache.statusHeight&#125;px - 44px` &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">:list</span>=<span class="string">"renderList"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">loading-animation</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:no-more</span>=<span class="string">"noMore"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:data</span>=<span class="string">"renderList"</span> </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我有一个上拉加载更多组件，HTML部分大概是这样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      prevScrollTop: <span class="number">0</span>,</span><br><span class="line">      currentScrollTop: <span class="number">0</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">    _scroll: _.debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.prevScrollTop = <span class="keyword">this</span>.currentScrollTop</span><br><span class="line">    &#125;, <span class="number">700</span>),</span><br><span class="line">    onScroll(&#123; <span class="attr">detail</span>: &#123; scrollTop &#125; &#125;) &#123;</span><br><span class="line">      <span class="keyword">this</span>._scroll()</span><br><span class="line">      <span class="keyword">this</span>.currentScrollTop = scrollTop</span><br><span class="line">    &#125;,</span><br><span class="line">    _onReachBottom: _.debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.noMore) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.pageNum++</span><br><span class="line">      <span class="keyword">this</span>.getData()</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    reachBottom() &#123;</span><br><span class="line">      <span class="keyword">this</span>._onReachBottom()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只贴了关键代码，可以看到我除了绑定了<code>@scrolltolower</code>触底事件，还加了一个滚动事件<code>@scroll</code>、滚动距离属性<code>scroll-top</code>。除此之外还有两个变量，prevScrollTop与currentScrollTop，名字可能不太契合，大概意思就是在滚动后将当前滚动的距离赋值给<code>scroll-view</code>标签。</p><h2 id="await的错误捕获"><a href="#await的错误捕获" class="headerlink" title="await的错误捕获"></a>await的错误捕获</h2><p>最近接手一个别人的写的项目遇到一个问题，请求接口时，当接口正常应答可以正常拿到数据，当接口报错了就拿不到任何东西，打开控制台一看，uncaught (in promise)。于是去看了下封装的请求库，发现了问题，因为封装的很乱，所以我就拿典型的错误举例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">参数</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">request(处理后的参数)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">参数</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">      axios(参数)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;...; resolve(response.data)&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span>=&gt;</span> &#123;...; reject(error)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.req(各种参数)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样咋一看好像没问题，不过有三个比较突出的问题:</p><ul><li>既然封装了 还使用了axios，那么就应该用拦截器，而不是直接用axios来封装</li><li>req函数只是调用了request函数，没有做错误捕捉等处理</li><li>使用async与await来同步化异步操作，但是返回的结果无法区分到底出没出错</li></ul><p>修改:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">参数</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = <span class="keyword">await</span> <span class="keyword">this</span>.request(参数)</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">null</span>, res]</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> [err, res]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">参数</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">      axios(参数)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;...; resolve(response.data)&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span>=&gt;</span> &#123;...; reject(error)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.req(各种参数)</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="comment">// 做接口错误后的相关事宜</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里修改后，用try catch捕获了错误，并且将代码风格改为了error-first，简单明了，让调用后更好区分。</p><h2 id="TypeScript一些总结"><a href="#TypeScript一些总结" class="headerlink" title="TypeScript一些总结"></a>TypeScript一些总结</h2><p>最近使用了nuxt+ts，另外用ts封装了一个代理vuex的库，遇到了一些问题，总结一下</p><h3 id="ts中常用的几种导入方式"><a href="#ts中常用的几种导入方式" class="headerlink" title="ts中常用的几种导入方式"></a>ts中常用的几种导入方式</h3><ul><li><p><code>import something from &#39;something&#39;</code>与 <code>import { something } from &#39;library&#39;</code>同js中一样，最标准的AMD导入，这种方法导入的东西是带有类型校验的，当然，前提是有声明文件。</p></li><li><p><code>import * as $ from &#39;xxx&#39;</code>，这样的导入方式及是将目标文件中所有的<code>export</code>项存入<code>namespace</code>变量$中，调用时均以$.调用，同样有类型校验。</p></li><li><code>import something = require(&#39;something&#39;)</code>，这个调用方式与<code>const something = require(&#39;something&#39;)</code>的区别是前者除了导入模块外，还将它的类型导入了，当你使用ts时，前者导入的<code>something</code>会在使用时进行类型校验，后者则不会，因为ts将后者的类型定义为any。</li></ul><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言并没有强制转换类型，而是让我们做一个选择，一个最简单的例子:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value.length) <span class="keyword">return</span> value.length</span><br><span class="line">  <span class="keyword">return</span> value.toString().length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里编译会出错，因为number类型并没有length属性，访问联合类型时，这个属性必须时两个类型的交集，也就是说length必须是两者都具有的属性才能编译通过。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((&lt;<span class="built_in">string</span>&gt;value).length) <span class="keyword">return</span> (&lt;<span class="built_in">string</span>&gt;value).length</span><br><span class="line">  <span class="keyword">return</span> value.toString().length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用data-set为伪类动态赋值"><a href="#使用data-set为伪类动态赋值" class="headerlink" title="使用data-set为伪类动态赋值"></a>使用data-set为伪类动态赋值</h2><p>之前做了一个页面，四个小模块，每个模块左上角是一个标题，当时并不想为没有什么复杂样式的标题专门写一个标签，因此想到了伪类。code:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"card violation-count"</span> <span class="attr">:data-title</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">v-for</span>=<span class="string">"meta in typeMeta"</span> <span class="attr">:key</span>=<span class="string">"meta.title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123; meta.title &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; meta.count &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">    title: <span class="string">'动态的标题'</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css部分：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: attr(data-title);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就这么简单。此外，我们还可以利用less、sass预编译器的循环功能来为多个伪类赋值。</p><h2 id="在Vue中注销watch监听"><a href="#在Vue中注销watch监听" class="headerlink" title="在Vue中注销watch监听"></a>在Vue中注销watch监听</h2><p>最近做的这个项目数据源只有三个接口，这三个接口的数据会由一个根组件注入到下面的所有子模块中，并且会轮询访问。下面的子模块watch监听到数据变化后更新视图。然后有一个页面的需求是只需要一次监听，赋值，然后就不再监听，这个时候，我们就需要用的<code>$watch</code>了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">()</span>=&gt;</span> []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">const</span> destoryWatch = <span class="keyword">this</span>.$watch(<span class="string">'list'</span>, (newList, oldList)=&gt; &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      destoryWatch()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照vue官网2.x的API所述，$watch监听后会返回一个取消观察函数，执行它之后监听函数将会被销毁。文档详情:<a href="https://cn.vuejs.org/v2/api/#vm-options" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#vm-options</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;uni-app的scroll-view组件触底概率不触发问题&quot;&gt;&lt;a href=&quot;#uni-app的scroll-view组件触底概率不触发问题&quot; class=&quot;headerlink&quot; title=&quot;uni-app的scroll-view组件触底概率不触发问题&quot;&gt;
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://localhost:4000/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>解析后端按位运算的枚举值</title>
    <link href="http://localhost:4000/2020/09/10/%E8%A7%A3%E6%9E%90%E5%90%8E%E7%AB%AF%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%80%BC/"/>
    <id>http://localhost:4000/2020/09/10/%E8%A7%A3%E6%9E%90%E5%90%8E%E7%AB%AF%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%80%BC/</id>
    <published>2020-09-10T01:04:32.000Z</published>
    <updated>2020-09-30T02:18:00.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="位运算枚举值"><a href="#位运算枚举值" class="headerlink" title="位运算枚举值"></a>位运算枚举值</h2><p>位运算的枚举值大概是下面的样子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dictionary = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">'枚举值one'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'枚举值two'</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="string">'枚举值three'</span>,</span><br><span class="line">  <span class="number">8</span>: <span class="string">'枚举值four'</span>,</span><br><span class="line">  <span class="number">16</span>: <span class="string">'枚举值five'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而很多时候枚举值会有叠加，比如该枚举值是指违规项，那么对应的就会存在同时有多种违规，比如同时违反了第一项和第三项，那么后端就会返回枚举值5(1+4)。</p><h2 id="为什么是1、2、4、8"><a href="#为什么是1、2、4、8" class="headerlink" title="为什么是1、2、4、8"></a>为什么是1、2、4、8</h2><p>首先这些数都是十进制，我们说的左移右移是针对二进制来说的，比如0001，我们左移后会变成0010，此时0010转为10进制就是2了，对于2再左移，就会变成0100对应的十进制就是8，以此类推</p><h2 id="解析位运算"><a href="#解析位运算" class="headerlink" title="解析位运算"></a>解析位运算</h2><p>我们并不需要去排列组合，使用JavaScript提供的左移右移操作符可以非常简洁的完成枚举转换，直接来完整的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dictByBit</span>(<span class="params">dictObj, value, separate = <span class="string">'、'</span>, result = <span class="string">""</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(dictObj) != <span class="string">"[object Object]"</span>)  <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dictLocation = []</span><br><span class="line">    <span class="comment">// 将枚举表中每一种可能的枚举值推入一个数组</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(dictObj).forEach(<span class="function"><span class="params">bit</span>=&gt;</span> &#123;</span><br><span class="line">        dictLocation.push(bit)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(dictObj[value]) &#123;</span><br><span class="line">        <span class="keyword">return</span> (result?(result + separate):<span class="string">''</span>) + dictObj[value]</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">       <span class="comment">// 这里我们假设枚举上限到1024，使用该值累加，直到右移后等于1</span></span><br><span class="line">       <span class="keyword">if</span>(value &gt;&gt; i === <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">let</span> afterMove = value - dictLocation[i]</span><br><span class="line">           <span class="keyword">return</span> dictByBit(dictObj, afterMove, separate, (result?(result + separate):<span class="string">''</span>) + dictObj[dictLocation[i]])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里函数接受四个参数</p><ul><li>dictObj: 枚举表</li><li>value: 后端返回的枚举值</li><li>separate: 分隔符，如枚举值同时是3，那么就是1+2，如、分隔符，字典翻译后会返回枚举值1、枚举值2</li><li>result: 这个参数是递归时函数间传递的，调用时不需要</li></ul><p>看一下上面的函数，最重要的部分就是下面for循环后的右移位，我这里以1024位作为(实际不可能枚举到这么多)右移上限。<strong>现在我们假设后端返回了一个枚举值7</strong>，我们的枚举表还是最上方的那个，现在分析这个函数的原理：</p><ul><li>后端返回了一个枚举值为7的的枚举值，那么就一定是1+2+4，对于位运算的枚举，只会有一种结果</li><li>我们将7这个枚举值右移，当我们<strong>右移到值为1时</strong>，就拿到了这个枚举值由?+?+?相加的<strong>最后一位的索引</strong>，我们以此为条件，递归，从最后一位拿到第一位，最后的结果就是2 1 0，这实际是索引。这也是为什么一开始我们要把枚举表中的值依次推入一个数组的原因，我们通过索引便可以直接拿到对应翻译后的值了。</li></ul><p>为什么要右移呢？很简单，因为后端左移了，我们要还原啊！还是以7为例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">0</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="comment">// 2 </span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">2</span> <span class="comment">// 4 </span></span><br><span class="line"><span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>递归函数每次会解析出一个枚举值，比如上面说的7，是1+2+4，那么就会有两次递归，afterMove变量非常重要，因为它保存了本次倒退的枚举值后<strong>剩下的枚举和</strong>。还是用上面的例子来看</p><ul><li>第一次我们传入枚举值7进去后，执行右移，当i = 2时，右移值是1，此时2就是1+2+4的枚举值4，对应dictionary字典中就是”枚举值three“</li><li>我们用7 - 4 = 3，<strong>(这个4就是bit数组[1,2,4,8,16]中的索引2)</strong>，3就是下一轮的枚举和，以同样的方式，3右移1位等于1，那么执行3-2</li><li>最后一轮我们拿到了值1，1本身就是字典中的值了，所以我们结束递归，拿到了7对应的三个结果，也就是1、2、4</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;位运算枚举值&quot;&gt;&lt;a href=&quot;#位运算枚举值&quot; class=&quot;headerlink&quot; title=&quot;位运算枚举值&quot;&gt;&lt;/a&gt;位运算枚举值&lt;/h2&gt;&lt;p&gt;位运算的枚举值大概是下面的样子:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="位运算" scheme="http://localhost:4000/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="JavaScript" scheme="http://localhost:4000/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>记一次后台权限与路由的重构</title>
    <link href="http://localhost:4000/2020/08/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%90%8E%E5%8F%B0%E6%9D%83%E9%99%90%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E9%87%8D%E6%9E%84/"/>
    <id>http://localhost:4000/2020/08/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%90%8E%E5%8F%B0%E6%9D%83%E9%99%90%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E9%87%8D%E6%9E%84/</id>
    <published>2020-08-31T00:39:55.000Z</published>
    <updated>2020-09-30T02:30:04.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要重构"><a href="#为什么要重构" class="headerlink" title="为什么要重构"></a>为什么要重构</h2><p>老实说重构我一直觉得是一件费力不讨好的事儿，但是这次的后台项目路由那块确实太乱了，复制粘贴以前项目的，非常生硬，这也导致权限的验证非常麻烦，因此趁着还没上线，花了大半天给改完了。</p><h2 id="重构的思路"><a href="#重构的思路" class="headerlink" title="重构的思路"></a>重构的思路</h2><p>这个后台管理是有两级菜单的，如下图</p><p><img src="/BeCoderQ.github.io/2020/08/31/记一次后台权限与路由的重构/power-menu.png" alt="菜单结构"></p><p>可以看到有两级菜单，顶层的菜单控制切换模块，并带动左侧的边栏菜单的变化，这里因为项目结构的历史原因，顶部的一级菜单和左侧的菜单是完全分开且没有关系的。那么我的思路大概有以下几步</p><ul><li>在数据上耦合一级菜单与二级菜单</li><li>因为页面并不是特别多，所以菜单就直接通过暴露出的路由元数据来渲染</li><li>权限配置上，因为后台返回的是id，因此这些id可以直接写在路由配置的meta属性中</li><li>在后端返回权限的配置数据，前端对比当前路由后，通过一个resetRouter函数替换路由(替换的路由是剔除掉无权限页面的)</li></ul><p>大体上就是这几个点，下面看代码详细说</p><h2 id="耦合一二级菜单"><a href="#耦合一二级菜单" class="headerlink" title="耦合一二级菜单"></a>耦合一二级菜单</h2><p>耦合两级菜单非常简单，我的办法是使用webpack的require.context方法，通过文件名作为key耦合两级菜单，并存储在vuex中，先看一下路由结构：</p><p><img src="/BeCoderQ.github.io/2020/08/31/记一次后台权限与路由的重构/router-menu.png" alt="路由结构"></p><p>modules文件下是所有路由的元数据，router-config文件是一些配置路由的功能函数，然后再看一下用于存储菜单数据的vuex数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rootMenus: [</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'首页'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/home'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'遥感监测'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/remote-sensing-map'</span>, <span class="attr">id</span>: <span class="string">'remote'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'分表计电'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/product-run'</span>, <span class="attr">id</span>: <span class="string">'electric'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'扬尘监测'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/monitor-map'</span>, <span class="attr">id</span>: <span class="string">'raise-dust'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'OBD监测'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/obd-map'</span>, <span class="attr">id</span>: <span class="string">'obd'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'系统管理'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/car-setting'</span>, <span class="attr">id</span>: <span class="string">'system'</span>, <span class="attr">subs</span>: [] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里id就是对应每个模块的文件名，subs就是二级菜单数组。</p><h3 id="通过require-context完成菜单的合成"><a href="#通过require-context完成菜单的合成" class="headerlink" title="通过require.context完成菜单的合成"></a>通过require.context完成菜单的合成</h3><p>在router-config中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// associateMenu将根据文件名与store中预设的菜单id关联，将顶级菜单与二级菜单结合</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">associateMenu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getState方法是我封装的获取store中state的方法</span></span><br><span class="line">    <span class="keyword">let</span> rootMenus = getState(<span class="string">'cache'</span>, <span class="string">'rootMenus'</span>),</span><br><span class="line">        originRouters = []</span><br><span class="line">    <span class="keyword">const</span> moduleFiles = <span class="built_in">require</span>.context(<span class="string">'./modules'</span>, <span class="literal">true</span>, /\.js$/)</span><br><span class="line">    moduleFiles.keys().map(<span class="function"><span class="keyword">function</span> (<span class="params">modulePath</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(moduleFiles(modulePath).default) &#123;</span><br><span class="line">            originRouters.push(moduleFiles(modulePath).default)</span><br><span class="line">            rootMenus.map(<span class="function"><span class="params">menu</span>=&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// 根据id绑定在一起</span></span><br><span class="line">                <span class="keyword">if</span>(modulePath.includes(menu.id)) &#123;</span><br><span class="line">                    menu.subs = moduleFiles(modulePath).default</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    setState(<span class="string">'cache'</span>, <span class="string">'rootMenus'</span>, rootMenus)</span><br><span class="line">    <span class="comment">// 这里返回一个原始的路由元数据，用于路由的注册</span></span><br><span class="line">    <span class="keyword">return</span> originRouters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在路由的index.js大概是这个样子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; associateMenu &#125; <span class="keyword">from</span> <span class="string">'./router-config'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">const</span> sonMenus = [].concat(...associateMenu())</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'/synthesize'</span>,</span><br><span class="line">        redirect: <span class="string">'/synthesize'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'@/views/frame/Home.vue'</span>),</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">          name: <span class="string">'home'</span>,</span><br><span class="line">          path: <span class="string">'home'</span>,</span><br><span class="line">          component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'@/views/home/index'</span>),</span><br><span class="line">            meta: &#123;</span><br><span class="line">              title: <span class="string">'首页'</span>,</span><br><span class="line">              icon: <span class="string">'el-icon-home'</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">        ...sonMenus</span><br><span class="line">        ]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/'</span>,</span><br><span class="line">redirect: <span class="string">'/login'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">title: <span class="string">'登录'</span>,</span><br><span class="line">path: <span class="string">'/login'</span>,</span><br><span class="line">name: <span class="string">"Login"</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/login/LoginPageNew'</span>),</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'*'</span>,</span><br><span class="line">redirect: <span class="string">'/404'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/404'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/error-page/404'</span>),</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样菜单就做好了，接下来就是权限了</p><h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><p>权限通过vuex中rootMenus中的权限id属性来判断哪些路由会被删除</p><h3 id="动态刷新路由"><a href="#动态刷新路由" class="headerlink" title="动态刷新路由"></a>动态刷新路由</h3><p>首先看一下怎么实现路由的动态刷新:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function">(<span class="params">routes</span>) =&gt;</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">base: process.env.NODE_ENV === <span class="string">'development'</span>?<span class="string">'/'</span>:<span class="string">'/synthesize/'</span>,</span><br><span class="line">routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(routes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限获取后替换路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params">routes</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> newRouter = createRouter(routes)</span><br><span class="line">router.matcher = newRouter.matcher</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里我们通过替换路由的matcher，即匹配规则，实现动态的路由更换，下面根据需要修改上面的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; associateMenu &#125; <span class="keyword">from</span> <span class="string">'./router-config'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">const</span> sonMenus = [].concat(...associateMenu())</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'/synthesize'</span>,</span><br><span class="line">        redirect: <span class="string">'/synthesize'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'@/views/frame/Home.vue'</span>),</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">          name: <span class="string">'home'</span>,</span><br><span class="line">          path: <span class="string">'home'</span>,</span><br><span class="line">          component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'@/views/home/index'</span>),</span><br><span class="line">            meta: &#123;</span><br><span class="line">              title: <span class="string">'首页'</span>,</span><br><span class="line">                icon: <span class="string">'el-icon-home'</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">        ...sonMenus</span><br><span class="line">        ]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/'</span>,</span><br><span class="line">redirect: <span class="string">'/login'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">title: <span class="string">'登录'</span>,</span><br><span class="line">path: <span class="string">'/login'</span>,</span><br><span class="line">name: <span class="string">"Login"</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/login/LoginPageNew'</span>),</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'*'</span>,</span><br><span class="line">redirect: <span class="string">'/404'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/404'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/error-page/404'</span>),</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// createRouter函数接受一个回调函数，将创建一个权限过滤后的路由实例</span></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function">(<span class="params">validate</span>) =&gt;</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">base: process.env.NODE_ENV === <span class="string">'development'</span>?<span class="string">'/'</span>:<span class="string">'/synthesize/'</span>,</span><br><span class="line">routes: <span class="keyword">typeof</span> validate === <span class="string">'function'</span>?validate(routes):routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(routes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限获取后替换路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params">validate</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> newRouter = createRouter(validate)</span><br><span class="line">router.matcher = newRouter.matcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>这里我们修改后的逻辑变成了在调用resetRouter时传入一个验证的回调函数，这个回调函数的参数就是当前所有路由的元数据，在使用时大概是这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> getPower() &#123;</span><br><span class="line">  <span class="keyword">let</span> [err, res] = <span class="keyword">await</span> getPower(&#123; ...params &#125;)</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个就是后台返回的权限树</span></span><br><span class="line">  <span class="keyword">const</span> powerMetas = res.rows</span><br><span class="line">  resetRouter(<span class="function">(<span class="params">routes</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里用routes与powerMetas循环判断id是否存在，不存在则将该路由删除</span></span><br><span class="line">    <span class="keyword">let</span> routesChildren = routes[<span class="number">0</span>].children</span><br><span class="line">    routesChildren.map(<span class="function">(<span class="params">route, index</span>)=&gt;</span> &#123;</span><br><span class="line">      powerMetas.forEach(<span class="function"><span class="params">meta</span>=&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(没有该ID) &#123;</span><br><span class="line">          <span class="comment">// 删除该路由</span></span><br><span class="line">          routesChildren.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 返回一个已经过滤完成的路由</span></span><br><span class="line">    <span class="keyword">return</span> routes</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我通过接口返回的权限树来与当前所有路由进行比对，把权限id不存在的路由删除掉。</p><h3 id="进一步修改"><a href="#进一步修改" class="headerlink" title="进一步修改"></a>进一步修改</h3><p>这里其实并没有做完，因为我们的菜单是根据vuex的rootMenus属性来渲染的，所以我们单纯删除了路由是没有用的，页面上的菜单上还是会有删除的页面，只是点了过后无法访问而已，这样用户体验是很差的。那么，我们要想一个办法让路由的数据与vuex中渲染页面的数据联系起来。</p><h3 id="使用Proxy监听路由的修改"><a href="#使用Proxy监听路由的修改" class="headerlink" title="使用Proxy监听路由的修改"></a>使用Proxy监听路由的修改</h3><p>这里正好可以使用上周博客介绍的Proxy来监听路由，在router-config文件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observeRouter</span>(<span class="params">router</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听代理数组与对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> router === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> router) &#123;</span><br><span class="line">            <span class="comment">// 递归深度代理</span></span><br><span class="line">            <span class="keyword">typeof</span> router[key] === <span class="string">'object'</span> &amp;&amp; (router[key] = observeRouter(router[key]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(router, &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @param &#123;target&#125; 当前对象</span></span><br><span class="line"><span class="comment">         * @param &#123;prop&#125; 设置属性名</span></span><br><span class="line"><span class="comment">         * @param &#123;value&#125; 新的值</span></span><br><span class="line"><span class="comment">         * @param &#123;receiver&#125; 映射时的上下文</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">set</span>(target, prop, value, receiver) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`设置了：<span class="subst">$&#123;prop&#125;</span>属性，修改值：<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="comment">// 以下操作为同步store渲染菜单</span></span><br><span class="line">            <span class="keyword">let</span> newMenus = getState(<span class="string">'cache'</span>, <span class="string">'rootMenus'</span>) || [],</span><br><span class="line">                deleteXy = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="comment">// 这里只处理第二级菜单 顶级菜单在渲染时直接通过v-show隐藏</span></span><br><span class="line">            newMenus.map(<span class="function">(<span class="params">menu, mIdx</span>)=&gt;</span> &#123;</span><br><span class="line">                menu.subs.map(<span class="function">(<span class="params">sub, sIdx</span>)=&gt;</span> &#123;</span><br><span class="line">                  <span class="comment">// receiver是单个路由的配置对象</span></span><br><span class="line">                    <span class="keyword">if</span>(sub.name === receiver.name) &#123;</span><br><span class="line">                        deleteXy = [mIdx, sIdx]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">            newMenus[deleteXy[<span class="number">0</span>]].subs.splice(deleteXy[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 将修改后的数据同步到vuex中</span></span><br><span class="line">            setState(<span class="string">'cache'</span>, <span class="string">'rootMenus'</span>, newMenus)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value, receiver)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意一点，我们通过递归来监听数组对象，当我们删除数组后，Proxy监听会有一个问题，比如我监听的数据是一个包含24个对象的数组，<strong>当我们删除第三个时，这里的监听函数会触发21次，因为第三个的删除导致了数组长度的变化，换句话说，现在这个数组”坍塌”了。</strong>所以，如果我们匹配权限规则时直接去删除路由，会导致我们监听不到具体删除的结果。</p><p>写好了监听函数，那么就在index.js文件中监听路由：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; associateMenu, observeRouter &#125; <span class="keyword">from</span> <span class="string">'./router-config'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">const</span> sonMenus = [].concat(...associateMenu())</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'/synthesize'</span>,</span><br><span class="line">        redirect: <span class="string">'/synthesize'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'@/views/frame/Home.vue'</span>),</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">          name: <span class="string">'home'</span>,</span><br><span class="line">          path: <span class="string">'home'</span>,</span><br><span class="line">          component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'@/views/home/index'</span>),</span><br><span class="line">            meta: &#123;</span><br><span class="line">              title: <span class="string">'首页'</span>,</span><br><span class="line">                icon: <span class="string">'el-icon-home'</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">        ...sonMenus</span><br><span class="line">        ]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/'</span>,</span><br><span class="line">redirect: <span class="string">'/login'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">title: <span class="string">'登录'</span>,</span><br><span class="line">path: <span class="string">'/login'</span>,</span><br><span class="line">name: <span class="string">"Login"</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/login/LoginPageNew'</span>),</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'*'</span>,</span><br><span class="line">redirect: <span class="string">'/404'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/404'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/error-page/404'</span>),</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里代理路由</span></span><br><span class="line"><span class="keyword">let</span> proxyRoutes = observeRouter(routes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// createRouter函数接受一个回调函数，将创建一个权限过滤后的路由实例</span></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function">(<span class="params">validate</span>) =&gt;</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">base: process.env.NODE_ENV === <span class="string">'development'</span>?<span class="string">'/'</span>:<span class="string">'/synthesize/'</span>,</span><br><span class="line">routes: <span class="keyword">typeof</span> validate === <span class="string">'function'</span>?validate(proxyRoutes):proxyRoutes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(proxyRoutes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限获取后替换路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params">validate</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> newRouter = createRouter(validate)</span><br><span class="line">router.matcher = newRouter.matcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>接下来，在刷新路由那里我们就要像这样改一下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> getPower() &#123;</span><br><span class="line">  <span class="keyword">let</span> [err, res] = <span class="keyword">await</span> getPower(&#123; ...params &#125;)</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个就是后台返回的权限树</span></span><br><span class="line">  <span class="keyword">const</span> powerMetas = res.rows</span><br><span class="line">  resetRouter(<span class="function">(<span class="params">routes</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里用routes与powerMetas循环判断id是否存在，不存在则将该路由删除</span></span><br><span class="line">    <span class="keyword">let</span> routesChildren = routes[<span class="number">0</span>].children</span><br><span class="line">    routesChildren.map(<span class="function">(<span class="params">route, index</span>)=&gt;</span> &#123;</span><br><span class="line">      powerMetas.forEach(<span class="function"><span class="params">meta</span>=&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(没有该ID) &#123;</span><br><span class="line">          <span class="comment">// 将该路由的导入文件设置为null</span></span><br><span class="line">          route.component = <span class="literal">null</span></span><br><span class="line">          route.redirect = <span class="string">'/404'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 返回一个已经过滤完成的路由</span></span><br><span class="line">    <span class="keyword">return</span> routes</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把没有权限的路由的component项设置为null，这样页面就时空的了，但是该路由其实还是注册了，用户如果直接输入路径访问并不会跳到404页面，所以后面我们把该路由重定向到了404页面。</p><h2 id="一二级菜单的联动"><a href="#一二级菜单的联动" class="headerlink" title="一二级菜单的联动"></a>一二级菜单的联动</h2><p>前面说了因为一些原因导致一级菜单与二级菜单的文件是分开的，这里我也没有再去改结构，我直接注册了全局事件，通过发布订阅模式实现一级菜单带动二级菜单的效果，另外对于用户直接通过url输入后菜单的变化是通过监听路由等实现的，看看代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// activeIndex是当前激活的一级菜单的索引</span></span><br><span class="line">  activeIndex(index) &#123;</span><br><span class="line">      <span class="comment">// 改变了就直接跳转到对于的菜单</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="keyword">this</span>._cache.rootMenus[index].path)</span><br><span class="line">      <span class="comment">// 触发左侧菜单订阅的root-menu-change事件，将当前菜单的数据传过去</span></span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'root-menu-change'</span>, <span class="keyword">this</span>._cache.rootMenus[index])</span><br><span class="line">&#125;,</span><br><span class="line">  $route: &#123;</span><br><span class="line">      handler(route) &#123;</span><br><span class="line">          <span class="comment">// 顶级菜单耦合路由</span></span><br><span class="line">          <span class="keyword">this</span>._cache.rootMenus &amp;&amp; <span class="keyword">this</span>._cache.rootMenus.forEach(<span class="function">(<span class="params">rMenu, rIdx</span>)=&gt;</span> &#123;</span><br><span class="line">            rMenu.subs.length &amp;&amp; rMenu.subs.forEach(<span class="function"><span class="params">menu</span>=&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(menu.name === route.name) &#123;</span><br><span class="line">                <span class="keyword">this</span>.activeIndex = <span class="string">''</span> + rIdx</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完成！</strong></p><h2 id="one-more-thing"><a href="#one-more-thing" class="headerlink" title="one more thing"></a>one more thing</h2><p>还没完，因为我发现这一套流程在IE上是走不通的，因为Proxy这个API在IE上是不支持的，并且一般的polyfill还搞不定Proxy，我尝试了谷歌开发Proxy-polyfill发现居然没有效果，于是乎又写了一个支持IE的版本:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observeRouterForIE</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="comment">// 递归深度代理</span></span><br><span class="line">            <span class="keyword">typeof</span> target[key] === <span class="string">'object'</span> &amp;&amp; (target[key] = observeRouterForIE(target[key]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(target).forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 赋值避免栈溢出</span></span><br><span class="line">        <span class="keyword">let</span> currentValue = target[key]</span><br><span class="line">        handler[key] = &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>: function() &#123; </span><br><span class="line">                <span class="keyword">return</span> currentValue</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">                currentValue = newVal</span><br><span class="line">                <span class="comment">// 以下操作为同步store渲染菜单</span></span><br><span class="line">                changeMenuByRoutes(target)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperties(target, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，其实就是用defineProperties去劫持数据，这里需要注意一点是像get与set<strong>不要直接操作target[key]</strong>，为什么呢？因为你已经劫持了这个对象，当你return target[key]时又会触发一次getter，这样不就套娃了吗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要重构&quot;&gt;&lt;a href=&quot;#为什么要重构&quot; class=&quot;headerlink&quot; title=&quot;为什么要重构&quot;&gt;&lt;/a&gt;为什么要重构&lt;/h2&gt;&lt;p&gt;老实说重构我一直觉得是一件费力不讨好的事儿，但是这次的后台项目路由那块确实太乱了，复制粘贴以前项目的，非常生
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Proxy" scheme="http://localhost:4000/tags/Proxy/"/>
    
      <category term="Vue" scheme="http://localhost:4000/tags/Vue/"/>
    
      <category term="重构" scheme="http://localhost:4000/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>柯里化函数</title>
    <link href="http://localhost:4000/2020/08/24/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    <id>http://localhost:4000/2020/08/24/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-24T12:10:33.000Z</published>
    <updated>2020-09-01T03:14:39.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h2><p>假设我们有一个求两个数和的函数，那么一般情况下他的调用的是这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sum(a, b)</span><br></pre></td></tr></table></figure><p>我们将这个函数柯里化:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(a)(b)</span><br></pre></td></tr></table></figure><p>柯里化不会调用函数，只是对函数进行转换。</p><h2 id="最简单的柯里化"><a href="#最简单的柯里化" class="headerlink" title="最简单的柯里化"></a>最简单的柯里化</h2><p>就拿两数求和的例子来说:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(a, b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这个很简单，curry函数接受一个回调后返回第一层函数，第一层函数执行后返回第二层，第二层执行后将a,b参数传入回调函数fn</p><h2 id="无限求和柯里化"><a href="#无限求和柯里化" class="headerlink" title="无限求和柯里化"></a>无限求和柯里化</h2><p>接下来完成一个函数，实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.reduce(<span class="function">(<span class="params">p,n</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p+n</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)() <span class="comment">// 6</span></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)() <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>注意，这里柯里化后的函数其实还有个执行的花括号，是没有传参，因此在花括号前面我们拿到的应该是所有参数的合集，最后的花括号代表fn(1,2,3,4,5…)这样的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">p,n</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p+n</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">currySum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这是第二个括号开始的返回函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否该完结此次柯里化</span></span><br><span class="line">            <span class="keyword">if</span>(!args2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 反之则继续递归</span></span><br><span class="line">            <span class="keyword">return</span> currySum.apply(<span class="keyword">this</span>, [...args, ...args2])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)() <span class="comment">// 6 </span></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)() <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>这里有几个点需要注意:</p><ul><li>通过第二个返回函数中的参数args2来判断是否完结柯里化</li><li>完结后的参数是args而不是args2，args2永远只是最新的一次调用传参</li><li>没有完结柯里化时递归调用外层的返回函数，并且要将上一次的参数合并</li></ul><h3 id="无限求和柯里化扩展–去掉后面的括号"><a href="#无限求和柯里化扩展–去掉后面的括号" class="headerlink" title="无限求和柯里化扩展–去掉后面的括号"></a>无限求和柯里化扩展–去掉后面的括号</h3><p>上面的例子里面最后总是要打一个括号来执行函数，下面优化一下实现currySum(1)(2)(3)直接输出6的效果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">currySum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里声明函数 赋给一个变量</span></span><br><span class="line">        <span class="keyword">let</span> sumFn = <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!args2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> currySum(...args.concat(args2))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点，我们重写了sumFn函数toString方法，让他返回sumFn函数的执行结果</span></span><br><span class="line">        sumFn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sumFn()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumFn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">p,n</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p+n</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是柯里化&quot;&gt;&lt;a href=&quot;#什么是柯里化&quot; class=&quot;headerlink&quot; title=&quot;什么是柯里化&quot;&gt;&lt;/a&gt;什么是柯里化&lt;/h2&gt;&lt;p&gt;假设我们有一个求两个数和的函数，那么一般情况下他的调用的是这样:&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="柯里化" scheme="http://localhost:4000/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
      <category term="currying" scheme="http://localhost:4000/tags/currying/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Proxy与Reflect</title>
    <link href="http://localhost:4000/2020/08/20/ES6-Proxy%E4%B8%8EReflect/"/>
    <id>http://localhost:4000/2020/08/20/ES6-Proxy%E4%B8%8EReflect/</id>
    <published>2020-08-20T07:02:17.000Z</published>
    <updated>2020-08-28T01:46:19.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy包装对象的方法</p><table><thead><tr><th>内部方法</th><th>Handler方法</th><th>何时触发</th></tr></thead><tbody><tr><td>[[Get]]</td><td>get</td><td>读取属性</td></tr><tr><td>[[Set]]</td><td>set</td><td>写入属性</td></tr><tr><td>[[HasProperty]]</td><td>has</td><td>in操作符(key in obj)</td></tr><tr><td>[[Delete]]</td><td>deleteProperty</td><td>delete操作符</td></tr><tr><td>[[Call]]</td><td>apply</td><td>函数调用上下文绑定</td></tr><tr><td>[[Construct]]</td><td>construct</td><td>new操作符，构造函数</td></tr><tr><td>[[GetPrototypeOf]]</td><td>getPrototypeOf</td><td>Object.getPrototypeOf</td></tr><tr><td>[[SetPrototypeOf]]</td><td>setPrototypeOf</td><td>Object.setPrototypeOf</td></tr><tr><td>[[IsExtensible]]</td><td>isExtensible</td><td>Object.isExtensible(决定对象是否可扩展)</td></tr><tr><td>[[PreventExtensions]]</td><td>preventExtensions</td><td>Object.preventExtensions</td></tr><tr><td>[[DefineOwnProperty]]</td><td>defineProperty</td><td>Object.defineProperty/defineProperties</td></tr><tr><td>[[GetOwnProperty]]</td><td>getOwnPropertyDescriptor</td><td>Object.getOwnPropertyDescriptor,<br>for…in/Object.keys/Object.values/Object.entries</td></tr><tr><td>[[OwnPropertyKeys]]</td><td>ownKeys</td><td>Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object/keys/values/entries</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>这里我们用get、set和deleteProperty作为例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  userName: <span class="string">'Chow'</span>,</span><br><span class="line">  _userId: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`读取属性:<span class="subst">$&#123;prop&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, prop, value) &#123;</span><br><span class="line">      <span class="keyword">if</span>(target[prop].startsWith(<span class="string">'_'</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">'can not change value'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          target[prop] = value</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  deleteProperty(target, prop) &#123;</span><br><span class="line">      <span class="keyword">if</span>(target[prop].startsWith(<span class="string">'_'</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">'can not delete property that start with _'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">delete</span> target[prop]</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在无法删除以下划线开头的key</span></span><br><span class="line"><span class="keyword">const</span> name = user.userName <span class="comment">// 输出 读取属性:userName</span></span><br><span class="line">user._userId = <span class="number">321</span> <span class="comment">// throw error: can not change value</span></span><br><span class="line"><span class="keyword">delete</span> user._userId <span class="comment">// throw error: can not delete property that start with _</span></span><br></pre></td></tr></table></figure><p>当读取值时会打印读取的属性名，当字段以_开头时将无法删除与修改</p><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>在上面的例子中，可以如预期的得到结果，但是如果存在函数，就会发生意外：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    _name: <span class="string">"User"</span>,</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop] <span class="comment">// target = user</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">    __proto__: userProxy,</span><br><span class="line">    _name: <span class="string">"Admin"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(admin.name) <span class="comment">// 输出 "User"</span></span><br></pre></td></tr></table></figure><p>这里我们的本意是让admin继承user对象，访问admin.name时打印出”Admin”，但最后输出的结果却是”User”，分析一下过程：</p><ul><li>user对象中设置了getter，返回私有属性_name</li><li>user被代理，设置了getter拦截器，返回target[prop]，这里的target是user</li><li>创建admin对象并继承代理后的user对象</li><li>调用admin.name，admin中没有name属性，便顺着原型链找到userProxy</li><li>于是调用代理userProxy的name属性，再次触发getter拦截器，这个时候会从原始对象中返回target[prop]，此时的target还是user</li></ul><p>也就是说我们调用admin.name最后执行的还是user.name！</p><h3 id="使用Reflect解决指向问题"><a href="#使用Reflect解决指向问题" class="headerlink" title="使用Reflect解决指向问题"></a>使用Reflect解决指向问题</h3><p>在proxy代理的拦截器中，有一个receiver参数，通过它我们能够取到正确的上下文环境:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    _name: <span class="string">"User"</span>,</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, prop, receiver) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">    __proto__: userProxy,</span><br><span class="line">    _name: <span class="string">"Admin"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(admin.name) <span class="comment">// 输出 "Admin"</span></span><br></pre></td></tr></table></figure><p>这里的receiver就是admin对象了，因此admin.name正确输出了”Admin”</p><h2 id="Proxy的限制"><a href="#Proxy的限制" class="headerlink" title="Proxy的限制"></a>Proxy的限制</h2><p>对于对象数组我们可以直接监听，对于对象数组，我们也可以通过递归遍历来监听：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observeObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听代理数组与对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="comment">// 递归深度代理</span></span><br><span class="line">            <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> &amp;&amp; (obj[key] = observeRouter(obj[key]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = [</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">'zhou'</span>, <span class="attr">job</span>: <span class="string">'programmer'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'li'</span>, <span class="attr">job</span>: <span class="string">'teacher'</span> &#125;                     </span><br><span class="line">]                     </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personProxy = observeObject(person) <span class="comment">// 代理复杂数组</span></span><br></pre></td></tr></table></figure><p>但是一些内建对象，如<strong>Map</strong>、<strong>Set</strong>、<strong>Date</strong>、<strong>Promise</strong>等都是用了<strong>内部插槽(Internal slot)</strong>。</p><h3 id="内建属性的内部插槽"><a href="#内建属性的内部插槽" class="headerlink" title="内建属性的内部插槽"></a>内建属性的内部插槽</h3><p>如<strong>Map</strong>对象，他的内部成员被放在<strong>[[MapData]]</strong>中，诸如<strong>get</strong>内建方法能够不使用<strong>[[Get]]</strong>直接访问到其中的属性，从上面的Proxy表可以看到，get拦截器是通过<strong>[[Get]]</strong>内建方法来拦截getter，因此Proxy无法拦截它们。所以如果我们像下面这样直接代理Map是行不通的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), mapProxy</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'zhou'</span>)</span><br><span class="line">mapProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">mapProxy.get(<span class="string">'name'</span>) <span class="comment">// 报错：Uncaught TypeError: Method Map.prototype.get called on incompatible receiver [object Object]</span></span><br></pre></td></tr></table></figure><p>代理对象没有<strong>[[MapData]]</strong>插槽，调用mapProxy.get后，内建方法会调用<strong>Map.prototype.get去访问this.[[MapData]]</strong>，但此时this是proxy，proxy中并没有该插槽，因此报错。</p><h3 id="解决部分内建对象无法代理"><a href="#解决部分内建对象无法代理" class="headerlink" title="解决部分内建对象无法代理"></a>解决部分内建对象无法代理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), mapProxy</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'zhou'</span>)</span><br><span class="line">mapProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop, receiver) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Reflect</span>.get(target, prop, receiver)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'function'</span>?value.bind(target):value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mapProxy.get(<span class="string">'name'</span>) <span class="comment">// 输出：zhou</span></span><br></pre></td></tr></table></figure><p>现在我们把this绑定到了Map对象上，代理的Map正常工作了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Proxy&quot;&gt;&lt;a href=&quot;#Proxy&quot; class=&quot;headerlink&quot; title=&quot;Proxy&quot;&gt;&lt;/a&gt;Proxy&lt;/h2&gt;&lt;p&gt;Proxy包装对象的方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内部方法&lt;/th&gt;
&lt;th&gt;Ha
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Proxy" scheme="http://localhost:4000/tags/Proxy/"/>
    
      <category term="Reflect" scheme="http://localhost:4000/tags/Reflect/"/>
    
  </entry>
  
  <entry>
    <title>Typescript再体验---一些开发中的杂谈</title>
    <link href="http://localhost:4000/2020/08/10/Typescript%E5%86%8D%E4%BD%93%E9%AA%8C-%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%9D%82%E8%B0%88/"/>
    <id>http://localhost:4000/2020/08/10/Typescript%E5%86%8D%E4%BD%93%E9%AA%8C-%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%9D%82%E8%B0%88/</id>
    <published>2020-08-10T12:13:37.000Z</published>
    <updated>2020-08-10T12:49:47.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="keyof映射"><a href="#keyof映射" class="headerlink" title="keyof映射"></a>keyof映射</h2><p>keyof这个关键字在ts中很有用，可以看一下官方的Readonly Partial type：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Readonly将interface或type中的所有属性转为只读项</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: ReadOnly&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'chow'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">22</span> <span class="comment">// 编译报错 因为age是只读属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial将interface或type中的所有属性转为非必选项</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以只传入一个属性甚至不传</span></span><br><span class="line"><span class="keyword">const</span> person: Partial&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'chow'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个例子，一个非常严谨的字典读取函数:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValue(&#123; name: <span class="string">'chow'</span> &#125;, <span class="string">'name'</span>) <span class="comment">// chow</span></span><br></pre></td></tr></table></figure><p>同样是使用了泛型 keyof</p><h2 id="使用装饰器封装防抖函数"><a href="#使用装饰器封装防抖函数" class="headerlink" title="使用装饰器封装防抖函数"></a>使用装饰器封装防抖函数</h2><p>最近我开发自己的博客有一个上拉加载的功能，我使用了防抖包装，但后面一个输入框又需要防抖，于是我打算用装饰器封装，达到一下效果</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    components: &#123; LoadingWaves &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Article <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">    <span class="keyword">private</span> loading: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> noMore: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> pageNum: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 只需传入延迟时间</span></span><br><span class="line">    <span class="meta">@debounce</span>(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">public</span> loadMore() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.noMore) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">this</span>.pageNum++</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">this</span>.getArticle()</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay: <span class="built_in">number</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer: <span class="built_in">number</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 一定要先将本次执行的函数拷贝到变量中</span></span><br><span class="line">        <span class="keyword">const</span> aimFunction = descriptor.value</span><br><span class="line">        descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> args: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">            <span class="keyword">if</span>(timer) clearTimeout(timer)</span><br><span class="line">          <span class="comment">// 第一个是上下文环境，拷贝后续参数</span></span><br><span class="line">            args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">                aimFunction.apply(<span class="keyword">this</span>, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要明确，ts中函数装饰器会拿到三个参数:</p><ul><li>target，装饰函数所在类的构造函数</li><li>key，该函数的名称，即Function.name</li><li>descriptor，即Object.defineProperty() 的第三个参数 descrideptor</li></ul><p>这里为了接受自定义参数，我们用了闭包，返回了一个函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;keyof映射&quot;&gt;&lt;a href=&quot;#keyof映射&quot; class=&quot;headerlink&quot; title=&quot;keyof映射&quot;&gt;&lt;/a&gt;keyof映射&lt;/h2&gt;&lt;p&gt;keyof这个关键字在ts中很有用，可以看一下官方的Readonly Partial type：&lt;/
      
    
    </summary>
    
    
      <category term="经验" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="Typescript" scheme="http://localhost:4000/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>uni-app中利用webview标签使用原生js高德地图</title>
    <link href="http://localhost:4000/2020/07/17/uni-app%E4%B8%AD%E5%88%A9%E7%94%A8webview%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    <id>http://localhost:4000/2020/07/17/uni-app%E4%B8%AD%E5%88%A9%E7%94%A8webview%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/</id>
    <published>2020-07-17T01:54:16.000Z</published>
    <updated>2020-07-17T04:19:43.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用原生的js高德地图"><a href="#为什么要使用原生的js高德地图" class="headerlink" title="为什么要使用原生的js高德地图"></a>为什么要使用原生的js高德地图</h2><p>首先说一下原因，虽然uni-app自带的map也是高德地图，但是这地图确实太鸡肋了，很多功能都没有，自定义的程度也很低，并且犹豫是底层的，因此无法简单的通过z-index设置显示层级。而高德官方的js地图就非常友好了，并且功能齐全，自定义程度高。</p><h2 id="为什么要使用webview"><a href="#为什么要使用webview" class="headerlink" title="为什么要使用webview"></a>为什么要使用webview</h2><p>因为在uni-app中，打包后的手机环境是没有docment对象或是window对象等一些列我们常用的api，没有document对象我们就无法将高德地图的api以script标签的形式引入，这样我们就拿不到AMap的实例了。而使用webview控件，我们可以引入自己的html文件，我们在这个html文件里用script标签引入高德地图便可：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#map-container</span> &#123;</span></span><br><span class="line">width: 100vw;</span><br><span class="line">height: 100vh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://webapi.amap.com/maps?v=1.4.15&amp;key=********&amp;plugin=Map3D,AMap.DistrictLayer,AMap.Scale,AMap.ToolBar"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/webview.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/map.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"map-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要使用原生的js高德地图&quot;&gt;&lt;a href=&quot;#为什么要使用原生的js高德地图&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用原生的js高德地图&quot;&gt;&lt;/a&gt;为什么要使用原生的js高德地图&lt;/h2&gt;&lt;p&gt;首先说一下原因，虽然uni-app自
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="uni-app" scheme="http://localhost:4000/tags/uni-app/"/>
    
      <category term="高德地图" scheme="http://localhost:4000/tags/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>flutter页面重绘问题解决方案</title>
    <link href="http://localhost:4000/2020/07/11/flutter%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://localhost:4000/2020/07/11/flutter%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-07-11T05:54:10.000Z</published>
    <updated>2020-07-11T05:57:10.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IndexedStack"><a href="#IndexedStack" class="headerlink" title="IndexedStack"></a>IndexedStack</h2><p>IndexedStack组件继承自Stack，两个参数</p><ul><li>Index: 当前显示的组件列表中的的第几个</li><li>children: 渲染页面的组件列表</li></ul><p>使用:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">   <span class="built_in">int</span> currentIndex;</span><br><span class="line">   <span class="built_in">List</span>&lt;Widget&gt; pages = [Pages1(), Pages2(), Pages3()];</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   Widget build(BuildContext context) &#123;</span><br><span class="line">   <span class="keyword">return</span> Scaffold(</span><br><span class="line">     appBar: AppBar(</span><br><span class="line">       title: Text(<span class="string">'demo'</span>),</span><br><span class="line">     ),</span><br><span class="line">     bottomNavigationBar: BottomNavigationBar(</span><br><span class="line">       items: items, currentIndex: currentIndex, onTap: onTap),</span><br><span class="line">     body: IndexedStack(</span><br><span class="line">       index: currentIndex,</span><br><span class="line">       children: pages</span><br><span class="line">     )</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在方法配置最简单，但是一进入程序就会直接将pages列表中引用的所有组件都初始化，这样一个是性能消耗问题，另外如果某个页面是有进入动画的，那么在初始化时动画也会被执行，之后再点击去就没有动画了。</p><h2 id="Offstage"><a href="#Offstage" class="headerlink" title="Offstage"></a>Offstage</h2><p>此方法实际是配置隐藏组件，也是两个参数:</p><ul><li><p>Offstage: 设置组件<strong>隐藏</strong>的条件</p></li><li><p>child: 组件</p></li></ul><p>使用：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBar</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _TabBarState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TabBarState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TabBar</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 在此定义当前tab的索引</span></span><br><span class="line">  <span class="built_in">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">"wave"</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primaryColor: Colors.white</span><br><span class="line">      ),</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: PreferredSize(</span><br><span class="line">          child: (AppBar(title: Text(<span class="string">"标题"</span>), leading: Icon(Icons.list, color: Colors.black), centerTitle: <span class="keyword">true</span>)),</span><br><span class="line">          preferredSize: Size.fromHeight(<span class="number">50</span>)</span><br><span class="line">        ),</span><br><span class="line">        body: Stack(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Offstage(</span><br><span class="line">              offstage: currentIndex != <span class="number">0</span>,</span><br><span class="line">              child: FollowPage(),</span><br><span class="line">            ),</span><br><span class="line">            Offstage(</span><br><span class="line">              offstage: currentIndex != <span class="number">1</span>,</span><br><span class="line">              child: NextPage(),</span><br><span class="line">            ),</span><br><span class="line">            Offstage(</span><br><span class="line">              offstage: currentIndex != <span class="number">2</span>,</span><br><span class="line">              child: MinePage(),</span><br><span class="line">            )</span><br><span class="line">          ]</span><br><span class="line">        ),</span><br><span class="line">        ...</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Offstage组件问题和IndexedStack一样，初始就会将所有空间都渲染了，只是会根据规则隐藏部分。对于有动画的部分使用此空间会导致动画无效。</p><h2 id="AutomaticKeepAliveClientMixin"><a href="#AutomaticKeepAliveClientMixin" class="headerlink" title="AutomaticKeepAliveClientMixin"></a>AutomaticKeepAliveClientMixin</h2><p>AutomaticKeepAliveClientMixin是一个Mixin混入类，使用它能够实现上面两个方法无法完成的效果:</p><ul><li>缓存页面，但不会一开始就把所有页面都渲染。</li><li>只有第一次进入页面时才会渲染页面，触发initState等钩子函数。</li></ul><p>也就是说使用混入类AutomaticKeepAliveClientMixin达成的效果就像我们使用Vue中的页面缓存技术一样，接下来看一下使用方法:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'components/wb-list.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FollowPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; FollowPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FollowPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FollowPage</span>&gt; <span class="title">with</span> <span class="title">AutomaticKeepAliveClientMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在外层定义滚动controller 以便在此控制页面返回顶部</span></span><br><span class="line">  ScrollController _scrollController = ScrollController();</span><br><span class="line"><span class="keyword">final</span> GlobalKey&lt;WBListState&gt; _wbListKey = <span class="keyword">new</span> GlobalKey&lt;WBListState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写AutomaticKeepAliveClientMixin的wantKeepAlive的getter，此属性默认是false</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> wantKeepAlive =&gt; <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 在重写的build方法内一定要注意调用父类的build方法！</span></span><br><span class="line">    <span class="keyword">super</span>.build(context);</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Flexible(</span><br><span class="line">          child: WBList(</span><br><span class="line">            fetchData: wbList,</span><br><span class="line">            scrollController: _scrollController,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下使用AutomaticKeepAliveClientMixin需要注意几点：</p><ul><li><p>重写wanKeepAlive的getter，并返回true</p></li><li><p>在build函数内调用父类的build方法。</p></li><li><p>需要注意，如果你使用类似BottomNavigationBar这种使用底栏进行页面切换，并且切换的页面使用import导入，那么AutomaticKeepAliveClientMixin不能写在BottomNavigationBar所在的父页面！务必进入每个导入的页面为他们书写以上代码。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IndexedStack&quot;&gt;&lt;a href=&quot;#IndexedStack&quot; class=&quot;headerlink&quot; title=&quot;IndexedStack&quot;&gt;&lt;/a&gt;IndexedStack&lt;/h2&gt;&lt;p&gt;IndexedStack组件继承自Stack，两个参数&lt;/p
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="flutter" scheme="http://localhost:4000/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>vue开发中的实用技巧</title>
    <link href="http://localhost:4000/2020/06/22/vue%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://localhost:4000/2020/06/22/vue%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2020-06-22T11:51:23.000Z</published>
    <updated>2020-07-04T03:01:46.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-cli中区分开发、生产环境"><a href="#Vue-cli中区分开发、生产环境" class="headerlink" title="Vue.cli中区分开发、生产环境"></a>Vue.cli中区分开发、生产环境</h2><p>对于在vue脚手架中区分开环境，我一直用的下面的方法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">baseUrl: process.env.NODE_ENV === <span class="string">'development'</span>? xxx.com : yyy.com</span><br></pre></td></tr></table></figure><p>这个方法没毛病，能正常运行，不过还有一种更好的方式，我们可以在项目的根目录创建两个文件:</p><p><img src="/BeCoderQ.github.io/2020/06/22/vue开发中的实用技巧/struct.png" alt="结构"></p><p>.env.production文件与.env.development文件分别是生产环境与开发环境对应的文件，在我们run dev时后者会生效，run build时前者会生效，然后我们利用这点可以轻松的实现类似下面的操作:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在两个文件中我们都设置一个地址变量 当然地址的路径会根据环境而不同</span></span><br><span class="line">VUE_APP_BASE_API = <span class="string">"http://xxx.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来在axios的配置文件中</span></span><br><span class="line">...</span><br><span class="line">baseUrl: process.env.VUE_APP_BASE_API</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样就完成了生产环境与开发环境的区分。</p><h2 id="巧妙利用ref钩子"><a href="#巧妙利用ref钩子" class="headerlink" title="巧妙利用ref钩子"></a>巧妙利用ref钩子</h2><p>在实际业务中，会遇到一些复杂的页面，这些页面我们会把组件抽离出来，那么就会存在参数传递，事件触发等问题，对于上述问题，合理利用ref钩子可以少写不少代码，下面看例子。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"$refs['deal-violation'].onDeal(row)"</span>&gt;</span></span><br><span class="line">          立即处理</span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">electric-deal-violation</span> <span class="attr">ref</span>=<span class="string">"deal-violation"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在子组件内部</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">      onDeal(data) &#123;</span><br><span class="line">          <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的好处是我们让父子通信后子组件的逻辑能在自己内部完成，降低了与父组件的耦合度。需要注意的是，这样的操作并不是所有情况都适用：</p><ul><li><p>如果父组件与子组件有较多的数据来源，那么还是适用props传参，因为这样能一目了然哪些数据会影响子组件。</p></li><li><p>嵌套超过一层的组件不宜使用该方法。</p></li></ul><h2 id="使用-attrs属性二次封装组件"><a href="#使用-attrs属性二次封装组件" class="headerlink" title="使用$attrs属性二次封装组件"></a>使用$attrs属性二次封装组件</h2><p>$attrs这个属性内部是父组件向子组件传递的参数，当然，不包含在子组件内通过props属性注册的。一般我们在嵌套组件内会使用$attrs属性。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里我们二次封装一个elementui的表格+分页组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"pagination"</span> </span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">                <span class="attr">layout</span>=<span class="string">"total, prev, pager, next"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">:total</span>=<span class="string">"total"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">:page-size</span>=<span class="string">"pageSize"</span></span></span><br><span class="line"><span class="tag">                @<span class="attr">current-change</span>=<span class="string">"pageChange"</span></span></span><br><span class="line"><span class="tag">                @<span class="attr">prev-click</span>=<span class="string">"pageChange"</span></span></span><br><span class="line"><span class="tag">                @<span class="attr">next-click</span>=<span class="string">"pageChange"</span></span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们只接收分页的属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 这里只接收了sonTitle属性</span></span><br><span class="line">  props: &#123;</span><br><span class="line">      total: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        pageSize: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们在el-table标签上使用了$attrs属性，这样我们在外部调用这个组件的时候，就能够像直接使用el-table一样传递各种诸如data等属性，除了声明的total与pageSize属性，其他都会被放当$attrs里传递给el-table。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue-cli中区分开发、生产环境&quot;&gt;&lt;a href=&quot;#Vue-cli中区分开发、生产环境&quot; class=&quot;headerlink&quot; title=&quot;Vue.cli中区分开发、生产环境&quot;&gt;&lt;/a&gt;Vue.cli中区分开发、生产环境&lt;/h2&gt;&lt;p&gt;对于在vue脚手架中
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue.cli4" scheme="http://localhost:4000/tags/vue-cli4/"/>
    
      <category term="vue" scheme="http://localhost:4000/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue.cli4版本下跨域代理配置与数据mock</title>
    <link href="http://localhost:4000/2020/05/27/vue-cli4%E7%89%88%E6%9C%AC%E4%B8%8B%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%95%B0%E6%8D%AEmock/"/>
    <id>http://localhost:4000/2020/05/27/vue-cli4%E7%89%88%E6%9C%AC%E4%B8%8B%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%95%B0%E6%8D%AEmock/</id>
    <published>2020-05-27T08:09:01.000Z</published>
    <updated>2020-05-31T11:57:07.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="proxy代理配置"><a href="#proxy代理配置" class="headerlink" title="proxy代理配置"></a>proxy代理配置</h2><p>最近搭了一个项目的架子，接口请求库用的axios，第一个测试接口就给扔了CORS，于是打开vue.config.js文件配置代理服务:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js中</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">port: port,</span><br><span class="line">    open: <span class="literal">false</span>, <span class="comment">// 是否在run起来后自动打开浏览器</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 开启热重载</span></span><br><span class="line">    overlay: &#123;</span><br><span class="line">         warnings: <span class="literal">false</span>,</span><br><span class="line">         errors: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/proxy'</span>: &#123; <span class="comment">// 匹配的地址</span></span><br><span class="line">        target: <span class="string">'真实的请求地址, 如https://real-request-address.com/api...'</span>,</span><br><span class="line">          changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 路径重写，这里就给个空的，因为我配置的方式会让/proxy直接放到请求路径里，所以那并不是真实路径。因此这里重写为空。</span></span><br><span class="line">            pathRewrite: &#123;<span class="string">'^/proxy'</span>: <span class="string">''</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>我是用的是axios，自己根据需求二次封装了，配置项大概在如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 基础url前缀</span></span><br><span class="line">    baseURL: <span class="string">'/proxy'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好后就能直接使用了，需要注意，这里baseUrl设置为vue.config.js中代理所匹配的路径即可。请求发送后，我们看到的请求路径就是本地路径，但实际已经被代理了，能够正常发送并接受返回值了。</p><h2 id="利用脚手架自带的express实现前后端分离"><a href="#利用脚手架自带的express实现前后端分离" class="headerlink" title="利用脚手架自带的express实现前后端分离"></a>利用脚手架自带的express实现前后端分离</h2><p>我的vue.cli4自带了express，同样是在vue.config.js文件中，我们可以通过拦截请求，并使用express实现前端后端分离。首先看一下我的请求文件结构:</p><p><img src="/BeCoderQ.github.io/2020/05/27/vue-cli4版本下跨域代理配置与数据mock/construct.png" alt="请求元数据结构"></p><h3 id="api文件中"><a href="#api文件中" class="headerlink" title="api文件中"></a>api文件中</h3><p>在api里的modules文件下有所有按模块分好的请求地址文件，每个文件内是这样的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apis = &#123;</span><br><span class="line">    <span class="string">"login"</span>: &#123; <span class="attr">url</span>: <span class="string">"/ad/user/auth"</span>, <span class="attr">noToken</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="comment">// 这里的mock后面会解释</span></span><br><span class="line">  <span class="string">"list"</span>: &#123; <span class="attr">url</span>: <span class="string">"/ad/user/list"</span>, <span class="attr">mock</span>: &#123;</span><br><span class="line">      code: <span class="number">0</span>,</span><br><span class="line">      data: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'zhou'</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'ming'</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default apis </span></span><br><span class="line"><span class="built_in">module</span>.exports = apis</span><br></pre></td></tr></table></figure><p>这里不用export导出而用common.js的导出规则是因为还需要在node环境的文件里取到这些元数据。</p><p>下面的index.js文件会将所有接口文件的文件名与文件内的接口地址耦合:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apiMap = &#123;&#125;</span><br><span class="line"><span class="comment">// 这个fileName用于存储modules下所有文件的文件名</span></span><br><span class="line"><span class="keyword">let</span> fileName = []</span><br><span class="line"><span class="comment">/* 利用webpack的require.context加载modules下所有的接口文件 */</span></span><br><span class="line"><span class="keyword">var</span> moduleFiles = <span class="built_in">require</span>.context(<span class="string">'./modules'</span>, <span class="literal">true</span>, /\.js$/)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取模块下的api配置对象</span></span><br><span class="line"><span class="comment"> * @param moduleName 模块文件名</span></span><br><span class="line"><span class="comment"> * @param apiName 文件下api模块名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">moduleFiles.keys().map(<span class="function"><span class="keyword">function</span>(<span class="params">modulePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleName = modulePath.substr(modulePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, modulePath.length - <span class="number">5</span>)</span><br><span class="line">    fileName.push(moduleName)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里因为modules下的文件都是以module.exports导出，所以要用require的方式拿到导出值</span></span><br><span class="line">fileName.forEach(<span class="function"><span class="params">name</span>=&gt;</span> &#123;</span><br><span class="line">    apiMap[name] = <span class="built_in">require</span>(<span class="string">`./modules/<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里导处的结果将为我封装的axios所用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apiMap</span><br></pre></td></tr></table></figure><p>这样封装的结果就是让我的axios可以以如下的方式调用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$api.user.login(&#123; <span class="string">'这里传递post参数'</span> &#125;, 这里传递query参数).then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">  成功请求并按照了规定的返回code</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span> &#123;</span><br><span class="line">  请求返回有任何错误或在拦截器中有任何异常</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么，我请求的环境就交代清楚了，接下来就是核心部分了</p><h3 id="在vue-config中拿到元数据并拦截请求"><a href="#在vue-config中拿到元数据并拦截请求" class="headerlink" title="在vue.config中拿到元数据并拦截请求"></a>在vue.config中拿到元数据并拦截请求</h3><p>这一步就是为什么在api的modules文件下，我的所有请求数据都以module.exports方式导出的原因了，因为vu e.config.js文件是纯node环境下运行，像require.context这种api是用不了的！好了直接看代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在最外层，我们要拿到所有接口的数据</span></span><br><span class="line"><span class="keyword">let</span> apiModules = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里要读取modules下的api文件名</span></span><br><span class="line">    <span class="keyword">let</span> files = fs.readdirSync(resolve(<span class="string">'/src/api/modules'</span>))</span><br><span class="line">    <span class="comment">// 拿到所有文件名后放入变量中</span></span><br><span class="line">    files.forEach(<span class="function"><span class="params">fName</span>=&gt;</span> &#123;</span><br><span class="line">      apiModules.push(<span class="built_in">require</span>(resolve(<span class="string">`/src/api/modules/<span class="subst">$&#123;fName&#125;</span>`</span>)))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是读取文件要用同步读取，否则后面express部分代码执行时可能文件还没读取完。</p><p>接下来在configureWebpack属性下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">            before(app) &#123;</span><br><span class="line">              <span class="comment">// 这是我导入的配置文件，这个文件内配置是否需要mock数据</span></span><br><span class="line">                <span class="keyword">if</span>(!defaultSettings.enableMock) <span class="keyword">return</span></span><br><span class="line">              <span class="comment">// 这就是前面拿到的文件名数组</span></span><br><span class="line">                apiModules.forEach(<span class="function"><span class="params">modules</span>=&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">Object</span>.keys(modules).forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(modules[key].mock) &#123;</span><br><span class="line">                            app.post(<span class="string">`/proxy<span class="subst">$&#123;modules[key].url&#125;</span>`</span>, (req, res)=&gt; &#123;</span><br><span class="line">                              <span class="comment">// 这儿我们就拿到在api文件内写的mock假数据啦！</span></span><br><span class="line">                                res.json(modules[key].mock)</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>好了，这样我们就设置完了，在请求后，接口会返回我们在api的modules文件内各个接口中配置的mock属性下的数据，并且与mock.js不同，是能够直接在network里面真实存在的一次请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;proxy代理配置&quot;&gt;&lt;a href=&quot;#proxy代理配置&quot; class=&quot;headerlink&quot; title=&quot;proxy代理配置&quot;&gt;&lt;/a&gt;proxy代理配置&lt;/h2&gt;&lt;p&gt;最近搭了一个项目的架子，接口请求库用的axios，第一个测试接口就给扔了CORS，于
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue.cli4" scheme="http://localhost:4000/tags/vue-cli4/"/>
    
      <category term="跨域" scheme="http://localhost:4000/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>electron打包后文件路径问题(解决子进程文件报错)</title>
    <link href="http://localhost:4000/2020/05/23/electron%E6%89%93%E5%8C%85%E5%90%8E%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
    <id>http://localhost:4000/2020/05/23/electron%E6%89%93%E5%8C%85%E5%90%8E%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/</id>
    <published>2020-05-23T05:33:24.000Z</published>
    <updated>2020-05-23T06:13:56.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近手上有个项目是基于electron（electron-vue）开发的平台监测系统，有一部分数据量非常大，并且是实时更新数据滚动显示，但后台的同学很鸡贼的没有过滤去重就把超多的数据仍给我了，因此数据处理就交给前端了。为了不影响页面的流畅性，我把计算去重等操作放到了子进程中(child_process.fork)。但打包后发现抛出了channel closed的报错（这里的error输出是我手动抓取的）：</p><p><img src="/BeCoderQ.github.io/2020/05/23/electron打包后文件路径问题-解决子进程文件报错/error.png" alt="抓到的报错"></p><p>这个报错我在stackoverflow上看有说版本问题，有说send数据不对。但debug了半天，最后发现实际是打包后子进程文件的路径出了问题。</p><h2 id="在package-json中修改配置"><a href="#在package-json中修改配置" class="headerlink" title="在package.json中修改配置"></a>在package.json中修改配置</h2><p>找到了出错的原因，下一步就好做了，打包后路径有问题，那么我们就在package.json文件中的build属性下，加入下面的配置:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"build"</span>: &#123;</span><br><span class="line">  ...otherConfig,</span><br><span class="line">    <span class="string">"asarUnpack"</span>: [</span><br><span class="line"><span class="string">"**/src/renderer/utils/**/*"</span></span><br><span class="line">],</span><br><span class="line">    <span class="string">"extraResources"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"from"</span>: <span class="string">"src/renderer/utils/worker.js"</span>,</span><br><span class="line">          <span class="string">"to"</span>: <span class="string">"app.asar.unpacked/source/worker.js"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照文档上的说法，<strong><a href="https://github.com/atom/asar" target="_blank" rel="noopener">asar</a> 是一种将多个文件合并成一个文件的类 tar 风格的归档格式。Electron 可以无需解压，即从其中读取任意文件内容。</strong></p><p>那么这里就是配置unpack（不打包）的文件，我的子进程文件放在了utils里，因此这里我配置了utils的路径。</p><p>第二个参数extraResources（直译额外的资源），下面from-to也很明显是要在打包后从哪个路径到哪个路径，实际就是我们自己的具体某个文件需要在打包后存放到哪个路径下。</p><h2 id="主进程文件中"><a href="#主进程文件中" class="headerlink" title="主进程文件中"></a>主进程文件中</h2><p>这里我们设置好了打包后的路径，接下来就在调用子进程的主进程文件内做好开发环境与生产环境的判定就好了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入子进程</span></span><br><span class="line"><span class="keyword">const</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"><span class="comment">// 引入path</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">// 判定当前环境的变量</span></span><br><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV &amp;&amp; process.env.NODE_ENV == <span class="string">'development'</span></span><br><span class="line"><span class="comment">// 子进程的真实路径 注意后面生产环节的路径要与package.json中配置的相同</span></span><br><span class="line"><span class="keyword">let</span> _path = isDev?path.join(__dirname, <span class="string">'worker.js'</span>):path.join(process.resourcesPath, <span class="string">'app.asar.unpacked/source/worker.js'</span>)</span><br><span class="line"><span class="keyword">const</span> worker = childProcess.fork(_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> onMessage = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 以下为我的业务函数 </span></span><br><span class="line">    caculateMsg(clientMsg, serverMsg, callback) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;主进程启动'</span>, _path)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            worker.send(&#123;clientMsg, serverMsg&#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;主进程发送出数据'</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="comment">// 这里回调遵守error-first的设计逻辑</span></span><br><span class="line">            callback(err, <span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!onMessage)</span><br><span class="line">            onMessage = worker.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;子进程的信息:'</span>, msg)</span><br><span class="line">                callback(<span class="literal">null</span>, msg)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近手上有个项目是基于electron（electron-vue）开发的平台监测系统，有一部分数据量非常大，并且是实时更新数
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="electron" scheme="http://localhost:4000/tags/electron/"/>
    
      <category term="webpack" scheme="http://localhost:4000/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>ES6迭代器与生成器</title>
    <link href="http://localhost:4000/2020/05/16/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://localhost:4000/2020/05/16/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2020-05-16T14:18:38.000Z</published>
    <updated>2020-05-23T05:35:44.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h2><p>迭代器是一种特殊的对象,特的结构如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">value</span>: <span class="string">'xxx'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure></p><p>value是下一个将要返回的值，done表示当前迭代是否完成，迭代器内部会保存一个指针，指向当前集合中值的位置，通过调用next()方法返回下一个值，当done为false后，每一次的next()返回的value都会为undefined。</p><h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a>生成器(Generator)</h2><p>生成器函数返回的是一个迭代器，外部通过next方法调用下一个yield。要创建一个生成器函数，可以有以下三种写法</p><ul><li><p>不带空格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">myGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不带空格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    *myGenerator() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.myGenerator().next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：生成器函数的yield关键字与return类似，不能穿透</strong><br>不能穿透是什么意思呢，看下面的例子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">myGenerator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="params">i</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = myGenerator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">g.next() <span class="comment">// 抛出错误 Uncaught SyntaxError: Unexpected identifier</span></span><br></pre></td></tr></table></figure></p><p>这也就是说yield不能再嵌套函数内使用，所以这里换成普通的for循环就能正常运行了。</p><h3 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span> <span class="comment">// 无视传值</span></span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span> <span class="comment">// 4 + 2</span></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span> <span class="comment">// 7 + 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = myGenerator()</span><br><span class="line">it.next(<span class="number">2</span>) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">4</span>) <span class="comment">// &#123;value: 6, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">7</span>) <span class="comment">// &#123;value: 10, done: false&#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>在生成器函数中yield本身不具有返回值，通过往next中传递参数使其有了返回值，但注意第一个next的参数会被忽略掉，因为next函数本身就是调用的上一次yield值。</p><h3 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h3><p>实际就是将多个迭代器合成一个调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">numberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">stringIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'one'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'two'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'three'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">allIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> *numberIterator()</span><br><span class="line">  <span class="keyword">yield</span> *stringIterator()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'finish'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用就通过allIterator函数</span></span><br><span class="line"><span class="keyword">let</span> all = allIterator()</span><br><span class="line">all.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: 'one', done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: 'two', done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: 'finish', done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h2 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for-of循环"></a>for-of循环</h2><p>ES6中加入了for-of循环，对于可迭代对象，使用for-of能遍历出他们的值(value),为什么必须是可迭代的对象呢，因为for-of内部会使用Symbol.iterator属性来迭代，内部其实就如同上面的生成器函数一样，使用next()方法来迭代。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> obj.arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// 依次输出 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样使用for-of是可行的，但是如果我们直接将自建对象obj拿来用for-of，就会抛出异常:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(val <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// Uncaught TypeError: obj is not iterable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>报错说obj是不可迭代的。</p><h3 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h3><p>前面我们说了，for-of内部使用了Symbol.iterator来迭代对象，那么如果我们自己写一个迭代函数，就能够让自建函数使用for-of了：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    property: <span class="string">'属性'</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="comment">// 使用for-in遍历obj，把值yield出去</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">this</span>[key]</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(val <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// 依次输出 [1,2,3]   属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用过这个迭代器函数，实现了自建属性的for-of。实际上，在JavaScript中已经<strong>内置了三种迭代器</strong>，分别是<strong>Object.keys()，Object.values()，Object.entries()</strong>，分别对应了键-值-键值，它们都会以数组的形式输出对应的迭代器内容。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>我们可以使用Symbol.iterator这个自带的函数来判断一个对象是否可迭代:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canIterate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用生成器完成异步任务"><a href="#使用生成器完成异步任务" class="headerlink" title="使用生成器完成异步任务"></a>使用生成器完成异步任务</h2><p>生成器最大的用武之地肯定就是在异步了，下面是一个最简单的实例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> execuTask(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">yield</span> execuTask(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">yield</span> execuTask(<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = task()</span><br><span class="line">t.next()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execuTask</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'延迟:'</span>, delay)</span><br><span class="line">        result.push(delay)</span><br><span class="line">        <span class="keyword">if</span>(result.length&lt;<span class="number">3</span>) &#123;</span><br><span class="line">            t.next()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, delay)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中的execuTask函数通过传入的延迟时间模拟异步操作，利用生成器在下一个next函数调用前函数会处于中断状态的特性，实现类似于Promise对象then方法的异步调用。执行结果是分别间隔1秒、3秒、6秒输出内容。</p><p><img src="/BeCoderQ.github.io/2020/05/16/迭代器与生成器/yb.png" alt="输出内容"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迭代器-Iterator&quot;&gt;&lt;a href=&quot;#迭代器-Iterator&quot; class=&quot;headerlink&quot; title=&quot;迭代器(Iterator)&quot;&gt;&lt;/a&gt;迭代器(Iterator)&lt;/h2&gt;&lt;p&gt;迭代器是一种特殊的对象,特的结构如下&lt;br&gt;&lt;figur
      
    
    </summary>
    
    
      <category term="学习" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://localhost:4000/tags/ES6/"/>
    
      <category term="Iterator" scheme="http://localhost:4000/tags/Iterator/"/>
    
      <category term="Generator" scheme="http://localhost:4000/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>canvas实现手写签名并保存为图片</title>
    <link href="http://localhost:4000/2020/04/25/canvas%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E7%AD%BE%E5%90%8D%E5%B9%B6%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/"/>
    <id>http://localhost:4000/2020/04/25/canvas%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E7%AD%BE%E5%90%8D%E5%B9%B6%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/</id>
    <published>2020-04-25T05:50:24.000Z</published>
    <updated>2020-04-25T07:14:28.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>最近做的一个表单页最后需要勾选同意选项，然后弹出一个手写签名的弹出层，在用户签名保存后将用户画出来的线条保存为base64图片通过接口上传。对此需求，canvas简直再适合不过了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现上比较简单，主要是使用线条相关绘画的api，也就是moveTo，lineTo。这里我提供pc端的绘画，手机端也是一样的，仅需要修改绑定的事件。</p><ul><li>构造函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SignCanvas</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装为一个类，接受目标元素以及各类配置项</span></span><br><span class="line">    <span class="keyword">constructor</span>(selector, options = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">        <span class="keyword">this</span>.canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">        <span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.canvas);</span><br><span class="line">        <span class="keyword">this</span>.ctx = <span class="keyword">this</span>.canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvas.width = <span class="keyword">this</span>.el.clientWidth * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.canvas.height = <span class="keyword">this</span>.el.clientHeight * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.ctx.fillStyle = options.bg || <span class="string">"#ffffff"</span>;</span><br><span class="line">        <span class="comment">// 填充矩形</span></span><br><span class="line">        <span class="keyword">this</span>.ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.width);</span><br><span class="line">        <span class="keyword">this</span>.ctx.strokeStyle = options.color || <span class="string">"#000000"</span>;</span><br><span class="line">        <span class="keyword">this</span>.ctx.lineWidth = options.lw || <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.ctx.lineCap = <span class="string">"round"</span>;</span><br><span class="line">        <span class="comment">// 这个变量用于判断当前鼠标是否按下 因为我们的操作逻辑是按下鼠标拖动才可以绘画</span></span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 主要的事件函数</span></span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">        <span class="keyword">this</span>.end()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里现把主要的配置写好了，我们可以设置canvas的线条颜色，填充颜色等。</p><ul><li>功能函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    start() &#123;</span><br><span class="line">        <span class="keyword">this</span>.canvas.onmousedown = <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.stop = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">            <span class="keyword">this</span>.ctx.moveTo(</span><br><span class="line">                e.layerX,</span><br><span class="line">                e.layerY</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">this</span>.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    draw() &#123;</span><br><span class="line">        <span class="keyword">this</span>.canvas.onmousemove = <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.stop) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">this</span>.ctx.lineTo(</span><br><span class="line">                e.layerX,</span><br><span class="line">                e.layerY</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">this</span>.ctx.stroke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 松开鼠标结束绘画</span></span><br><span class="line">    end() &#123;</span><br><span class="line">        <span class="keyword">this</span>.canvas.onmouseup = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.stop = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除画布</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx.clearRect(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="keyword">this</span>.canvas.width,</span><br><span class="line">            <span class="keyword">this</span>.canvas.height</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存通过canvas的内置方法转为base64的图片</span></span><br><span class="line">    save() &#123;</span><br><span class="line">        <span class="keyword">let</span> imgBase64 = <span class="keyword">this</span>.canvas.toDataURL();</span><br><span class="line">        <span class="keyword">return</span> imgBase64;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>因为比较简单，所有功能函数就一并写出来了，这里面，start作为一个初始化的函数，这里对于pc端主要要注意需要一个stop作为是否松开鼠标的判断，另外就是要注意this的指向问题，这里也是全部使用了箭头函数。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这里以vue+element-ui中使用为例子<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line">                清除</span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"save"</span>&gt;</span></span><br><span class="line">                保存</span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SignCanvas <span class="keyword">from</span> <span class="string">'./SignCanvas'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        drawLine: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="keyword">this</span>.drawLine = <span class="keyword">new</span> SignCanvas(<span class="string">'#canvas'</span>, &#123;</span><br><span class="line">            color: <span class="string">'yellow'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 清除画布</span></span><br><span class="line">        clear() &#123;</span><br><span class="line">            <span class="keyword">this</span>.drawLine.clear()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 保存图片 函数将返回base64的编码</span></span><br><span class="line">        save() &#123;</span><br><span class="line">            <span class="keyword">let</span> base64 = <span class="keyword">this</span>.drawLine.save()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2020/04/25/canvas实现手写签名并保存为图片/canvas-sign.png" alt="完成效果"><br>调用非常简单，这样就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;最近做的一个表单页最后需要勾选同意选项，然后弹出一个手写签名的弹出层，在用户签名保存后将用户画出来的线条保存为base64图片通过接口上传。
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="canvas" scheme="http://localhost:4000/tags/canvas/"/>
    
      <category term="手写签名" scheme="http://localhost:4000/tags/%E6%89%8B%E5%86%99%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>解决uni-app编译后自定义指令中绑定事件无效问题</title>
    <link href="http://localhost:4000/2020/04/11/%E8%A7%A3%E5%86%B3uni-app%E7%BC%96%E8%AF%91%E5%90%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://localhost:4000/2020/04/11/%E8%A7%A3%E5%86%B3uni-app%E7%BC%96%E8%AF%91%E5%90%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-11T07:15:14.000Z</published>
    <updated>2020-04-11T07:41:38.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>自定义指令在vue中我使用得不多，但最近遇到一个业务场景非常适合，需求是在用户点击某些页面跳转按钮但是没有登录的时，拦截跳转，弹出登录popup组件。看到这个需求我第一时间就想到了使用全局指令，并且因为全局指令诸如bind、inserted等钩子函数内能获取到目标元素实例与传递的参数，这样就非常好解决了。</p><h2 id="遇到坑"><a href="#遇到坑" class="headerlink" title="遇到坑"></a>遇到坑</h2><p>我在H5环境下，一切如预期运行良好，下面看看代码<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"a"</span> <span class="attr">v-checklogin</span>=<span class="string">"&#123; _this: this, url: '../me/forHelp/index' &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"/static/images/icon/forHelp.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>点单<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在项目的入口main文件中:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'checklogin'</span>, &#123;</span><br><span class="line">    bind (el, &#123;<span class="attr">value</span>: &#123;_this, url&#125;&#125;) &#123;</span><br><span class="line">        <span class="comment">// 参数分别为当前元素实例，调用指令的上下文环境，以及如果登录后要跳转的页面的url</span></span><br><span class="line">        el.onclick = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 根据token是否存在来判断是否需要弹出</span></span><br><span class="line">            <span class="keyword">if</span> (getState(<span class="string">'api'</span>,<span class="string">'token'</span>)) &#123;</span><br><span class="line">                uni.navigateTo(&#123;</span><br><span class="line">                    url: url</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_this.show = <span class="literal">true</span> <span class="comment">// show控制弹出层是否弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>做完这些在H5运行良好，但第二天我尝试了编译在手机上运行后就拉垮了，怎么点都没反应，并且扔了一堆红字给我：</p><ul><li>Property or method “toJSON” is not defined on the instance but referenced during render.</li><li>TypeError: JSON.stringify cannot serialize cyclic structures.</li></ul><h2 id="出坑之路"><a href="#出坑之路" class="headerlink" title="出坑之路"></a>出坑之路</h2><p>这上面的代码在编译后有比较严重的问题，下面依次来说一下</p><h3 id="编译后的上下文传递问题"><a href="#编译后的上下文传递问题" class="headerlink" title="编译后的上下文传递问题"></a>编译后的上下文传递问题</h3><p>上面的代码我在v-checklogin的参数中直接传递了this，这在H5环境没有问题，但是编译后会报错，其实都是因为编译后序列化this会是一个死循环，所以这里我做了一下处理:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 通过函数返回值的方式传递</span></span><br><span class="line">        context() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"a"</span> <span class="attr">v-checklogin</span>=<span class="string">"&#123; context, url: '../me/forHelp/index' &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"/static/images/icon/forHelp.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>点单<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这样第一个问题就解决了</strong></p><h3 id="编译后点击事件失效"><a href="#编译后点击事件失效" class="headerlink" title="编译后点击事件失效"></a>编译后点击事件失效</h3><p>这个就很坑爹了，我找了半天，最后debug发现是uni-app编译后重写了VNode,也就是说编译后的el是一个’虚假的’元素，我们无法通过他直接绑定事件！对此我有点懵逼，在研究了一下后，我发现这个el对象是可以在events中看到直接在元素上@click绑定的事件的！那么，我们要做的就是<strong>劫持这个函数</strong>！</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"a"</span> <span class="attr">v-checklogin</span>=<span class="string">"&#123; context, url: '../me/forHelp/index' &#125;"</span> @<span class="attr">click</span>=<span class="string">"()=&gt;&#123;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"/static/images/icon/forHelp.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>点单<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>首先我们绑定一个事件，直接给个空的匿名函数就行了</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'checklogin'</span>, &#123;</span><br><span class="line">    bind (el, &#123;<span class="attr">value</span>: &#123;context, url&#125;&#125;) &#123;</span><br><span class="line"><span class="comment">//#ifdef APP-PLUS</span></span><br><span class="line"><span class="comment">// 编译后重写了VNode 事件在一个循环队列中，这里劫持自定义指令的元素，重写click事件</span></span><br><span class="line">el.events.click = [<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (getState(<span class="string">'api'</span>,<span class="string">'token'</span>)) &#123;</span><br><span class="line">    uni.navigateTo(&#123;</span><br><span class="line">        url: url</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">context().show = <span class="literal">false</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">context().show = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发环境下</span></span><br><span class="line"><span class="comment">//#ifdef H5</span></span><br><span class="line">        el.onclick = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState(<span class="string">'api'</span>,<span class="string">'token'</span>)) &#123;</span><br><span class="line">                uni.navigateTo(&#123;</span><br><span class="line">                    url: url</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">context().show = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>考虑到开发调试，我还是把直接绑定的方法写在里面，当然要判断下当前环境，这样问题就完美解决了，现在无论在APP端还是H5端都能完美运行了！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h2&gt;&lt;p&gt;自定义指令在vue中我使用得不多，但最近遇到一个业务场景非常适合，需求是在用户点击某些页面跳转按钮但是没有登录的时，拦截跳转
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="uni-app" scheme="http://localhost:4000/tags/uni-app/"/>
    
      <category term="directive" scheme="http://localhost:4000/tags/directive/"/>
    
  </entry>
  
  <entry>
    <title>在js中使用canvas压缩图片</title>
    <link href="http://localhost:4000/2020/04/07/%E5%9C%A8js%E4%B8%AD%E4%BD%BF%E7%94%A8canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
    <id>http://localhost:4000/2020/04/07/%E5%9C%A8js%E4%B8%AD%E4%BD%BF%E7%94%A8canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</id>
    <published>2020-04-07T06:45:13.000Z</published>
    <updated>2020-04-11T07:16:33.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js中简单实用的图片压缩"><a href="#js中简单实用的图片压缩" class="headerlink" title="js中简单实用的图片压缩"></a>js中简单实用的图片压缩</h2><p>最近在业务中遇到一个问题，因为现在手机的像素越来越高了，拍出来的相片大小动辄就是4、5M，用户那边反应上传图片很慢，因此我便加入了一个压缩的功能。</p><h3 id="talk-is-cheap-show-me-the-code"><a href="#talk-is-cheap-show-me-the-code" class="headerlink" title="talk is cheap, show me the code"></a>talk is cheap, show me the code</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base64转为blob流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64UrlToBlob</span> (<span class="params">urlData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = urlData.split(<span class="string">','</span>),</span><br><span class="line">        mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>], <span class="comment">// 去掉url的头，并转化为byte</span></span><br><span class="line">        bstr = atob(arr[<span class="number">1</span>]), <span class="comment">// 处理异常,将ascii码小于0的转换为大于0</span></span><br><span class="line">        n = bstr.length,</span><br><span class="line">        u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n)</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">      u8arr[n] = bstr.charCodeAt(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转blob</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'转码完成'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123;<span class="attr">type</span>: mime&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// canvas压缩 参数为文件，配置项，以及图片的最大限制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasDataURL</span> (<span class="params">file, obj, maxSize = <span class="number">512</span> * <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">            <span class="comment">// 这里其实只是粗略算一下压缩比，不同图片大小不同</span></span><br><span class="line">            <span class="keyword">let</span> cutCount = <span class="built_in">Math</span>.ceil(file.size / maxSize)</span><br><span class="line">            img.src = file.fullPath</span><br><span class="line">            img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> that = <span class="keyword">this</span> <span class="comment">// 指到img</span></span><br><span class="line">                <span class="keyword">let</span> quality = <span class="number">0.5</span> <span class="comment">// 默认图片质量为0.5</span></span><br><span class="line">                <span class="comment">// 默认按比例压缩</span></span><br><span class="line">                <span class="keyword">let</span> w = that.width,</span><br><span class="line">                    h = that.height,</span><br><span class="line">                w = w / cutCount</span><br><span class="line">                h = h / cutCount</span><br><span class="line">                <span class="comment">// 生成canvas</span></span><br><span class="line">                <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">                <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">                <span class="comment">// 创建属性节点</span></span><br><span class="line">                <span class="keyword">let</span> anw = <span class="built_in">document</span>.createAttribute(<span class="string">'width'</span>)</span><br><span class="line">                anw.nodeValue = w</span><br><span class="line">                <span class="keyword">let</span> anh = <span class="built_in">document</span>.createAttribute(<span class="string">'height'</span>)</span><br><span class="line">                anh.nodeValue = h</span><br><span class="line">                canvas.setAttributeNode(anw)</span><br><span class="line">                canvas.setAttributeNode(anh)</span><br><span class="line">                ctx.drawImage(that, <span class="number">0</span>, <span class="number">0</span>, w, h)</span><br><span class="line">                <span class="comment">// 图像质量</span></span><br><span class="line">                <span class="keyword">if</span> (obj.quality &amp;&amp; obj.quality &gt;= <span class="number">1</span> &amp;&amp; obj.quality &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    quality = obj.quality</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// quality值越小，所绘制出的图像越模糊</span></span><br><span class="line">                <span class="keyword">let</span> base64 = canvas.toDataURL(<span class="string">'image/*'</span>, quality)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'canvas压缩完毕'</span>)</span><br><span class="line">                <span class="comment">// 回调函数返回base64的值 可以直接调用接口上传base64编码值，也可以实用上面的base64转blob之后再发送</span></span><br><span class="line">                resolve(base64)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'canvas处理出错:'</span> ,err)</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js中简单实用的图片压缩&quot;&gt;&lt;a href=&quot;#js中简单实用的图片压缩&quot; class=&quot;headerlink&quot; title=&quot;js中简单实用的图片压缩&quot;&gt;&lt;/a&gt;js中简单实用的图片压缩&lt;/h2&gt;&lt;p&gt;最近在业务中遇到一个问题，因为现在手机的像素越来越高了，拍出
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="canvas" scheme="http://localhost:4000/tags/canvas/"/>
    
      <category term="图片压缩" scheme="http://localhost:4000/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>~ | &amp; ^操作符与二进制基础：原码反码补码</title>
    <link href="http://localhost:4000/2020/03/18/%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://localhost:4000/2020/03/18/%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-18T10:18:36.000Z</published>
    <updated>2020-04-11T06:43:53.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>我们都知道计算机只认识0和1，因此所有复杂的计算都是建立在0和1上面，换句话说，再复杂的代码，最后都会转换为0和1。对于操作符，理解了底层运算原理后，就一目了然了</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码实际上是为了表示数字的正负出现的，它的最高位0与1分别代表正与负，下面以32为计算机中的数字5举例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// -5</span></span><br></pre></td></tr></table></figure></p><p>这样解决了正负问题，但是两数相加，很容易发现，结果并不为0，最明显的是最高位正负相加后永远是1，即负数，于是就有了<strong>反码</strong></p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>对于正数，反码没有任何变化，而负数就是对原码取反，当然，除了最高位，还是以上面的-5为例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// -5 原码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> <span class="comment">// -5 反码</span></span><br></pre></td></tr></table></figure></p><p>把-5的反码和5的反码相加：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 5 反码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> <span class="comment">// -5 反码</span></span><br></pre></td></tr></table></figure></p><p>这样相加，结果就是<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">// -0</span></span><br></pre></td></tr></table></figure></p><p>结果实际就是0的反码，即为-0，这样还是有问题，这是一个带符号的负0。因此补码就出现了。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>同样，对于正数，补码还是没变，对于负数，补码就是在反码的基础上在结尾+1<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> <span class="comment">// -5 反码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> <span class="comment">// -5 补码</span></span><br></pre></td></tr></table></figure></p><p>最后-5的补码和5的补码相加<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 5 补码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> <span class="comment">// -5 补码</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="comment">// 结尾</span></span><br></pre></td></tr></table></figure></p><p>结尾的1就像多米诺一样，然前面的二进制数全部进位，最后结果就是0啦。这也是为什么计算机使用补码来存储数据。</p><h2 id="JavaScript中的操作符"><a href="#JavaScript中的操作符" class="headerlink" title="JavaScript中的操作符"></a>JavaScript中的操作符</h2><p>其实理解了上面32位原、反、补码后，js中位元算符的原理就非常好理解了</p><h3 id="按位与-amp-、按位或"><a href="#按位与-amp-、按位或" class="headerlink" title="按位与(&amp;)、按位或(|)"></a>按位与(&amp;)、按位或(|)</h3><p>对两边操作数的补码进行相与(相或)运算，还是拿5与-5来举例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 5 补码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> <span class="comment">// -5 补码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行相与运算</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span> <span class="comment">// 结果为1</span></span><br><span class="line"><span class="comment">// 进行相或运算</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></p><h3 id="按位异或-、按位非-～"><a href="#按位异或-、按位非-～" class="headerlink" title="按位异或(^)、按位非(～)"></a>按位异或(^)、按位非(～)</h3><p>原理相同 按位异或与或不同的是只能有一个1才为1，按位非就是反转操作数的比特位，即0变1，1变0，实际上只需要在补码末尾+1即可<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 5 补码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> <span class="comment">// -5 补码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行异或运算</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111110</span> <span class="comment">// -2 </span></span><br><span class="line"><span class="comment">// 对5进行非运算 ～5</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111110</span> <span class="comment">// 末尾+1 -6</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二进制&quot;&gt;&lt;a href=&quot;#二进制&quot; class=&quot;headerlink&quot; title=&quot;二进制&quot;&gt;&lt;/a&gt;二进制&lt;/h2&gt;&lt;p&gt;我们都知道计算机只认识0和1，因此所有复杂的计算都是建立在0和1上面，换句话说，再复杂的代码，最后都会转换为0和1。对于操作符，理解
      
    
    </summary>
    
    
      <category term="操作符" scheme="http://localhost:4000/categories/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
    
      <category term="操作符" scheme="http://localhost:4000/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="计算机基础" scheme="http://localhost:4000/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="二进制" scheme="http://localhost:4000/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>puppeteer爬虫工具的使用与踩坑</title>
    <link href="http://localhost:4000/2020/03/07/puppeteer%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B8%A9%E5%9D%91/"/>
    <id>http://localhost:4000/2020/03/07/puppeteer%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B8%A9%E5%9D%91/</id>
    <published>2020-03-07T07:53:20.000Z</published>
    <updated>2020-03-07T07:57:51.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于puppeteer"><a href="#关于puppeteer" class="headerlink" title="关于puppeteer"></a>关于puppeteer</h2><p>还记得前年我想要完成一个网页脚本，但局限于只知道console里输代码，页面如果一条转就拉胯了。后来知道了chrome插件，才写出了一个能够模拟真人的脚本。而puppeteer就可以实现chrome插件的效果，并且还支持可视化的操作(当然一般只有调试时才打开)，非常方便。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.click(元素)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'完成了'</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">    <span class="comment">// 监听console 并输出在terminal</span></span><br><span class="line">    page.on(<span class="string">'console'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>首先当然是<strong>npm install puppetter</strong>了，然后我们引入进来</li><li>需要一个browser对象控制浏览器的打开关闭</li><li>需要一个page对象负责当前窗口的一系列操作</li><li>如同EventEmiter用on可以对console监控</li></ul><p>这里要注意一点，<strong>如果点击按钮后会跳转页面的话，我们要做一个延时处理</strong>，当然像上面这样写死一个时间是不合理的，下面我会单独说一下。</p><h2 id="点击后页面跳转的处理"><a href="#点击后页面跳转的处理" class="headerlink" title="点击后页面跳转的处理"></a>点击后页面跳转的处理</h2><p>下面看一个简单的demo<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="comment">// 假设点击这个元素后页面跳转了</span></span><br><span class="line">    <span class="keyword">await</span> page.click(元素)</span><br><span class="line">    <span class="comment">// 官方文档写的页面跳转等待api 默认30秒等待时间</span></span><br><span class="line">    <span class="keyword">await</span> page.waitForNavigation()</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'完成了'</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">    page.on(<span class="string">'console'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>这里我们假设点击跳转后马上截图，这么看是没毛病的，但实际运行你会发现终端会给你抛一个错出来大概是<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">TimeoutError: Navigation Timeout</span><br></pre></td></tr></table></figure></p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>我在StackOverflow上看到有人说是时间设置短了，但实际上并非如此，因为我如下所示，设置timeout：0,也就是永远等待，虽然没报错了，但也一直卡那儿了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并非时间的问题</span></span><br><span class="line"><span class="keyword">await</span> page.waitForNavigation(&#123;</span><br><span class="line">    timeout: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>会不会是页面跳转太快导致到了新页面waitForNavigation函数才执行呢？那么我就换了一个思路，我自己来判断页面有没有跳转吧！</p><h3 id="解决跳转问题"><a href="#解决跳转问题" class="headerlink" title="解决跳转问题"></a>解决跳转问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForEscape</span>(<span class="params">page, selector, delay</span>) </span>&#123;</span><br><span class="line">    page.$(selector).then( <span class="keyword">async</span> ($el)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>($el) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'enter clicked'</span>)</span><br><span class="line">            <span class="keyword">await</span> page.click(selector)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'-----no selector loop'</span>)</span><br><span class="line">            <span class="keyword">await</span> page.waitFor(delay)</span><br><span class="line">            waitForEscape(page, selector, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless: <span class="literal">true</span>,</span><br><span class="line">        ignoreDefaultArgs: [<span class="string">"--enable-automation"</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    cookies.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        page.setCookie(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="comment">// 假设点击这个元素后页面跳转了</span></span><br><span class="line">    <span class="keyword">await</span> page.click(元素)</span><br><span class="line">    <span class="comment">// 传入当前实例，递归直到页面跳转</span></span><br><span class="line">    waitForEscape(page, <span class="string">'selector'</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'完成了'</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">    <span class="comment">// 监听console 并输出在terminal</span></span><br><span class="line">    page.on(<span class="string">'console'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这样问题就解决了，我们通过自己写的一个函数递归，参数为当前页面实例，目标元素选择器，延迟时间。跳出条件是当前page对象的页面下有我们跳转后的目标页面的某个元素，内部通过传入的delay参数使用waitFor函数设置延迟。</p><h3 id="阴沟翻船"><a href="#阴沟翻船" class="headerlink" title="阴沟翻船"></a>阴沟翻船</h3><p>最后其实还遇到个小问题，我需要写一个定时抢口罩的脚本，口罩是晚上八点开抢，于是我就像下面这么写了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">await</span> page.waitFor(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>,<span class="number">03</span>,<span class="number">07</span>,<span class="number">20</span>,<span class="number">00</span>,<span class="number">00</span>).getTime() - <span class="built_in">Date</span>.now())</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>乍一看好像没问题，等待目标时间减去当前时间，然后执行任务，但是算出来的毫秒数不对，我一是还没反应过来，知道我把毫秒转成天，发现多了30天。。。。好吧，我忘了要减去一个月了！！！</p><p>所以推荐这种写法:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">await</span> page.waitFor(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020/03/07/ 20:00:00'</span>).getTime() - <span class="built_in">Date</span>.now())</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这样就没问题了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于puppeteer&quot;&gt;&lt;a href=&quot;#关于puppeteer&quot; class=&quot;headerlink&quot; title=&quot;关于puppeteer&quot;&gt;&lt;/a&gt;关于puppeteer&lt;/h2&gt;&lt;p&gt;还记得前年我想要完成一个网页脚本，但局限于只知道console里输代
      
    
    </summary>
    
    
      <category term="爬虫" scheme="http://localhost:4000/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="puppeteer" scheme="http://localhost:4000/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>手写一个完整的Promise类</title>
    <link href="http://localhost:4000/2020/03/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Promise%E7%B1%BB/"/>
    <id>http://localhost:4000/2020/03/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Promise%E7%B1%BB/</id>
    <published>2020-03-01T08:50:40.000Z</published>
    <updated>2020-03-05T09:13:33.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise规则"><a href="#Promise规则" class="headerlink" title="Promise规则"></a>Promise规则</h2><p>在实现Promise之前，先看一下Promise的规则，也就是我们要实现的目标。没有太专业的英文术语，都是我自己总结的白话：</p><ul><li><p>Promise有三个状态，分别为pendding(准备),fufilled(成功),rejected(失败)。这三个状态只能是由pendding-&gt;fufilled或者是pendding-&gt;rejected,状态变更后不可改。实际使用上的效果就是resolve后不能再reject,反之亦然。</p></li><li><p>Promise是异步执行的，我们要保证当resolve或reject在任务队列末尾时，我们要保证then中的回调函数能够成功执行。</p></li><li><p>then可以链式调用，并且当then有返回值时，下一个then要能够拿到返回值。也就是说我们会用上递归。</p></li><li><p>就算不往then中传递某个甚至直接不传递回调参数，链式调用也可以实现，因此在then中我们要对传递的回调函数做相应处理。</p></li><li><p>对于执行中的错误我们可以使用try-catch来捕获，然后进行处理。</p></li><li><p>在then中我们的返回值可以还是一个Promise对象，这个时候我们内部拿到这个Promise对象后要进行处理。</p></li><li><p>异步的核心-任务队列的实现: 发布订阅者模式。</p></li><li><p>Promise的几个静态方法(我暂时只做了resolve与reject)的实现。</p></li></ul><h2 id="基础骨架"><a href="#基础骨架" class="headerlink" title="基础骨架"></a>基础骨架</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="comment">// 决议值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="comment">// 状态不可变更</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个基础骨架下，我们能实现最基础的功能:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'成功'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>但一旦异步就拉胯了:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 无输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>这也是为什么我们要使用发布-订阅者模式</strong></p><h3 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h3><p>看一下最简单的示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventRegister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList = []</span><br><span class="line">    &#125;</span><br><span class="line">    on(key, fn) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.taskList)</span><br><span class="line">        <span class="keyword">this</span>.taskList.push(&#123;</span><br><span class="line">            [key]: fn</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    emit(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fn[key]) fn[key]()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> EventRegister()</span><br><span class="line">my.on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">my.emit(<span class="string">'test'</span>) <span class="comment">// 1秒后输出 执行了</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><h2 id="异步版"><a href="#异步版" class="headerlink" title="异步版"></a>异步版</h2><p>接下来看改进的异步版<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 成功与失败的任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.successList = []</span><br><span class="line">        <span class="keyword">this</span>.failList = []</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="comment">// 决议时再执行队列中的任务，实际上队列里的任务只会有一个，因为每次都是一个新的promise实例</span></span><br><span class="line">            <span class="keyword">this</span>.successList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onFulfilled(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">            <span class="keyword">this</span>.failList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onRejected(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    因为是异步 因此执行到这里的时候还没有resolve改变value与状态，所以将then中的回调函数存入</span></span><br><span class="line"><span class="comment">                    成功事件队列，调用的时机为resolve执行时，resolve时将value传入</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    onFulfilled(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 失败队列</span></span><br><span class="line">            <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    onRejected(reason)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以异步调用了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>接下来就是实现链式调用了</strong></p><h2 id="加入链式调用"><a href="#加入链式调用" class="headerlink" title="加入链式调用"></a>加入链式调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...这里相同就略了</span></span><br><span class="line"></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 实现链式调用的重点: 再次返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">                            <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                            resolve(thenReturnValue)</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                            <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">                            onRejected(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                            resolve(thenReturnValue)</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                            onRejected(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                        resolve(thenReturnValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                        onRejected(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                        resolve(thenReturnValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                        onRejected(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链式调用的关键是<strong>返回一个Promise对象</strong>，除此之外，我们还要在传递给下一个then时获取上一个then的返回值，之后，我们就可以使用resolve决议给下一个then了</p><h3 id="优化链式调用内的重复函数"><a href="#优化链式调用内的重复函数" class="headerlink" title="优化链式调用内的重复函数"></a>优化链式调用内的重复函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        resolve(thenReturnValue)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码量就能减少一大截</p><h2 id="then的穿透与返回值是Promise时的处理"><a href="#then的穿透与返回值是Promise时的处理" class="headerlink" title="then的穿透与返回值是Promise时的处理"></a>then的穿透与返回值是Promise时的处理</h2><p>标准的Promise可以实现以下功能：</p><ul><li>then的穿透：不传任何回调函数下一个then也能拿到决议值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'succuess'</span>)</span><br><span class="line">&#125;).then()</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>then的返回值可以是一个新的Promise对象，并且返回了一个新的Promise对象后面的then可以根据这个Promise的决议状态从成功或失败回调中拿到值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'succuess'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="string">'fail'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 无输出值</span></span><br><span class="line">&#125;,rej=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(rej) <span class="comment">// 输出 fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现then的穿透"><a href="#实现then的穿透" class="headerlink" title="实现then的穿透"></a>实现then的穿透</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...这里相同就略了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否传入了回调函数 若没有传入 考虑到穿透特性，这里要让其返回当前的value以传递到下一个then中</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 实现链式调用的重点: 再次返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 这部分代码略了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断如果没有传入函数我们就自己创建一个，并且注意一定要将返回值设置为this.value，这样才能在我们的checkAndConvert函数内拿到值。</p><h3 id="处理返回值是Promise对象的情况"><a href="#处理返回值是Promise对象的情况" class="headerlink" title="处理返回值是Promise对象的情况"></a>处理返回值是Promise对象的情况</h3><p>前面我们封装了处理函数，所以这里直接在这个函数内处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// todo 这里后面还要做处理</span></span><br><span class="line">            resolve(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就把所有返回值的情况处理好了</p><h2 id="catch与静态方法resolve-reject"><a href="#catch与静态方法resolve-reject" class="headerlink" title="catch与静态方法resolve/reject"></a>catch与静态方法resolve/reject</h2><p>首先搞明白：</p><ul><li>catch实际上就是只有失败回调的then方法</li><li>resolve与reject静态方法实际就是一个调用了失败决议的新的Promise对象</li></ul><p>再看看标准Promise的catch行为：</p><p>无失败回调时，可以穿透拿到失败决议值，并且catch之后还可以调用then。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>)</span><br><span class="line">&#125;).then()</span><br><span class="line">.then()</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 输出 fail</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'继续'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 继续</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>但是当有失败回调时，catch将不会执行<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>)</span><br><span class="line">&#125;).then(<span class="literal">null</span>, rej=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rej) <span class="comment">// 输出fail</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 无响应</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="catch方法的实现"><a href="#catch方法的实现" class="headerlink" title="catch方法的实现"></a>catch方法的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 这个变量用来判断使用者是否传入了onRejected回调函数，根据这个变量我们可以判断是否调用catch的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> gate = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            gate = <span class="literal">true</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, value, <span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, reason, <span class="literal">false</span>, gate)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">true</span>)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">false</span>, gate)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于checkAndConvert函数:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分别是then的成功失败回调，promise的成功失败决议，决议的参数，失败决议还是成功决议的判断标志，失败决议且没有传递失败回调的标志</span></span><br><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag, rejectFlag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里要注意</span></span><br><span class="line">            <span class="keyword">if</span>(!rejectFlag) resolve(thenReturnValue)</span><br><span class="line">            <span class="keyword">else</span> reject(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在传递个下一个then时，<strong>只有一种情况会调用reject拒绝</strong>：promise决议为拒绝后且用户没有往then函数内传递拒绝参数(也就是第二个回调)，这个时候我们使用reject决议，这样就可以让catch函数顺利执行了，并且这完全符合promise的catch行为: 当then中有第二个回调函数接受上一步抛出的错误后，catch内的回调函数将不会执行反之则会执行。</p><h3 id="静态方法resolve与reject"><a href="#静态方法resolve与reject" class="headerlink" title="静态方法resolve与reject"></a>静态方法resolve与reject</h3><p>在实现了上面的代码的基础下，这两个方法实际是最简单的:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际就是返回一个新的Promise对象，再调用对应的决议函数。</p><h2 id="大功告成，完整代码"><a href="#大功告成，完整代码" class="headerlink" title="大功告成，完整代码"></a>大功告成，完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag, rejectFlag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                在传递个下一个then时，只有一种情况会调用reject拒绝：promise决议为拒绝后且用户没有往then函数内传递</span></span><br><span class="line"><span class="comment">                拒绝参数(也就是第二个回调)，这个时候我们使用reject决议，这样就可以让catch函数顺利执行了，并且这完全</span></span><br><span class="line"><span class="comment">                符合promise的catch行为: 当then中有第二个回调函数接受上一步抛出的错误后，catch内的回调函数将不会执行</span></span><br><span class="line"><span class="comment">                反之则会执行。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(!rejectFlag) resolve(thenReturnValue)</span><br><span class="line">            <span class="keyword">else</span> reject(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.successList = []</span><br><span class="line">        <span class="keyword">this</span>.failList = []</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="keyword">this</span>.successList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onFulfilled(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">            <span class="keyword">this</span>.failList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onRejected(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 这个变量用来判断使用者是否传入了onRejected回调函数，根据这个变量我们可以判断是否调用catch的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> gate = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 判断是否传入了回调函数 若没有传入 考虑到穿透特性，这里要让其返回当前的value以传递到下一个then中</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            gate = <span class="literal">true</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现链式调用</span></span><br><span class="line">        <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    <span class="comment">/* </span></span><br><span class="line"><span class="comment">                        因为是异步 因此执行到这里的时候还没有resolve改变value与状态，所以将then中的回调函数存入</span></span><br><span class="line"><span class="comment">                        成功事件队列，调用的时机为resolve执行时，resolve时将value传入</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, value, <span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, reason, <span class="literal">false</span>, gate)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">true</span>)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">false</span>, gate)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><del>经过测试，本次手写的Promise能够完全达到与标准Promise相同的效果。</del><br>肯定不能媲美标准的Promise库，不过确实能按预想的实现Promise的所有基本功能，是不是A+规范我还没去研究。</p><p>这次手写整个Promise，我花了两天多的时间，第一天中午开始我跟着Youtube上面的大佬写代码，到下午我跟着写完了，然后我自己动手写catch的时候就懵了，对于递归的this指向我一开始没有搞清楚，导致走了很多弯路。之后两天我耐下心打断点，一次一次运行调试，最后终于把整个流程搞透了。期间数次怀疑人生，不过最后还是搞明白了。期间认识到了不足，但也学到了新东西。这就是学习的过程吧？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Promise规则&quot;&gt;&lt;a href=&quot;#Promise规则&quot; class=&quot;headerlink&quot; title=&quot;Promise规则&quot;&gt;&lt;/a&gt;Promise规则&lt;/h2&gt;&lt;p&gt;在实现Promise之前，先看一下Promise的规则，也就是我们要实现的目标。没有
      
    
    </summary>
    
    
      <category term="进阶" scheme="http://localhost:4000/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Promise" scheme="http://localhost:4000/tags/Promise/"/>
    
      <category term="异步" scheme="http://localhost:4000/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>二次封装axios</title>
    <link href="http://localhost:4000/2020/02/21/%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85axios/"/>
    <id>http://localhost:4000/2020/02/21/%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85axios/</id>
    <published>2020-02-21T07:12:19.000Z</published>
    <updated>2020-03-05T08:52:06.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>这里参考了网上一些大神的封装方法，然后结合了下自己的需求，总的分了两个文件<br><img src="/BeCoderQ.github.io/2020/02/21/二次封装axios/construct.png" alt="construct"></p><ul><li>api文件，将项目中所有的接口api按模块分类存储在module文件。其下的index文件会将所有模块及其下的api接口以字典形式对应起来</li><li>service文件为axios封装的核心，config为配置项文件，request文件为实际封装文件，interface文件将api文件暴露出的字典转为axios函数并将其封装插件</li></ul><h2 id="api文件"><a href="#api文件" class="headerlink" title="api文件"></a>api文件</h2><p>这个文件内有所有的api接口</p><h3 id="index文件"><a href="#index文件" class="headerlink" title="index文件"></a>index文件</h3><p>这个文件会把module下根据接口分类的字典按照文件名-api名的格式暴露出去<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将api文件下的接口模块全部导入 并转换成&#123; 模块文件名: &#123; api接口名: &#123;url...&#125; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> apiMap = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加载modules下所有的接口文件 */</span></span><br><span class="line"><span class="keyword">var</span> moduleFiles = <span class="built_in">require</span>.context(<span class="string">'./module'</span>, <span class="literal">true</span>, /\.js$/)</span><br><span class="line">moduleFiles.keys().map(<span class="function"><span class="keyword">function</span>(<span class="params">modulePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleName = modulePath.substr(modulePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, modulePath.length - <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">var</span> apis = moduleFiles(modulePath).default <span class="comment">// export default的数据</span></span><br><span class="line">    apiMap[moduleName] = apis</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取模块下的api配置对象</span></span><br><span class="line"><span class="comment"> * @param moduleName 模块文件名</span></span><br><span class="line"><span class="comment"> * @param apiName 文件下api模块名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apiMap</span><br></pre></td></tr></table></figure></p><h3 id="module文件"><a href="#module文件" class="headerlink" title="module文件"></a>module文件</h3><p>这个文件下为各个接口，如下图<br><img src="/BeCoderQ.github.io/2020/02/21/二次封装axios/module.png" alt="module"><br>这里还可以自定义请求的method等</p><h2 id="service文件"><a href="#service文件" class="headerlink" title="service文件"></a>service文件</h2><p>然后是核心的service文件。</p><h3 id="config文件"><a href="#config文件" class="headerlink" title="config文件"></a>config文件</h3><p>配置项独立出来放到了一个文件里<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 基础url前缀</span></span><br><span class="line">    baseURL: <span class="string">'http://xxx.com/'</span>,</span><br><span class="line">    <span class="comment">// 请求头信息</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>:<span class="string">'application/json;charset=UTF-8'</span>,</span><br><span class="line">      <span class="string">'token'</span>: localStorage.getItem(<span class="string">'token'</span>) || <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    timeout: <span class="number">10000</span>,</span><br><span class="line">    <span class="comment">// 携带凭证</span></span><br><span class="line">    withCredentials: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 返回数据类型</span></span><br><span class="line">    responseType: <span class="string">'json'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴露出的config等会儿直接放到axios实例中</p><h3 id="request文件"><a href="#request文件" class="headerlink" title="request文件"></a>request文件</h3><p>axios核心的二次封装文件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">// 先导入axios</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'./config.js'</span> <span class="comment">// 导入配置项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">$request</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">            ...config</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// request 拦截器，请求发送前的操作</span></span><br><span class="line">    instance.interceptors.request.use(</span><br><span class="line">        config =&gt; &#123;</span><br><span class="line">            <span class="comment">// Tip: 1</span></span><br><span class="line">            <span class="comment">// 请求开始的时候可以结合 vuex 开启全屏的 loading 动画</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Tip: 2 </span></span><br><span class="line">            <span class="comment">// token也可以在这里带上 , 结合 vuex 或者 localStorage</span></span><br><span class="line">            <span class="comment">// if (store.getters.token) &#123;</span></span><br><span class="line">            <span class="comment">//     config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     // token失效跳转指定页面或是重新请求 </span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Tip: 3</span></span><br><span class="line">            <span class="comment">// 根据请求方法，序列化传来的参数，根据后端需求是否序列化</span></span><br><span class="line">            <span class="comment">// if (config.method.toLocaleLowerCase() === 'post' </span></span><br><span class="line">            <span class="comment">//     || config.method.toLocaleLowerCase() === 'put' </span></span><br><span class="line">            <span class="comment">//     || config.method.toLocaleLowerCase() === 'delete') &#123;</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">//     config.data = qs.stringify(config.data)</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">            <span class="comment">// 请求错误时(接口错误、超时等)</span></span><br><span class="line">            <span class="comment">// Tip: 4</span></span><br><span class="line">            <span class="comment">// 关闭loadding</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//  1.判断请求超时</span></span><br><span class="line">            <span class="keyword">if</span> (error.code === <span class="string">'ECONNABORTED'</span> &amp;&amp; error.message.indexOf(<span class="string">'timeout'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'根据你设置的timeout/真的请求超时 判断请求现在超时了，你可以在这里加入超时的处理方案'</span>)</span><br><span class="line">                <span class="comment">// return service.request(originalRequest);//例如再重复请求一次</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  2.需要重定向到错误页面</span></span><br><span class="line">            <span class="keyword">const</span> errorInfo = error.response</span><br><span class="line">            <span class="built_in">console</span>.log(errorInfo)</span><br><span class="line">            <span class="keyword">if</span> (errorInfo) &#123;</span><br><span class="line">                <span class="comment">// error =errorInfo.data//页面那边catch的时候就能拿到详细的错误信息,看最下边的Promise.reject</span></span><br><span class="line">                <span class="keyword">const</span> errorStatus = errorInfo.status; <span class="comment">// 404 403 500 ... 等</span></span><br><span class="line">                router.push(&#123;</span><br><span class="line">                    path: <span class="string">`/error/<span class="subst">$&#123;errorStatus&#125;</span>`</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error) <span class="comment">// 在调用的那边可以拿到(catch)你想返回的错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 响应拦截器 then catch 之前</span></span><br><span class="line">    instance.interceptors.response.use(</span><br><span class="line">        response =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> data;</span><br><span class="line">            <span class="keyword">if</span> (response &amp;&amp; (response.status === <span class="number">200</span> || response.status === <span class="number">304</span>)) &#123;</span><br><span class="line">                <span class="comment">// IE9时response.data是undefined，因此需要使用response.request.responseText(Stringify后的字符串)</span></span><br><span class="line">                <span class="keyword">if</span>(response.data == <span class="literal">undefined</span>)&#123;</span><br><span class="line">                    data = response.request.responseText</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = response.data</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据返回的code值来做不同的处理（和后端约定）</span></span><br><span class="line">                <span class="keyword">switch</span> (data.rc) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'与后端约定返回的不同rc码'</span>:</span><br><span class="line">                        <span class="keyword">return</span> data;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> &#123;</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        rc: <span class="number">-2</span>,</span><br><span class="line">                        des: <span class="string">'异常响应状态码'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err &amp;&amp; err.response) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                    err.message = <span class="string">'请求错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">                    err.message = <span class="string">'未授权，请登录'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">                    err.message = <span class="string">'拒绝访问'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">                    err.message = <span class="string">`请求地址出错: <span class="subst">$&#123;err.response.config.url&#125;</span>`</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">                    err.message = <span class="string">'请求超时'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">                    err.message = <span class="string">'服务器内部错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">                    err.message = <span class="string">'服务未实现'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">                    err.message = <span class="string">'网关错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">                    err.message = <span class="string">'服务不可用'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">                    err.message = <span class="string">'网关超时'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">                    err.message = <span class="string">'HTTP版本不受支持'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.error(err)</span><br><span class="line">            Message.error(<span class="string">`ERROR: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err) <span class="comment">// 返回接口返回的错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//请求处理</span></span><br><span class="line">    instance(options)</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="interface文件"><a href="#interface文件" class="headerlink" title="interface文件"></a>interface文件</h3><p>这个文件会对api暴露出的对象的统一处理<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $req <span class="keyword">from</span> <span class="string">'./request'</span> <span class="comment">// 导入处理后的axios</span></span><br><span class="line"><span class="keyword">import</span> apiMap <span class="keyword">from</span> <span class="string">'../api/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将api文件下的接口模块全部导入 并转换成&#123; 模块文件名: &#123; api接口名: func(参数1, 参数2) &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> $apis = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> mName <span class="keyword">in</span> apiMap) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> aName <span class="keyword">in</span> apiMap[mName]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!$api[mName]) $api[mName] = &#123;&#125;</span><br><span class="line">        <span class="comment">// payload queryString参数</span></span><br><span class="line">        $api[mName][aName] = <span class="function"><span class="keyword">function</span>(<span class="params">data, params</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $req(&#123;</span><br><span class="line">                url: apiMap[mName][aName].url,</span><br><span class="line">                method: apiMap[mName][aName].method || <span class="string">'post'</span>,</span><br><span class="line">                data,</span><br><span class="line">                params</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装成插件</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="params">Vue</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (install.installed) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    install.installed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Vue.prototype, &#123;</span><br><span class="line">        <span class="comment">// 此处挂载在 Vue 原型的 $api </span></span><br><span class="line">        $api: &#123;</span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> $apis</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> install</span><br></pre></td></tr></table></figure></p><p>最后在项目的入口文件中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./service/interface'</span></span><br><span class="line">Vue.use(api)</span><br></pre></td></tr></table></figure></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用上就很简单啦:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$api.user.login(&#123;</span><br><span class="line">        username: <span class="string">'啊啊啊'</span>,</span><br><span class="line">        password: <span class="string">'123456a'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 请求成功后续操作</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 请求错误的操作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;p&gt;这里参考了网上一些大神的封装方法，然后结合了下自己的需求，总的分了两个文件&lt;br&gt;&lt;img src=&quot;/BeCoderQ.github.io
      
    
    </summary>
    
    
      <category term="经验" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="axios" scheme="http://localhost:4000/tags/axios/"/>
    
  </entry>
  
</feed>

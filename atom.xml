<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>ChowMe</title>
  <icon>https://www.gravatar.com/avatar/a73d30b0d26382bb941766ce55d0904e</icon>
  <subtitle>Hello,World</subtitle>
  <link href="/BeCoderQ.github.io/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2020-03-05T09:13:33.621Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>Chow</name>
    <email>zhouqm814@sina.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手写一个完整的Promise类</title>
    <link href="http://localhost:4000/2020/03/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Promise%E7%B1%BB/"/>
    <id>http://localhost:4000/2020/03/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Promise%E7%B1%BB/</id>
    <published>2020-03-01T08:50:40.000Z</published>
    <updated>2020-03-05T09:13:33.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise规则"><a href="#Promise规则" class="headerlink" title="Promise规则"></a>Promise规则</h2><p>在实现Promise之前，先看一下Promise的规则，也就是我们要实现的目标。没有太专业的英文术语，都是我自己总结的白话：</p><ul><li><p>Promise有三个状态，分别为pendding(准备),fufilled(成功),rejected(失败)。这三个状态只能是由pendding-&gt;fufilled或者是pendding-&gt;rejected,状态变更后不可改。实际使用上的效果就是resolve后不能再reject,反之亦然。</p></li><li><p>Promise是异步执行的，我们要保证当resolve或reject在任务队列末尾时，我们要保证then中的回调函数能够成功执行。</p></li><li><p>then可以链式调用，并且当then有返回值时，下一个then要能够拿到返回值。也就是说我们会用上递归。</p></li><li><p>就算不往then中传递某个甚至直接不传递回调参数，链式调用也可以实现，因此在then中我们要对传递的回调函数做相应处理。</p></li><li><p>对于执行中的错误我们可以使用try-catch来捕获，然后进行处理。</p></li><li><p>在then中我们的返回值可以还是一个Promise对象，这个时候我们内部拿到这个Promise对象后要进行处理。</p></li><li><p>异步的核心-任务队列的实现: 发布订阅者模式。</p></li><li><p>Promise的几个静态方法(我暂时只做了resolve与reject)的实现。</p></li></ul><h2 id="基础骨架"><a href="#基础骨架" class="headerlink" title="基础骨架"></a>基础骨架</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="comment">// 决议值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="comment">// 状态不可变更</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个基础骨架下，我们能实现最基础的功能:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'成功'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>但一旦异步就拉胯了:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 无输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>这也是为什么我们要使用发布-订阅者模式</strong></p><h3 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h3><p>看一下最简单的示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventRegister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList = []</span><br><span class="line">    &#125;</span><br><span class="line">    on(key, fn) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.taskList)</span><br><span class="line">        <span class="keyword">this</span>.taskList.push(&#123;</span><br><span class="line">            [key]: fn</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    emit(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fn[key]) fn[key]()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> EventRegister()</span><br><span class="line">my.on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">my.emit(<span class="string">'test'</span>) <span class="comment">// 1秒后输出 执行了</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><h2 id="异步版"><a href="#异步版" class="headerlink" title="异步版"></a>异步版</h2><p>接下来看改进的异步版<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 成功与失败的任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.successList = []</span><br><span class="line">        <span class="keyword">this</span>.failList = []</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="comment">// 决议时再执行队列中的任务，实际上队列里的任务只会有一个，因为每次都是一个新的promise实例</span></span><br><span class="line">            <span class="keyword">this</span>.successList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onFulfilled(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">            <span class="keyword">this</span>.failList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onRejected(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    因为是异步 因此执行到这里的时候还没有resolve改变value与状态，所以将then中的回调函数存入</span></span><br><span class="line"><span class="comment">                    成功事件队列，调用的时机为resolve执行时，resolve时将value传入</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    onFulfilled(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 失败队列</span></span><br><span class="line">            <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    onRejected(reason)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以异步调用了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>接下来就是实现链式调用了</strong></p><h2 id="加入链式调用"><a href="#加入链式调用" class="headerlink" title="加入链式调用"></a>加入链式调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...这里相同就略了</span></span><br><span class="line"></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 实现链式调用的重点: 再次返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">                            <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                            resolve(thenReturnValue)</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                            <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">                            onRejected(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                            resolve(thenReturnValue)</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                            onRejected(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                        resolve(thenReturnValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                        onRejected(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                        resolve(thenReturnValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                        onRejected(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链式调用的关键是<strong>返回一个Promise对象</strong>，除此之外，我们还要在传递给下一个then时获取上一个then的返回值，之后，我们就可以使用resolve决议给下一个then了</p><h3 id="优化链式调用内的重复函数"><a href="#优化链式调用内的重复函数" class="headerlink" title="优化链式调用内的重复函数"></a>优化链式调用内的重复函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        resolve(thenReturnValue)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码量就能减少一大截</p><h2 id="then的穿透与返回值是Promise时的处理"><a href="#then的穿透与返回值是Promise时的处理" class="headerlink" title="then的穿透与返回值是Promise时的处理"></a>then的穿透与返回值是Promise时的处理</h2><p>标准的Promise可以实现以下功能：</p><ul><li>then的穿透：不传任何回调函数下一个then也能拿到决议值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'succuess'</span>)</span><br><span class="line">&#125;).then()</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>then的返回值可以是一个新的Promise对象，并且返回了一个新的Promise对象后面的then可以根据这个Promise的决议状态从成功或失败回调中拿到值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'succuess'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="string">'fail'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 无输出值</span></span><br><span class="line">&#125;,rej=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(rej) <span class="comment">// 输出 fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现then的穿透"><a href="#实现then的穿透" class="headerlink" title="实现then的穿透"></a>实现then的穿透</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...这里相同就略了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否传入了回调函数 若没有传入 考虑到穿透特性，这里要让其返回当前的value以传递到下一个then中</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 实现链式调用的重点: 再次返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 这部分代码略了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断如果没有传入函数我们就自己创建一个，并且注意一定要将返回值设置为this.value，这样才能在我们的checkAndConvert函数内拿到值。</p><h3 id="处理返回值是Promise对象的情况"><a href="#处理返回值是Promise对象的情况" class="headerlink" title="处理返回值是Promise对象的情况"></a>处理返回值是Promise对象的情况</h3><p>前面我们封装了处理函数，所以这里直接在这个函数内处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// todo 这里后面还要做处理</span></span><br><span class="line">            resolve(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就把所有返回值的情况处理好了</p><h2 id="catch与静态方法resolve-reject"><a href="#catch与静态方法resolve-reject" class="headerlink" title="catch与静态方法resolve/reject"></a>catch与静态方法resolve/reject</h2><p>首先搞明白：</p><ul><li>catch实际上就是只有失败回调的then方法</li><li>resolve与reject静态方法实际就是一个调用了失败决议的新的Promise对象</li></ul><p>再看看标准Promise的catch行为：</p><p>无失败回调时，可以穿透拿到失败决议值，并且catch之后还可以调用then。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>)</span><br><span class="line">&#125;).then()</span><br><span class="line">.then()</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 输出 fail</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'继续'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 继续</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>但是当有失败回调时，catch将不会执行<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>)</span><br><span class="line">&#125;).then(<span class="literal">null</span>, rej=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rej) <span class="comment">// 输出fail</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 无响应</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="catch方法的实现"><a href="#catch方法的实现" class="headerlink" title="catch方法的实现"></a>catch方法的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 这个变量用来判断使用者是否传入了onRejected回调函数，根据这个变量我们可以判断是否调用catch的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> gate = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            gate = <span class="literal">true</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, value, <span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, reason, <span class="literal">false</span>, gate)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">true</span>)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">false</span>, gate)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于checkAndConvert函数:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分别是then的成功失败回调，promise的成功失败决议，决议的参数，失败决议还是成功决议的判断标志，失败决议且没有传递失败回调的标志</span></span><br><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag, rejectFlag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里要注意</span></span><br><span class="line">            <span class="keyword">if</span>(!rejectFlag) resolve(thenReturnValue)</span><br><span class="line">            <span class="keyword">else</span> reject(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在传递个下一个then时，<strong>只有一种情况会调用reject拒绝</strong>：promise决议为拒绝后且用户没有往then函数内传递拒绝参数(也就是第二个回调)，这个时候我们使用reject决议，这样就可以让catch函数顺利执行了，并且这完全符合promise的catch行为: 当then中有第二个回调函数接受上一步抛出的错误后，catch内的回调函数将不会执行反之则会执行。</p><h3 id="静态方法resolve与reject"><a href="#静态方法resolve与reject" class="headerlink" title="静态方法resolve与reject"></a>静态方法resolve与reject</h3><p>在实现了上面的代码的基础下，这两个方法实际是最简单的:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际就是返回一个新的Promise对象，再调用对应的决议函数。</p><h2 id="大功告成，完整代码"><a href="#大功告成，完整代码" class="headerlink" title="大功告成，完整代码"></a>大功告成，完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag, rejectFlag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                在传递个下一个then时，只有一种情况会调用reject拒绝：promise决议为拒绝后且用户没有往then函数内传递</span></span><br><span class="line"><span class="comment">                拒绝参数(也就是第二个回调)，这个时候我们使用reject决议，这样就可以让catch函数顺利执行了，并且这完全</span></span><br><span class="line"><span class="comment">                符合promise的catch行为: 当then中有第二个回调函数接受上一步抛出的错误后，catch内的回调函数将不会执行</span></span><br><span class="line"><span class="comment">                反之则会执行。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(!rejectFlag) resolve(thenReturnValue)</span><br><span class="line">            <span class="keyword">else</span> reject(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.successList = []</span><br><span class="line">        <span class="keyword">this</span>.failList = []</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="keyword">this</span>.successList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onFulfilled(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">            <span class="keyword">this</span>.failList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onRejected(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 这个变量用来判断使用者是否传入了onRejected回调函数，根据这个变量我们可以判断是否调用catch的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> gate = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 判断是否传入了回调函数 若没有传入 考虑到穿透特性，这里要让其返回当前的value以传递到下一个then中</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            gate = <span class="literal">true</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现链式调用</span></span><br><span class="line">        <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    <span class="comment">/* </span></span><br><span class="line"><span class="comment">                        因为是异步 因此执行到这里的时候还没有resolve改变value与状态，所以将then中的回调函数存入</span></span><br><span class="line"><span class="comment">                        成功事件队列，调用的时机为resolve执行时，resolve时将value传入</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, value, <span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, reason, <span class="literal">false</span>, gate)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">true</span>)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">false</span>, gate)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><del>经过测试，本次手写的Promise能够完全达到与标准Promise相同的效果。</del><br>肯定不能媲美标准的Promise库，不过确实能按预想的实现Promise的所有基本功能，是不是A+规范我还没去研究。</p><p>这次手写整个Promise，我花了两天多的时间，第一天中午开始我跟着Youtube上面的大佬写代码，到下午我跟着写完了，然后我自己动手写catch的时候就懵了，对于递归的this指向我一开始没有搞清楚，导致走了很多弯路。之后两天我耐下心打断点，一次一次运行调试，最后终于把整个流程搞透了。期间数次怀疑人生，不过最后还是搞明白了。期间认识到了不足，但也学到了新东西。这就是学习的过程吧？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Promise规则&quot;&gt;&lt;a href=&quot;#Promise规则&quot; class=&quot;headerlink&quot; title=&quot;Promise规则&quot;&gt;&lt;/a&gt;Promise规则&lt;/h2&gt;&lt;p&gt;在实现Promise之前，先看一下Promise的规则，也就是我们要实现的目标。没有
      
    
    </summary>
    
    
      <category term="进阶" scheme="http://localhost:4000/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Promise" scheme="http://localhost:4000/tags/Promise/"/>
    
      <category term="异步" scheme="http://localhost:4000/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>二次封装axios</title>
    <link href="http://localhost:4000/2020/02/21/%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85axios/"/>
    <id>http://localhost:4000/2020/02/21/%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85axios/</id>
    <published>2020-02-21T07:12:19.000Z</published>
    <updated>2020-03-05T08:52:06.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>这里参考了网上一些大神的封装方法，然后结合了下自己的需求，总的分了两个文件<br><img src="/BeCoderQ.github.io/2020/02/21/二次封装axios/construct.png" alt="construct"></p><ul><li>api文件，将项目中所有的接口api按模块分类存储在module文件。其下的index文件会将所有模块及其下的api接口以字典形式对应起来</li><li>service文件为axios封装的核心，config为配置项文件，request文件为实际封装文件，interface文件将api文件暴露出的字典转为axios函数并将其封装插件</li></ul><h2 id="api文件"><a href="#api文件" class="headerlink" title="api文件"></a>api文件</h2><p>这个文件内有所有的api接口</p><h3 id="index文件"><a href="#index文件" class="headerlink" title="index文件"></a>index文件</h3><p>这个文件会把module下根据接口分类的字典按照文件名-api名的格式暴露出去<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将api文件下的接口模块全部导入 并转换成&#123; 模块文件名: &#123; api接口名: &#123;url...&#125; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> apiMap = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加载modules下所有的接口文件 */</span></span><br><span class="line"><span class="keyword">var</span> moduleFiles = <span class="built_in">require</span>.context(<span class="string">'./module'</span>, <span class="literal">true</span>, /\.js$/)</span><br><span class="line">moduleFiles.keys().map(<span class="function"><span class="keyword">function</span>(<span class="params">modulePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleName = modulePath.substr(modulePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, modulePath.length - <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">var</span> apis = moduleFiles(modulePath).default <span class="comment">// export default的数据</span></span><br><span class="line">    apiMap[moduleName] = apis</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取模块下的api配置对象</span></span><br><span class="line"><span class="comment"> * @param moduleName 模块文件名</span></span><br><span class="line"><span class="comment"> * @param apiName 文件下api模块名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apiMap</span><br></pre></td></tr></table></figure></p><h3 id="module文件"><a href="#module文件" class="headerlink" title="module文件"></a>module文件</h3><p>这个文件下为各个接口，如下图<br><img src="/BeCoderQ.github.io/2020/02/21/二次封装axios/module.png" alt="module"><br>这里还可以自定义请求的method等</p><h2 id="service文件"><a href="#service文件" class="headerlink" title="service文件"></a>service文件</h2><p>然后是核心的service文件。</p><h3 id="config文件"><a href="#config文件" class="headerlink" title="config文件"></a>config文件</h3><p>配置项独立出来放到了一个文件里<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 基础url前缀</span></span><br><span class="line">    baseURL: <span class="string">'http://xxx.com/'</span>,</span><br><span class="line">    <span class="comment">// 请求头信息</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>:<span class="string">'application/json;charset=UTF-8'</span>,</span><br><span class="line">      <span class="string">'token'</span>: localStorage.getItem(<span class="string">'token'</span>) || <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    timeout: <span class="number">10000</span>,</span><br><span class="line">    <span class="comment">// 携带凭证</span></span><br><span class="line">    withCredentials: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 返回数据类型</span></span><br><span class="line">    responseType: <span class="string">'json'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴露出的config等会儿直接放到axios实例中</p><h3 id="request文件"><a href="#request文件" class="headerlink" title="request文件"></a>request文件</h3><p>axios核心的二次封装文件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">// 先导入axios</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'./config.js'</span> <span class="comment">// 导入配置项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">$request</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">            ...config</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// request 拦截器，请求发送前的操作</span></span><br><span class="line">    instance.interceptors.request.use(</span><br><span class="line">        config =&gt; &#123;</span><br><span class="line">            <span class="comment">// Tip: 1</span></span><br><span class="line">            <span class="comment">// 请求开始的时候可以结合 vuex 开启全屏的 loading 动画</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Tip: 2 </span></span><br><span class="line">            <span class="comment">// token也可以在这里带上 , 结合 vuex 或者 localStorage</span></span><br><span class="line">            <span class="comment">// if (store.getters.token) &#123;</span></span><br><span class="line">            <span class="comment">//     config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     // token失效跳转指定页面或是重新请求 </span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Tip: 3</span></span><br><span class="line">            <span class="comment">// 根据请求方法，序列化传来的参数，根据后端需求是否序列化</span></span><br><span class="line">            <span class="comment">// if (config.method.toLocaleLowerCase() === 'post' </span></span><br><span class="line">            <span class="comment">//     || config.method.toLocaleLowerCase() === 'put' </span></span><br><span class="line">            <span class="comment">//     || config.method.toLocaleLowerCase() === 'delete') &#123;</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">//     config.data = qs.stringify(config.data)</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">            <span class="comment">// 请求错误时(接口错误、超时等)</span></span><br><span class="line">            <span class="comment">// Tip: 4</span></span><br><span class="line">            <span class="comment">// 关闭loadding</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//  1.判断请求超时</span></span><br><span class="line">            <span class="keyword">if</span> (error.code === <span class="string">'ECONNABORTED'</span> &amp;&amp; error.message.indexOf(<span class="string">'timeout'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'根据你设置的timeout/真的请求超时 判断请求现在超时了，你可以在这里加入超时的处理方案'</span>)</span><br><span class="line">                <span class="comment">// return service.request(originalRequest);//例如再重复请求一次</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  2.需要重定向到错误页面</span></span><br><span class="line">            <span class="keyword">const</span> errorInfo = error.response</span><br><span class="line">            <span class="built_in">console</span>.log(errorInfo)</span><br><span class="line">            <span class="keyword">if</span> (errorInfo) &#123;</span><br><span class="line">                <span class="comment">// error =errorInfo.data//页面那边catch的时候就能拿到详细的错误信息,看最下边的Promise.reject</span></span><br><span class="line">                <span class="keyword">const</span> errorStatus = errorInfo.status; <span class="comment">// 404 403 500 ... 等</span></span><br><span class="line">                router.push(&#123;</span><br><span class="line">                    path: <span class="string">`/error/<span class="subst">$&#123;errorStatus&#125;</span>`</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error) <span class="comment">// 在调用的那边可以拿到(catch)你想返回的错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 响应拦截器 then catch 之前</span></span><br><span class="line">    instance.interceptors.response.use(</span><br><span class="line">        response =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> data;</span><br><span class="line">            <span class="keyword">if</span> (response &amp;&amp; (response.status === <span class="number">200</span> || response.status === <span class="number">304</span>)) &#123;</span><br><span class="line">                <span class="comment">// IE9时response.data是undefined，因此需要使用response.request.responseText(Stringify后的字符串)</span></span><br><span class="line">                <span class="keyword">if</span>(response.data == <span class="literal">undefined</span>)&#123;</span><br><span class="line">                    data = response.request.responseText</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = response.data</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据返回的code值来做不同的处理（和后端约定）</span></span><br><span class="line">                <span class="keyword">switch</span> (data.rc) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'与后端约定返回的不同rc码'</span>:</span><br><span class="line">                        <span class="keyword">return</span> data;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> &#123;</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        rc: <span class="number">-2</span>,</span><br><span class="line">                        des: <span class="string">'异常响应状态码'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err &amp;&amp; err.response) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                    err.message = <span class="string">'请求错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">                    err.message = <span class="string">'未授权，请登录'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">                    err.message = <span class="string">'拒绝访问'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">                    err.message = <span class="string">`请求地址出错: <span class="subst">$&#123;err.response.config.url&#125;</span>`</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">                    err.message = <span class="string">'请求超时'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">                    err.message = <span class="string">'服务器内部错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">                    err.message = <span class="string">'服务未实现'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">                    err.message = <span class="string">'网关错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">                    err.message = <span class="string">'服务不可用'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">                    err.message = <span class="string">'网关超时'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">                    err.message = <span class="string">'HTTP版本不受支持'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.error(err)</span><br><span class="line">            Message.error(<span class="string">`ERROR: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err) <span class="comment">// 返回接口返回的错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//请求处理</span></span><br><span class="line">    instance(options)</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="interface文件"><a href="#interface文件" class="headerlink" title="interface文件"></a>interface文件</h3><p>这个文件会对api暴露出的对象的统一处理<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $req <span class="keyword">from</span> <span class="string">'./request'</span> <span class="comment">// 导入处理后的axios</span></span><br><span class="line"><span class="keyword">import</span> apiMap <span class="keyword">from</span> <span class="string">'../api/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将api文件下的接口模块全部导入 并转换成&#123; 模块文件名: &#123; api接口名: func(参数1, 参数2) &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> $apis = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> mName <span class="keyword">in</span> apiMap) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> aName <span class="keyword">in</span> apiMap[mName]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!$api[mName]) $api[mName] = &#123;&#125;</span><br><span class="line">        <span class="comment">// payload queryString参数</span></span><br><span class="line">        $api[mName][aName] = <span class="function"><span class="keyword">function</span>(<span class="params">data, params</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $req(&#123;</span><br><span class="line">                url: apiMap[mName][aName].url,</span><br><span class="line">                method: apiMap[mName][aName].method || <span class="string">'post'</span>,</span><br><span class="line">                data,</span><br><span class="line">                params</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装成插件</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="params">Vue</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (install.installed) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    install.installed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Vue.prototype, &#123;</span><br><span class="line">        <span class="comment">// 此处挂载在 Vue 原型的 $api </span></span><br><span class="line">        $api: &#123;</span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> $apis</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> install</span><br></pre></td></tr></table></figure></p><p>最后在项目的入口文件中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./service/interface'</span></span><br><span class="line">Vue.use(api)</span><br></pre></td></tr></table></figure></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用上就很简单啦:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$api.user.login(&#123;</span><br><span class="line">        username: <span class="string">'啊啊啊'</span>,</span><br><span class="line">        password: <span class="string">'123456a'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 请求成功后续操作</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 请求错误的操作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;p&gt;这里参考了网上一些大神的封装方法，然后结合了下自己的需求，总的分了两个文件&lt;br&gt;&lt;img src=&quot;/BeCoderQ.github.io
      
    
    </summary>
    
    
      <category term="经验" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="axios" scheme="http://localhost:4000/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本(半)自动化部署项目,以及踩到的坑</title>
    <link href="http://localhost:4000/2020/01/13/shell%E8%84%9A%E6%9C%AC-%E5%8D%8A-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE-%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://localhost:4000/2020/01/13/shell%E8%84%9A%E6%9C%AC-%E5%8D%8A-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE-%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91/</id>
    <published>2020-01-13T07:39:32.000Z</published>
    <updated>2020-01-13T08:32:30.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用shell脚本"><a href="#为什么要使用shell脚本" class="headerlink" title="为什么要使用shell脚本"></a>为什么要使用shell脚本</h2><p>手上有个半年前开发的项目，这个项目一套代码需要打包到七八个不同的服务器上，虽说是一套代码，但实际上要打包好几次，最开始我用最笨的办法，打包一次发一个服务器，当然这样效率是最低的，已很容易犯错，比如把A区的发到了B区的服务器上。之后我尝试打包后再改请求地址，同样的，效率也很低。附上一张之前配置的请求地址结构。<br><img src="/BeCoderQ.github.io/2020/01/13/shell脚本-半-自动化部署项目-以及踩到的坑/shell-url.png" alt="url"></p><p>也就是说每次切换一个地方就会注释掉其他的url，然后再记住当前打包的地区，再部署到对应服务器，非常痛苦，且容易出错。正巧最近一接触了shell，于是便打算使用shell脚本帮我完成部署。</p><h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><p>对于api文件内的URL结构我没有更改，仍然使用之前的结构，最初我在后面加上了”-端口”，想着方便后免脚本匹配到端口，然后使用管道执行字符串命令。但后面遇到一个坑，卡了半天。于是我新建了一个txt文本，将scp部署命令都写在里面:<br><img src="/BeCoderQ.github.io/2020/01/13/shell脚本-半-自动化部署项目-以及踩到的坑/shell-addr.png" alt="url"><br>账号@后的IP地址将与项目中api文件内的地址进行匹配，这样最恼火的一个问题就解决了。</p><h2 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h2><p>使用字符串切割(类似JavaScript中的split):</p><ul><li>${VALUE%.*}或${VALUE%%.*}：删除VALUE字符串中以分隔符“.”匹配的左边字符，保留右边字符。</li><li>${VALUE#*.}或${VALUE##*.}：删除VALUE字符串中以分隔符“.”匹配的右边字符，保留左边字符。<br>单%(#)与双%(#)区别是前者截取最短长度 后者截取最长长度<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">    pattern=<span class="string">"// var"</span></span><br><span class="line">    head -n <span class="number">8</span> ./src/utils/api.js | <span class="keyword">while</span> read line <span class="comment">// 遍历api文件内的前八行</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [[ $line =~ $pattern ]] <span class="comment">// 匹配每行以"// var开头的"</span></span><br><span class="line">        then</span><br><span class="line">            echo <span class="string">"******"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fival=$&#123;line#*<span class="comment">//&#125;</span></span><br><span class="line">            less ./<span class="keyword">public</span>/scp-address.txt | <span class="keyword">while</span> read tline</span><br><span class="line">            <span class="keyword">do</span> </span><br><span class="line">                <span class="keyword">if</span> [[ $tline =~ $&#123;fival%:*&#125; ]]</span><br><span class="line">                <span class="comment">// 或 if [[ $tline == *$&#123;fival%:*&#125;* ]]</span></span><br><span class="line">                then </span><br><span class="line">                    npm run build</span><br><span class="line">                    scp=$&#123;tline#*:&#125;</span><br><span class="line">                    $scp</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    echo <span class="string">"&amp;&amp;&amp;&amp;&amp;&amp;"</span></span><br><span class="line">                fi </span><br><span class="line">            done           </span><br><span class="line">            echo <span class="string">"*******************服务器$&#123;fival%:*&#125;打包上传完成*******************"</span></span><br><span class="line">        fi    </span><br><span class="line">    done</span><br></pre></td></tr></table></figure></li></ul><p>我们可以以别名alias或直接输入路径:./bridge.sh来执行这个shell脚本，会自动打包，然后部署到对应服务器，而打包不同的地区现在只需要在api中更改对应的url值即可。当然，现在每次执行脚本后还会要求你输入密码，如果想免密部署可以配置密钥或者使用expect脚本。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在部署这个脚本的过程遇到一个很奇葩的问题，前面说过，我在api中以”-端口”的形式让shell来匹配端口，我将这个端口的值存入了变量port中，并希望通过管道让拼接完成的字符串命令直接执行:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">port=循环匹配的端口</span><br><span class="line">...</span><br><span class="line">echo $port #这里可以正常输出内容</span><br><span class="line">`scp -r -P $port ./dist/\* ssh fbjd@$&#123;fival%:*&#125;:/home/fbjd/html | sh`</span><br><span class="line">echo <span class="string">"scp -r -P $port ./dist/* ssh fbjd@$&#123;fival%:*&#125;:/home/fbjd/html"</span></span><br></pre></td></tr></table></figure></p><p>但是输出后我发现输出的内容完全不对<br><img src="/BeCoderQ.github.io/2020/01/13/shell脚本-半-自动化部署项目-以及踩到的坑/shell-problem.png" alt="problem"><br>怎么$port以及前面的东西都不见了？百思不得其解。<br>于是我又改成输出port的长度<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">echo <span class="string">"scp -r -P $&#123;#port&#125; ./dist/* ssh fbjd@$&#123;fival%:*&#125;:/home/fbjd/html"</span></span><br><span class="line"><span class="meta"># scp -r -P 3 ./dist/\* ssh fbjd@$192.168.2.1:/home/fbjd/html</span></span><br></pre></td></tr></table></figure></p><p>改成长度输出了，但长度对不上？最后找了半天，才发现是获取的变量”不干净”，有换行符什么的，因为现在回头看截取的那部分正好是js文件内一行的最后几个字符<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">echo "scp -r -P $port ./dist/* ssh fbjd@$&#123;fival%:*&#125;:/home/fbjd/html" |tr -d '\n\r\v'</span><br></pre></td></tr></table></figure></p><p>改成这样，正常输出了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要使用shell脚本&quot;&gt;&lt;a href=&quot;#为什么要使用shell脚本&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用shell脚本&quot;&gt;&lt;/a&gt;为什么要使用shell脚本&lt;/h2&gt;&lt;p&gt;手上有个半年前开发的项目，这个项目一套代码需要打包到
      
    
    </summary>
    
    
      <category term="记录" scheme="http://localhost:4000/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="shell脚本" scheme="http://localhost:4000/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Es6中Map对象基础</title>
    <link href="http://localhost:4000/2020/01/07/Es6%E4%B8%ADMap%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://localhost:4000/2020/01/07/Es6%E4%B8%ADMap%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2020-01-07T11:12:12.000Z</published>
    <updated>2020-01-08T07:57:08.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map对象与Object"><a href="#Map对象与Object" class="headerlink" title="Map对象与Object"></a>Map对象与Object</h2><p>对于Map与普通的Object相比，主要有两点不同:</p><ul><li>Map对象的虽然也是键值对的形式，但是其健(key)可以是任何形式,从String到Function,甚至是undefined,null,而Object的键(key)只能是String或Symbol</li><li>Map中的键值对是有序的，而Object中是无序的，通过枚举遍历出的顺序是不可靠的</li><li>Map对象可以通过size操作获取长度，Object需要自行计算</li><li>Map对象可以使用forEach直接迭代</li><li>Map在一些频发的增删改下对比Object会有些性能优势</li></ul><h2 id="Map对象原型方法"><a href="#Map对象原型方法" class="headerlink" title="Map对象原型方法"></a>Map对象原型方法</h2><h3 id="Map-prototype-clear"><a href="#Map-prototype-clear" class="headerlink" title="Map.prototype.clear()"></a>Map.prototype.clear()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除Map对象的所有键/值对</span></span><br><span class="line">Map.prototype.clear()</span><br><span class="line"></span><br><span class="line">var myMap = <span class="keyword">new</span> Map();</span><br><span class="line">var objKey = &#123;&#125;;</span><br><span class="line">myMap.set('stringKey', 'this is stringKey');</span><br><span class="line">myMap.set(objKey, 'this is objKey');</span><br><span class="line">myMap.clear()</span><br><span class="line">console.<span class="built_in">log</span>(myMap) <span class="comment">// 输出: Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Map-prototype-delete"><a href="#Map-prototype-delete" class="headerlink" title="Map.prototype.delete()"></a>Map.prototype.delete()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。随后调用 Map.prototype.has(key) 将返回 false</span></span><br><span class="line">Map.prototype.<span class="keyword">delete</span>(key)</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(myMap.<span class="keyword">delete</span>(objKey)) <span class="comment">// 删除了对应键值 返回true</span></span><br></pre></td></tr></table></figure><h3 id="Map-prototype-entries"><a href="#Map-prototype-entries" class="headerlink" title="Map.prototype.entries()"></a>Map.prototype.entries()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</span></span><br><span class="line">Map.prototype.entries()</span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2020/01/07/Es6中Map对象基础/Map.entries.png" alt="entries"></p><h3 id="Map-prototype-forEach"><a href="#Map-prototype-forEach" class="headerlink" title="Map.prototype.forEach()"></a>Map.prototype.forEach()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按插入顺序，为 Map对象里的每一键值对调用一次callback函数, 回调依此是值，键，Map实例</span></span><br><span class="line">Map.prototype.forEach(callback(value, key, thisMap))</span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2020/01/07/Es6中Map对象基础/Map.forEach.png" alt="forEach"></p><h3 id="Map-prototype-get"><a href="#Map-prototype-get" class="headerlink" title="Map.prototype.get()"></a>Map.prototype.get()</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回键对应的值，如果不存在，则返回undefined</span></span><br><span class="line">Map.prototype.get(key)</span><br><span class="line"></span><br><span class="line">console.log(myMap.get('stringKey')) // 输出 this is stringKey</span><br></pre></td></tr></table></figure><h3 id="Map-prototype-has"><a href="#Map-prototype-has" class="headerlink" title="Map.prototype.has()"></a>Map.prototype.has()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示Map实例是否包含键对应的值</span></span><br><span class="line">Map.prototype.has(key)</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(myMap.has(undefined)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Map-prototype-keys"><a href="#Map-prototype-keys" class="headerlink" title="Map.prototype.keys()"></a>Map.prototype.keys()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键</span></span><br><span class="line">Map.prototype.keys()</span><br><span class="line"><span class="comment">// 我们使用展开展</span></span><br><span class="line">console.<span class="built_in">log</span>([...myMap.keys()])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展一下, 这里我们也可以将数组转为Map对象:</span></span><br><span class="line">let myArray = [['key1', 'value1'],['key2', 'value2']]</span><br><span class="line">let arrayToMap = <span class="keyword">new</span> Map(myArray) <span class="comment">// 转化为了Map对象</span></span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2020/01/07/Es6中Map对象基础/Map.keys.png" alt="keys"></p><h3 id="Map-prototype-set"><a href="#Map-prototype-set" class="headerlink" title="Map.prototype.set()"></a>Map.prototype.set()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置Map对象中键的值。返回该Map对象</span></span><br><span class="line">Map.prototype.<span class="built_in">set</span>(key, value)</span><br></pre></td></tr></table></figure><h3 id="Map-prototype-values"><a href="#Map-prototype-values" class="headerlink" title="Map.prototype.values()"></a>Map.prototype.values()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 对应和keys()方法类似</span></span><br><span class="line">Map.prototype.values()</span><br></pre></td></tr></table></figure><h3 id="Map-prototype-iterator"><a href="#Map-prototype-iterator" class="headerlink" title="Map.prototype@@iterator"></a>Map.prototype<a href>@@iterator</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组</span></span><br><span class="line">Map.prototype[@@iterator]()</span><br></pre></td></tr></table></figure><h2 id="Map的for-of有序遍历"><a href="#Map的for-of有序遍历" class="headerlink" title="Map的for of有序遍历"></a>Map的for of有序遍历</h2><p>除了forEach,还可以使用for of来遍历Map对象:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let myMap = <span class="keyword">new</span> Map();</span><br><span class="line">myMap.<span class="built_in">set</span>(<span class="number">0</span>, <span class="string">"zero"</span>);</span><br><span class="line">myMap.<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会显示两个log。一个是"0 = zero"另一个是"1 = one"</span></span><br><span class="line"><span class="keyword">for</span> (let [key, value] of myMap) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 "0" 另一个是 "1"</span></span><br><span class="line"><span class="keyword">for</span> (let key of myMap.keys()) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 "zero" 另一个是 "one"</span></span><br><span class="line"><span class="keyword">for</span> (let value of myMap.values()) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 "0 = zero" 另一个是 "1 = one"</span></span><br><span class="line"><span class="keyword">for</span> (let [key, value] of myMap.entries()) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一个小小的实践"><a href="#一个小小的实践" class="headerlink" title="一个小小的实践"></a>一个小小的实践</h2><p>在枚举时，我们可以使用Map，一定程度上可以实现typescript中的枚举类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stateFilter(val) &#123;</span><br><span class="line">    <span class="keyword">const</span> dictionary = &#123;</span><br><span class="line">0: '设备正常',</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> statMap = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="keyword">for</span>(let key in dictionary) &#123;</span><br><span class="line">statMap.<span class="built_in">set</span>(key, dictionary[key])</span><br><span class="line">statMap.<span class="built_in">set</span>(dictionary[key], key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> statMap.get(String(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>12月31号写的 今天才发上来，越来越懒了，一定要坚持写博客啊！！！！！！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Map对象与Object&quot;&gt;&lt;a href=&quot;#Map对象与Object&quot; class=&quot;headerlink&quot; title=&quot;Map对象与Object&quot;&gt;&lt;/a&gt;Map对象与Object&lt;/h2&gt;&lt;p&gt;对于Map与普通的Object相比，主要有两点不同:&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="学习" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Map对象" scheme="http://localhost:4000/tags/Map%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>vuex的封装以及其在项目中的使用场景</title>
    <link href="http://localhost:4000/2019/11/25/vuex%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://localhost:4000/2019/11/25/vuex%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2019-11-25T11:55:13.000Z</published>
    <updated>2020-01-07T11:16:17.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex的半自动化注册"><a href="#Vuex的半自动化注册" class="headerlink" title="Vuex的半自动化注册"></a>Vuex的半自动化注册</h2><p>以前我的vuex的store文件里总是会写一大坨代码，看着实在不够’优雅’！我们其实可以利用require.context来实现vuex的半自动化注册。<br>先看下我vuex的结构</p><h3 id="Vuex的结构"><a href="#Vuex的结构" class="headerlink" title="Vuex的结构"></a>Vuex的结构</h3><p><img src="/BeCoderQ.github.io/2019/11/25/vuex的封装以及其在项目中的使用场景/store.png" alt="store.png"><br>module文件下是我按照模块划分的各个js文件 存储了如枚举值 用户信息 请求url的信息，他们会如下暴露出去<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    menulist: [],</span><br><span class="line">    companyInfo: &#123;&#125;,</span><br><span class="line">    companyNo: null,</span><br><span class="line">    toLogined:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用require-context"><a href="#使用require-context" class="headerlink" title="使用require.context"></a>使用require.context</h3><p>接下来是关键，在StoreFactory文件内，有以下代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个对象 用来暴露出去</span></span><br><span class="line">var storeMap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">var moduleFiles = require.context('./module', true, /\.js$/)</span><br><span class="line">moduleFiles.keys().<span class="built_in">map</span>(function(modulePath) &#123;</span><br><span class="line">    var moduleName = modulePath.substr(modulePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, modulePath.length - <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 获取到每个模块内的对象 .default就是文件内export default曝露出的对象</span></span><br><span class="line">    var stores = moduleFiles(modulePath).<span class="keyword">default</span></span><br><span class="line">    <span class="comment">// 声明一个中转对象</span></span><br><span class="line">    var store = &#123;namespaced:<span class="literal">true</span>, state:&#123;&#125;,mutations:&#123;&#125;&#125;</span><br><span class="line">    <span class="comment">// 使用for in遍历之每个模块内的对象。vuex的mutation修改，state存储</span></span><br><span class="line">    <span class="keyword">for</span>(let i in stores)&#123;</span><br><span class="line">        store.state[i]=stores[i]</span><br><span class="line">        <span class="comment">// 这里我设置set+属性名首字母大写 实际就是驼峰</span></span><br><span class="line">        store.mutations[`<span class="built_in">set</span>$&#123;i[<span class="number">0</span>].toUpperCase()&#125;$&#123;i.substr(<span class="number">1</span>)&#125;`]=function(states, params) &#123;</span><br><span class="line">    states[i] = params</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    storeMap[moduleName] = store</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// storeMap将存储所有对象暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> storeMap</span><br></pre></td></tr></table></figure></p><p>我们这里用webpackContext的keys方法能够得到符合条件的文件地址的数组,map方法便利我们拿到字符串，处理掉多余的符号，我们便得到了对应的文件名<br><img src="/BeCoderQ.github.io/2019/11/25/vuex的封装以及其在项目中的使用场景/keys.png" alt="moduleFiles.keys()数组"><br>得到文件名后我们将他传入moduleFiles方法中，我们可以打印出来，会发现这个对象里的default字段下已经有了我们之前暴露出去的变量对象：<br><img src="/BeCoderQ.github.io/2019/11/25/vuex的封装以及其在项目中的使用场景/default.png" alt="moduleFiles(modulePath)"><br>没错～我们就这么轻而易举的拿到了module文件下各个模块的变量！接下来要做的就是以vuex的形式处理每个模块</p><h3 id="封装store的取值与改值"><a href="#封装store的取值与改值" class="headerlink" title="封装store的取值与改值"></a>封装store的取值与改值</h3><p>先上代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">import &#123;Store&#125; from 'vuex'</span><br><span class="line"><span class="keyword">import</span> Vuex from <span class="string">"vuex"</span></span><br><span class="line"><span class="keyword">import</span> Vue from <span class="string">"vue"</span></span><br><span class="line"><span class="comment">// 导入上面那堆代码暴露出的对象</span></span><br><span class="line">import allStore from './StoreFactory'</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">var store</span><br><span class="line"><span class="keyword">if</span> (!store) &#123;</span><br><span class="line">    store = <span class="keyword">new</span> Store(&#123;</span><br><span class="line">        modules: &#123;</span><br><span class="line">            ...allStore</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的封装取值与赋值函数</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">getState</span><span class="params">(moduleName, value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!store)</span><br><span class="line">        <span class="keyword">return</span> null</span><br><span class="line">    <span class="keyword">return</span> moduleName ? store.state[moduleName][value] : store.state[value]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> function setState(moduleName, field,value)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!store)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    store.commit(`$&#123;moduleName?`$&#123;moduleName&#125;/`:''&#125;set$&#123;field[0].toLocaleUpperCase()&#125;$&#123;field.substr(1)&#125;`,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></p><p>封装的代码很简单，赋值就是按照刚才设置的set字段撸就完事儿。</p><h2 id="Vuex项目中常用场景"><a href="#Vuex项目中常用场景" class="headerlink" title="Vuex项目中常用场景"></a>Vuex项目中常用场景</h2><p>实际上Vuex出了存储用户信息 token等参数外，我认为在缓存数据时更能体现价值。假设有个页面有一个表单，当用户填写表单后再次点进去，会显示刚才填写过的内容，也就是说回显，这个时候我们可以按照一下步骤来缓存与取数据。</p><ul><li><p>首先我们的表单页面的mounted或者其他合适的钩子函数内，我们先判断</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(存在某个store字段) &#123;</span><br><span class="line">    表单回显数据 = 对应store字段</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    发起ajax请求获取最新的表单数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在每次编辑或删除这个表单数据时，同样在操作成功的回调函数内，我们要将对应修改或删除的数据更新到store内</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ajax请求.then(res=&gt;&#123;</span><br><span class="line">    ...其他操作</span><br><span class="line">    setState(模块文件, 文件内字段, 修改值) <span class="comment">// 让store里的内容实时保持最新</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>这样一来不仅降低了服务器的负担，也能让回显速度大幅提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex的半自动化注册&quot;&gt;&lt;a href=&quot;#Vuex的半自动化注册&quot; class=&quot;headerlink&quot; title=&quot;Vuex的半自动化注册&quot;&gt;&lt;/a&gt;Vuex的半自动化注册&lt;/h2&gt;&lt;p&gt;以前我的vuex的store文件里总是会写一大坨代码，看着实在不够’
      
    
    </summary>
    
    
      <category term="经验" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="Vuex" scheme="http://localhost:4000/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>vue.cli脚手架项目中require.context的使用</title>
    <link href="http://localhost:4000/2019/09/15/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E4%B8%ADrequire-context%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://localhost:4000/2019/09/15/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E4%B8%ADrequire-context%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-09-15T04:44:28.000Z</published>
    <updated>2019-11-25T12:57:20.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>在使用vue做项目开发时，我们经常会用到vue全家桶，vue-router,vuex等，对于这两个工具，就拿路由来说，我们每新开一个vue文件,就要在router里注册组件才能使用,vuex也是类似如此，这个时候，我们使用这个node的api就可以实现自动注册，也就是常说的前端自动化工程。</p><h2 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h2><p>对于这个api我也只是有一点初步的了解，是因为看了公司一位前辈搭建的工程的代码才发现的。该方法接受三个参数:</p><ul><li>第一个是你需要遍历的文件目录</li><li>第二个是是否遍历其下所有子级路径的布尔变量</li><li>第三个是匹配文件名的正则表达式</li></ul><p>下面以vuex的自动注册为例子<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在store目录下的index.js文件</span></span><br><span class="line"><span class="comment">// 首先导入相关依赖</span></span><br><span class="line">import Vue from 'vue'</span><br><span class="line">import Vuex from 'vuex'</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">// allStates存储共享变量</span></span><br><span class="line">var allStates = &#123;&#125;</span><br><span class="line"><span class="comment">// 自动生成mutation存储到这个对象中</span></span><br><span class="line">var mutations = &#123;&#125;</span><br><span class="line">var computedCache = []</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加载modules下所有的状态码文件*/</span></span><br><span class="line">var moduleFiles = require.context('./modules', true, /\.js$/)</span><br><span class="line"><span class="comment">// map遍历文件路径数组</span></span><br><span class="line">moduleFiles.keys().<span class="built_in">map</span>(function(modulePath) &#123;</span><br><span class="line">  <span class="comment">// 获取到文件内的内容，并以键值对的形式存入allStates,这里我modules下的default文件格式规定成n为键名，value为值</span></span><br><span class="line">  var vars = moduleFiles(modulePath).<span class="keyword">default</span></span><br><span class="line">  vars.<span class="built_in">map</span>(function(v) &#123;</span><br><span class="line">    <span class="comment">// v.n即取出键名,v.value取出值</span></span><br><span class="line">    allStates[v.n] = v.value</span><br><span class="line">    <span class="comment">// mutation我们拼接字符串设置为统一的set+键名</span></span><br><span class="line">    mutations[`<span class="built_in">set</span>$&#123;v.n.substr(<span class="number">0</span>, <span class="number">1</span>).toUpperCase()&#125;$&#123;v.n.substr(<span class="number">1</span>)&#125;`] = function(state, value) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state[v.n] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// computed的数组推入新键名 </span></span><br><span class="line">    computedCache.push(v.n)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// computed数组存入session方便另一个文件取出</span></span><br><span class="line">sessionStorage.setItem('computedStateCache',computedCache.join(","))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将自动生成的vuex数据放进store实例里</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: allStates,</span><br><span class="line">  mutations</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></p><ul><li><p>接下来在另一个mapComputed文件内</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var computeds = &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> function mapComputed() &#123;</span><br><span class="line">  <span class="comment">// 将刚才存入session的键名取出遍历，并根据键名返回对应值</span></span><br><span class="line">  var states = sessionStorage.getItem('computedStateCache').split(',')</span><br><span class="line">  states.<span class="built_in">map</span>(function(state) &#123;</span><br><span class="line">    computeds[state] = function() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state[state]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> computeds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样，在我们要使用的文件内，我们就可以在computed计算属性内像下面这样使用了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  computed:&#123;</span><br><span class="line">      <span class="comment">// es6写法</span></span><br><span class="line">      ...mapComputed(),</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样我们就相当于把store里的变量放入data内，实现了属性共享。在使用的时候，我们只需要在store内自己创建的modules文件下的default.js中按自己规定的格式写入变量即可，一般我把页面的一些枚举值放在里面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用背景&quot;&gt;&lt;a href=&quot;#使用背景&quot; class=&quot;headerlink&quot; title=&quot;使用背景&quot;&gt;&lt;/a&gt;使用背景&lt;/h2&gt;&lt;p&gt;在使用vue做项目开发时，我们经常会用到vue全家桶，vue-router,vuex等，对于这两个工具，就拿路由来说，我们每
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="node" scheme="http://localhost:4000/tags/node/"/>
    
      <category term="webpack" scheme="http://localhost:4000/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>DOM元素渲染的几种优化方式</title>
    <link href="http://localhost:4000/2019/08/31/DOM%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://localhost:4000/2019/08/31/DOM%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</id>
    <published>2019-08-31T04:02:38.000Z</published>
    <updated>2019-08-31T05:27:19.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM渲染性能问题"><a href="#DOM渲染性能问题" class="headerlink" title="DOM渲染性能问题"></a>DOM渲染性能问题</h2><p>我在几个月前做的项目地图部分使用了大量的dom渲染，这导致地图在渲染的时候会有很明显的卡顿效果，当然对于地图这块，海量点的渲染是尽量不要或者说压根就别用dom元素去渲染，因为每次拖动地图都会导致每个dom元素的重新渲染。但有时候在某些不可抗力影响下又不得不用dom元素去做大量渲染，这时候我们就要考虑如何优化性能了。</p><h2 id="我所知的几个优化方法"><a href="#我所知的几个优化方法" class="headerlink" title="我所知的几个优化方法"></a>我所知的几个优化方法</h2><p>在公司一位有多年前端开发经验的前辈那里我学到了几点优化的方案：</p><ul><li>使用requestAnimationFrame<br>在那之前，我一直是使用setTimeout、setInterval来编写动画或是进行dom渲染，后两者只是在设定的时间后将相应任务添加到任务队列中，而任务队列中如果还有前面的任务尚未执行完毕，那么后添加的任务就必须等待，所以说给它们设定的时间并不准确。requestAnimationFrame的间隔是16.7ms(1000ms/60帧),另外在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这就意味着更少的的cpu，gpu和内存使用量，最直观的还是动画变得更流畅了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x = <span class="number">0</span>;</span><br><span class="line">    var div = document.getElementById(<span class="string">"div"</span>)</span><br><span class="line">    function animation() &#123;</span><br><span class="line">        requestAnimationFrame(function () &#123;</span><br><span class="line">            div.style.left = ++x + <span class="string">"px"</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">250</span>) animation();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">animation();</span><br></pre></td></tr></table></figure></li></ul><p>上面是一个最简单的应用，内层一个递归调用requestAnimationFrame</p><ul><li>document.Fragment<br>DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为 DocumentFragment 不是真实DOM树的一部分，它的变化不会触发 DOM 树的（重新渲染) ，且不会导致性能等问题。这是MDN的文档说明。实际我理解就是避免单次一个一个的插入dom元素，尽量的批量插入元素<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">"一"</span>,<span class="string">"个"</span>,<span class="string">"数"</span>,<span class="string">"组"</span>];</span><br><span class="line">arr.forEach( item=&gt;&#123;</span><br><span class="line">    var p = document.createElement(<span class="string">"p"</span>);</span><br><span class="line">    p.innerText = item;</span><br><span class="line">    document.body.appendChild(p);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>这样遍历数组每次都是挨个插入，性能较低<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">"一"</span>,<span class="string">"个"</span>,<span class="string">"数"</span>,<span class="string">"组"</span>];</span><br><span class="line">var fakeFather = document.createDocumentFragment()</span><br><span class="line">arr.forEach( item=&gt;&#123;</span><br><span class="line">    var p = document.createElement(<span class="string">"p"</span>);</span><br><span class="line">    p.innerText = item;</span><br><span class="line">    fakeFather.appendChild(p);</span><br><span class="line">&#125;)</span><br><span class="line">document.body.appendChild(fakeFather);</span><br></pre></td></tr></table></figure></p><p>document.Fragment不存在于文档流中，暂时作为一个’包’，我们将每个元素先存放在这个包中，最后打包一起插入文档流。</p><ul><li>递归分批次渲染<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">batchRenderLotsPoints(eachList)&#123;</span><br><span class="line">    <span class="comment">// 这里setTimeout主要是怕前一个还没渲染好，因为没有对应的回调函数</span></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    <span class="comment">// splice截取前10个</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.renderLotsPoints(eachList.splice(<span class="number">0</span>,<span class="number">10</span>)))</span><br><span class="line"><span class="keyword">this</span>.batchRenderLotsPoints(eachList)</span><br><span class="line">&#125;,<span class="number">200</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">renderLotsPoints(eachList) &#123;</span><br><span class="line"><span class="keyword">if</span>(!eachList||!eachList.length)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">      let arr = [];</span><br><span class="line">      let colorMarker = <span class="string">"#76DA91"</span>;</span><br><span class="line">      <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; eachList.length; i++) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>.batchRenderLotsPoints(eachList);</span><br></pre></td></tr></table></figure></li></ul><p>这里我用递归渲染，页面上效果就是很有节奏感的渲染除了节点，非常流畅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM渲染性能问题&quot;&gt;&lt;a href=&quot;#DOM渲染性能问题&quot; class=&quot;headerlink&quot; title=&quot;DOM渲染性能问题&quot;&gt;&lt;/a&gt;DOM渲染性能问题&lt;/h2&gt;&lt;p&gt;我在几个月前做的项目地图部分使用了大量的dom渲染，这导致地图在渲染的时候会有很明显
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="递归" scheme="http://localhost:4000/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>记录一下最近vue项目开发中遇到的问题与解决过程</title>
    <link href="http://localhost:4000/2019/07/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <id>http://localhost:4000/2019/07/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</id>
    <published>2019-07-31T11:06:29.000Z</published>
    <updated>2019-08-31T05:45:04.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存后的路由页面参数保存问题"><a href="#缓存后的路由页面参数保存问题" class="headerlink" title="缓存后的路由页面参数保存问题"></a>缓存后的路由页面参数保存问题</h2><p>前不久遇到个问题，在页面A单击按钮后会通过params路由传参将一个对象传给下一个路由页面B，然后进入B又有一个按钮，点击后会跳到页面C。然后我就遇到一个问题，在从B到C后，再从C返回到B，就会报错了，因为B页面接受路由参数的部分是写在activated钩子函数内的。因为在使用路由缓存后created与mounted等钩子函数都只在第一次页面载入时生效,也就是说这里必须放到activated里，那么就会出现上面的问题，C页面返回到B，是不传参的，也就是说B拿不到A之前传的参数，解决办法是使用deactivated钩子函数，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        anotherInfo: <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">activated()&#123;</span><br><span class="line">    <span class="keyword">this</span>.info = <span class="keyword">this</span>.$route.params.obj == undefined ? <span class="keyword">this</span>.anotherInfo : <span class="keyword">this</span>.$route.params.obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// deactivated是缓存页面离开的钩子函数</span></span><br><span class="line">deactivated()&#123;</span><br><span class="line">    <span class="keyword">this</span>.anotherInfo = <span class="keyword">this</span>.info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>这里我用另一个变量在离开页面时保存了第一次进入B路由时的info，在activated钩子函数内，使用三元表达式判断是否有A页面传来的参数？没有则是从其他页面跳转过来的，那么就让info等于之前离开时保存的变量antherInfo</li><li>deactivated函数很实用，另外在这个钩子函数内打印url 结果是跳转后的页面。</li></ul><h2 id="filter内无法获取到data中的属性"><a href="#filter内无法获取到data中的属性" class="headerlink" title="filter内无法获取到data中的属性"></a>filter内无法获取到data中的属性</h2><p>项目中在使用v-for渲染页面时有一个变量需要过滤值，但是这个值要根据data中的一个变量来过滤，这个时候作为一个小白，我果断使用了filter然后写了this.那个变量,然后就报错了，抛出ReferenceError,即引用错误，后来打印了一下this,居然是undefined，反正不是指向vue实例的。这个时候我查了一下，网上大神建议用computed计算属性，但是我这儿v-for渲染的不好处理呀。</p><ul><li>最后实在插值符里用了三元表达式判断。。。</li></ul><h2 id="vuex状态管理内变量在页面刷新后消失"><a href="#vuex状态管理内变量在页面刷新后消失" class="headerlink" title="vuex状态管理内变量在页面刷新后消失"></a>vuex状态管理内变量在页面刷新后消失</h2><p>接手的别人的项目用了vuex,然后这边老板要求价格下拉刷新。结果当然是一刷新就报错，因为整个app都依赖vuex里的变量。</p><ul><li>解决方法其实很简单，将vuex里的东西存入session里就行了<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    <span class="comment">// 判断session中是否有值</span></span><br><span class="line">    <span class="keyword">if</span> (sessionStorage.getItem(<span class="string">"store"</span>) ) &#123;</span><br><span class="line">        <span class="comment">// 深拷贝session中的值</span></span><br><span class="line">        <span class="keyword">this</span>.$store.replaceState(Object.assign(&#123;&#125;, <span class="keyword">this</span>.$store.state,JSON.parse(sessionStorage.getItem(<span class="string">"store"</span>))))</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在页面刷新前将vuex里的信息保存到sessionStorage里</span></span><br><span class="line">    window.addEventListener(<span class="string">"beforeunload"</span>,()=&gt;&#123;</span><br><span class="line">        sessionStorage.setItem(<span class="string">"store"</span>,JSON.stringify(<span class="keyword">this</span>.$store.state))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用ES6中Set类型给数组去重"><a href="#使用ES6中Set类型给数组去重" class="headerlink" title="使用ES6中Set类型给数组去重"></a>使用ES6中Set类型给数组去重</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>];</span><br><span class="line">arr = <span class="keyword">new</span> Set(arr) <span class="comment">// [1,2,3,4,6]</span></span><br><span class="line">console.<span class="built_in">log</span>(arr instanceof Array) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Set类型可以给单纯的数组去重，但是对于复杂的对象数组是无法实现去重的，另外对于去重后的数组，实际上我们还需要数组的from方法来将其完全转化为数组类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>];</span><br><span class="line">arr = Array.from(<span class="keyword">new</span> Set(arr)) <span class="comment">// [1,2,3,4,6]</span></span><br><span class="line">console.<span class="built_in">log</span>(arr instanceof Array) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>这里就可以将arr转化为数组类型了。</p><h2 id="关于对象数组排序"><a href="#关于对象数组排序" class="headerlink" title="关于对象数组排序"></a>关于对象数组排序</h2><p>有时候遇到需求需要我们前端来讲返回的json数组排序，并且排序的情况可能会改变比如 下面的对象数组<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var json = [</span><br><span class="line">    &#123;name: <span class="string">"Zhou"</span>,age: <span class="number">22</span>,late: <span class="string">"0次"</span>&#125;,</span><br><span class="line">    &#123;name: <span class="string">"Qi"</span>,age: <span class="number">20</span>,late:<span class="string">"5次"</span>&#125;,</span><br><span class="line">    &#123;name: <span class="string">"Ming"</span>,age: <span class="number">23</span>,late: <span class="string">"3次"</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>类似如此，我们需要按特定属性排序将数据依次渲染到页面，这时候我们可以使用Array的sort方法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">sortProperty</span><span class="params">(property)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function(a,b)&#123;</span><br><span class="line">        <span class="keyword">return</span> parseInt(a[property]) - parseInt(b[property]) <span class="comment">//这里用parseInt强制转化为数字，因为项目内需求只考虑数字大小排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">json.sort( sortProperty('late') ) // 传入排序的属性</span><br><span class="line"><span class="comment">// 输出[&#123;name: "Zhou",age: 22,late: "0次"&#125;,&#123;name: "Ming",age: 23,late: "3次"&#125;,&#123;name: "Qi",age: 20,late:"5次"&#125;]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存后的路由页面参数保存问题&quot;&gt;&lt;a href=&quot;#缓存后的路由页面参数保存问题&quot; class=&quot;headerlink&quot; title=&quot;缓存后的路由页面参数保存问题&quot;&gt;&lt;/a&gt;缓存后的路由页面参数保存问题&lt;/h2&gt;&lt;p&gt;前不久遇到个问题，在页面A单击按钮后会通过p
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://localhost:4000/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>prototype、_proto_与[[prototype]]记录</title>
    <link href="http://localhost:4000/2019/07/15/prototype%E3%80%81-proto-%E4%B8%8E-prototype-%E8%AE%B0%E5%BD%95/"/>
    <id>http://localhost:4000/2019/07/15/prototype%E3%80%81-proto-%E4%B8%8E-prototype-%E8%AE%B0%E5%BD%95/</id>
    <published>2019-07-15T11:49:53.000Z</published>
    <updated>2019-07-15T11:49:53.915Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>解决高德地图3D模式下渲染marker卡顿问题</title>
    <link href="http://localhost:4000/2019/07/11/%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE3D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B8%B2%E6%9F%93marker%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://localhost:4000/2019/07/11/%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE3D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B8%B2%E6%9F%93marker%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/</id>
    <published>2019-07-11T11:55:35.000Z</published>
    <updated>2019-07-11T12:16:39.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲扯"><a href="#闲扯" class="headerlink" title="闲扯"></a>闲扯</h2><p>这一个月我都在和高德地图打交道，遇到了很多问题，因为没人带，都是靠自己解决，走了不少弯路。高德地图其实很强大，你能想到的几乎上面都有。</p><h2 id="3D地图"><a href="#3D地图" class="headerlink" title="3D地图"></a>3D地图</h2><p>其实项目并没有3D地图的需求，但是无奈老板提了个需求是要地图可以慢慢缩放，也就是我们说的无级缩放，再说专业点就是缩放等级zoom可以是浮点数。web端高德地图在2D模式下是不支持无级缩放的，那么在手机上就算你只缩放了一丢丢，地图也会按照加减1的zoom来放大缩小。<br>但是我又遇到个问题，3D模式下我在地图上的marker们都点不动了，经过我测试发现并不是点击事件失效，而是压根就触发不了，就像表面有个遮罩层挡住了一样，z-index设置多高都没用。最后搞了一天我还是没找到原因，不过我想起来自己用的是vue-amap,我果断换回了原生的amap，居然就解决了。。。</p><h3 id="渲染速度"><a href="#渲染速度" class="headerlink" title="渲染速度"></a>渲染速度</h3><p>那么，来说正题，我解决了上述两个问题，接下来又发现了新问题：我的marker渲染速度太慢了！！我的地图是才加载进去有9个marker,这9个类似点聚合的点，点击后会让地图放大，然后展示那9个行政区下面的几百上千家企业的marker点。marker实际上就是一个div,那么dom渲染，上千个，<strong>并且随着每次拖动div都会相对移动，而且地图还是在3D模式下</strong>，卡顿也就不奇怪了。那么我就如下分析了一下</p><ul><li>dom渲染卡顿，那么我不用dom。</li><li>拖动会重新绘制div的位置，那么我不让他重汇。<br>能实现这两点的那就只有canvas了，高德地图里也就是海量点。</li></ul><p>但是还有个问题，我的项目要求每个点旁边要有文字展示，海量点是没有的，那么高德地图有没有绘制文字的canvas方法呢？答案当然是有的。</p><h3 id="LabelsLayer图层与LabelMarker标记层"><a href="#LabelsLayer图层与LabelMarker标记层" class="headerlink" title="LabelsLayer图层与LabelMarker标记层"></a>LabelsLayer图层与LabelMarker标记层</h3><p>直接看代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">this.amap = new AMap.Map('cont', &#123;</span><br><span class="line">    resizeEnable: <span class="literal">true</span>,</span><br><span class="line">    rotateEnable:<span class="literal">false</span>,</span><br><span class="line">    pitchEnable:<span class="literal">true</span>,</span><br><span class="line">    zoom: <span class="number">9.5</span>,</span><br><span class="line">    pitch:<span class="number">0</span>,</span><br><span class="line">    viewMode:'3D',//开启3D视图,默认为关闭</span><br><span class="line">    buildingAnimation:<span class="literal">true</span>,<span class="comment">//楼块出现是否带动画</span></span><br><span class="line">    zooms:[<span class="number">9</span>,<span class="number">19</span>],</span><br><span class="line">    center:[<span class="number">116.45848</span>, <span class="number">38.87328</span>],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.layer = <span class="keyword">new</span> AMap.LabelsLayer(&#123;</span><br><span class="line">    zooms: [<span class="number">3</span>, <span class="number">20</span>],</span><br><span class="line">    zIndex: <span class="number">99999999999999999</span>,</span><br><span class="line">    visible: <span class="literal">true</span>,</span><br><span class="line">    collision: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 开启标注避让，默认为开启，v1.4.15 新增属性</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加入图层</span></span><br><span class="line"><span class="keyword">this</span>.amap.add(<span class="keyword">this</span>.layer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是canvas文字</span></span><br><span class="line">var text = <span class="keyword">new</span> AMap.LabelMarker(&#123;</span><br><span class="line">        position: [longitude, latitude],</span><br><span class="line">        zooms: [<span class="number">3</span>,<span class="number">20</span>],</span><br><span class="line">        extData: eachList,</span><br><span class="line">        text: &#123;</span><br><span class="line">            content: companyName,</span><br><span class="line">            style: &#123;</span><br><span class="line">                backgroundColor: <span class="string">"white"</span></span><br><span class="line">            &#125;,</span><br><span class="line">        offset: [<span class="number">0</span>,<span class="number">-33</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">this</span>.layer.add(text)</span><br></pre></td></tr></table></figure></p><p>实际上LabelsMarker也是可以绘制icon图标的，但是不知为何我用on函数绑定点击事件总是有一大半的点点了没反应，因此我还是使用了海量点(massMarker)</p><p>这样，在3D地图下较大量点的渲染就变得very smooth了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲扯&quot;&gt;&lt;a href=&quot;#闲扯&quot; class=&quot;headerlink&quot; title=&quot;闲扯&quot;&gt;&lt;/a&gt;闲扯&lt;/h2&gt;&lt;p&gt;这一个月我都在和高德地图打交道，遇到了很多问题，因为没人带，都是靠自己解决，走了不少弯路。高德地图其实很强大，你能想到的几乎上面都有。&lt;/p
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="高德地图" scheme="http://localhost:4000/tags/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>对于Symbol.iterator的理解</title>
    <link href="http://localhost:4000/2019/07/08/%E5%AF%B9%E4%BA%8ESymbol-iterator%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://localhost:4000/2019/07/08/%E5%AF%B9%E4%BA%8ESymbol-iterator%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2019-07-08T11:46:38.000Z</published>
    <updated>2019-07-08T12:25:10.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是iterator"><a href="#什么是iterator" class="headerlink" title="什么是iterator"></a>什么是iterator</h2><p>iterator就是迭代器的意思，在ES6里面，第一次看到的时候很懵逼，这是干什么的？那么还是直接看例子吧</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="for-in枚举"><a href="#for-in枚举" class="headerlink" title="for in枚举"></a>for in枚举</h3><p>我们都知道for in来枚举对象或者数组属性列表，如<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = &#123;name: <span class="string">"Qi"</span>,age: <span class="number">22</span>,job:<span class="string">"engineer"</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(var key in a)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(key)<span class="comment">// 打印 name  age  job</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，如果要直接打印属性值呢？一般我是下面这样做<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = &#123;name: <span class="string">"Qi"</span>,age: <span class="number">22</span>,job:<span class="string">"engineer"</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(var key in a)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(a[key])<span class="comment">// 打印 Qi 22 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>es6其实有个for of方法,使用上和for in差不多<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var b = ['Qi','22','engineer'];</span><br><span class="line"><span class="keyword">for</span>(var val in b)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(b);<span class="comment">// Qi 22 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里用数组举例，不用对象是因为对象并没有内置@@iterator迭代器，iterator迭代器只在数组、类数组对象、Map和Set结构中内置了，为什么对象没有内置？实际是因为对象的各成员并没有一个确定的顺序，所以谁先遍历谁后遍历就不确定了。给一个对象部署iterator接口，其实就是对该对象做一种线性转换。接下来看如何给对象部署迭代器。</p><h3 id="给对象部署iterator"><a href="#给对象部署iterator" class="headerlink" title="给对象部署iterator"></a>给对象部署iterator</h3><p>就用上面的例子，看看迭代器怎么工作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var b = ['Qi','22','engineer'];</span><br><span class="line">var it = b[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置的next方法</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'Qi',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: '22',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'engineer',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;done: true&#125;</span></span><br></pre></td></tr></table></figure></p><p>当然 如果直接这样连着打只会打印最后一行，这样只是展示了iterator的遍历顺序。我们使用ES6的Symbol.iterator来获取对象的@@iterator内部属性，要注意@@iterator本身不是一个迭代器对象，而是一个返回迭代器对象的函数</p><p>那么接下来看看如何给对象部署迭代器<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: <span class="string">"Zhou"</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    job: <span class="string">"engineer"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( obj,Symbol.iterator, &#123;</span><br><span class="line">    enumrable: <span class="literal">false</span>, <span class="comment">// 是否可枚举</span></span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 只读 writable 给的说明是如果设置为 false, 不可以采用 数据运算符 进行赋值</span></span><br><span class="line">    configurable: <span class="literal">true</span>, <span class="comment">// 可操作 为false的话不可以修改, 不可以删除.</span></span><br><span class="line">    value: function() &#123;</span><br><span class="line">        var _this = <span class="keyword">this</span>;</span><br><span class="line">        var idx = <span class="number">0</span>;</span><br><span class="line">        var ks = Object.keys( _this ); <span class="comment">// Object.keys()方法传入一个对象返回其属性名</span></span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            next: function() &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: _this[ks[idx++]],</span><br><span class="line">                    done: (idx &gt; ks.length)</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var it = obj[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置的next方法</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'Zhou',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: '22',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'engineer',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined,done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用for of 遍历我们的obj对象</span></span><br><span class="line"><span class="keyword">for</span>(var val of obj)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(val); <span class="comment">// Zhou 22 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这实际上就是用强大的Object.defineProperty(vue中数据的双向绑定就是使用该方法)方法把Symbol.iterator写进了对象里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是iterator&quot;&gt;&lt;a href=&quot;#什么是iterator&quot; class=&quot;headerlink&quot; title=&quot;什么是iterator&quot;&gt;&lt;/a&gt;什么是iterator&lt;/h2&gt;&lt;p&gt;iterator就是迭代器的意思，在ES6里面，第一次看到的时候很懵
      
    
    </summary>
    
    
      <category term="学习" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://localhost:4000/tags/ES6/"/>
    
      <category term="iterator" scheme="http://localhost:4000/tags/iterator/"/>
    
  </entry>
  
  <entry>
    <title>hbuilder打包vue项目遇到的布局以及图片路径问题坑</title>
    <link href="http://localhost:4000/2019/07/02/hbuilder%E6%89%93%E5%8C%85vue%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%9D%91/"/>
    <id>http://localhost:4000/2019/07/02/hbuilder%E6%89%93%E5%8C%85vue%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%9D%91/</id>
    <published>2019-07-02T11:55:26.000Z</published>
    <updated>2019-07-02T12:05:54.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们的项目用hbuilder打包成安卓app,最近主要遇到了两个问题:</p><ul><li>打包后登录页底部总是有空白，后面根据我仔细观察，发现那个空白的高度和手机状态栏是一样的</li><li>打包后高德地图的海量点icon图标不显示了？！在pc端调试的时候可都是没问题的！</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>要说都是小问题，可是对于我这样才入职的程序员小白来说还真花了一番功夫才解决<br>首先说下hbuilder打包后登录页留白的问题。原因我还没找到，我感觉可能是bug?因为我只有第一次进入登录页才会留白，从app登录后点退出回到登录页后就没有留白了。</p><ul><li>解决这个问题的核心是获取到当前手机的状态栏高度<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里可以算是获取状态栏高度吧，实际是获取的屏幕高度与非工作区域高度的差值</span></span><br><span class="line"><span class="keyword">const</span> stateHeight = window.screen.height - document.documentElement.clientHeight;</span><br><span class="line"><span class="comment">// 这里stateHeight为啥要除以2呢？这就是我觉得是bug的原因！hbuilder给我打包后登录页留白是因为出现了两个状态栏！只是其中一个在底部，而且是空白。</span></span><br><span class="line"><span class="keyword">this</span>.$refs.main.style.height = window.screen.height - stateHeight / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个问题就算解决了</p><p>再说第二个，为啥打包后高德地图海量点的图标不显示了？</p><ul><li>路径原因！下面看看我改之前的代码<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前我是这么写的海量点路径</span></span><br><span class="line">...</span><br><span class="line">style: [&#123;</span><br><span class="line">          url: '../../static/images/img.png',</span><br><span class="line">          anchor: <span class="keyword">new</span> AMap.Pixel(<span class="number">16</span>, <span class="number">35</span>),</span><br><span class="line">          size: <span class="keyword">new</span> AMap.Size(<span class="number">25</span>, <span class="number">32</span>),</span><br><span class="line">        &#125;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>这样似乎没问题，我其他页面的图都是这么写的，并且打包后能正常显示。但是高德地图的icon地址就不能这么写了<br>一定要写成<strong>static/images/img.png</strong>，也就是说不要前面的../!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;我们的项目用hbuilder打包成安卓app,最近主要遇到了两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包后登录页底部总是有空白，后面根据我仔细
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="hbuilder" scheme="http://localhost:4000/tags/hbuilder/"/>
    
      <category term="app" scheme="http://localhost:4000/tags/app/"/>
    
  </entry>
  
  <entry>
    <title>vue中使用高德地图展示点信息以及海量点的使用</title>
    <link href="http://localhost:4000/2019/07/02/vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E5%B1%95%E7%A4%BA%E7%82%B9%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8A%E6%B5%B7%E9%87%8F%E7%82%B9%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://localhost:4000/2019/07/02/vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E5%B1%95%E7%A4%BA%E7%82%B9%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8A%E6%B5%B7%E9%87%8F%E7%82%B9%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-07-02T11:19:44.000Z</published>
    <updated>2019-07-02T12:07:12.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天算是彻底解决了地图部分的难点，第一次上线项目，确实遇到很多问题，好在也慢慢在解决了。下面说一下，在做地图这块一路上主要遇到的问题</p><ul><li>一开始使用的是marker,也就是普通的点标记，这个其实很简单，操作起来也很容易，但是有个问题是一旦点多起来后，页面地图那块的加载会变得非常慢</li><li>接下来我就考虑并使用了点聚合，这个确实很大程度上解决了卡顿的问题，但是上面继续提需求，就是要显示每个点，并且要在每个点旁边显示公司名,在marker里就是一个label来实现</li><li>点聚合还是走不通，并且我发现了DOM渲染数量到了一定程度过后，哪怕你渲染的div样式非常简单，简单到只是一行字符串，也会卡顿很久，也就是说只要DOM元素达到800以上，特别是1000多以后，会阻塞页面</li><li>接下来我还是用的marker，不过这次我判断后台返回的数据如果大于650条我就拆分两次渲染，第二次使用setTimeout异步渲染，这样有一定效果，但还是非常不理想，前面几百个渲染倒还算流畅，但后面几百个渲染的时候依然会阻塞页面，导致卡顿</li><li>最后，我用了海量点，海量点是canvas渲染的，性能比dom高了不知道多少，2000个点几百毫秒就渲染完毕，完全没有卡顿的感觉。</li><li>然后又遇到了新问题：要在旁边显示每个点的名称，类似label标签那种，官方海量点并没有提供这个功能，倒是有个类似marker的text可以实现这种效果，但说白了，那还是一个DIV，也就是说又是dom渲染，我试了，还是会很卡，又回到最初的起点？！</li><li>最最最后，我想到了类似于图片懒加载，我就称其为懒渲染吧，还算完美的解决了这个问题。</li></ul><h2 id="详细攻略"><a href="#详细攻略" class="headerlink" title="详细攻略"></a>详细攻略</h2><p>先看看要实现的效果<br><img src="/BeCoderQ.github.io/2019/07/02/vue中使用高德地图展示点信息以及海量点的使用/mapPoints.png" alt="mapPoints.png"><br>可以看到虽然不美观，但是领导就要求这么做，点特别多，DOM渲染的话，效率真的很低。海量点经过canvas性能的加持，对这种密集点的加载比marker那真的好太多了，主要问题还是如图旁边公司名的渲染方式，我是利用了高的官方提供的getBounds()方法，获得northEast(右上方)以及southWest(左下方)的经纬度来确定当前屏幕显示的经纬度范围。我们这边项目后台返回了每个点的经纬度，那么我就遍历这些经纬度，在for循环里if判断第i个点的经纬度是否在这个范围内，在，那么使用textMarker传入这个经纬度数值，渲染公司名，虽然还是div，还是dom渲染，但是只是在当前屏幕与显示范围内的话，那么效率就高了非常非常多了。下面说下详细操作</p><ul><li>在高德提供的地图移动事件中，判断，如果地图放大等级zoom的大小，大于某个等级再执行以下操作，这一步是为了防止用户把地图缩很小过后，屏幕显示内容的经纬度范围就很大，这样的话恐怕又会渲染每个点了！</li><li>那么继续，大于某个放大等级后，我们就进行刚才我说的循环与判断以及渲染。</li></ul><p>还是上一点代码吧，完整改动的代码忘记copy回家了，自己凭记忆写了一份<br>下面是海量点部分<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var mass = <span class="keyword">new</span> AMap.MassMarks(arr, &#123;</span><br><span class="line">        opacity: <span class="number">0.8</span>,</span><br><span class="line">        zIndex: <span class="number">999999</span>,</span><br><span class="line">        cursor: 'pointer',</span><br><span class="line">        style: [&#123;</span><br><span class="line">          url: '//a.amap.com/jsapi_demos/static/demo-center/icons/poi-marker-default.png',</span><br><span class="line">          anchor: <span class="keyword">new</span> AMap.Pixel(<span class="number">16</span>, <span class="number">35</span>),</span><br><span class="line">          size: <span class="keyword">new</span> AMap.Size(<span class="number">25</span>, <span class="number">32</span>),</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.realMass = mass;</span><br><span class="line">      mass.setMap(self.<span class="built_in">map</span>); </span><br><span class="line">      mass.on('click', function (e) &#123;</span><br><span class="line">        let arrInfo = eachList[e.data.id];</span><br><span class="line">        self.diliveryInfo = arrInfo;</span><br><span class="line">        self.getDevTotal(arrInfo.companyNo);</span><br><span class="line">        <span class="comment">// 赋值经纬度 以便导航</span></span><br><span class="line">        self.nowLongtitude = arrInfo.longitude;</span><br><span class="line">        self.nowLatitude = arrInfo.latitude;</span><br><span class="line">        self.detailFlag = <span class="literal">true</span>;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure></p><p>地图移动事件中渲染公司名部分<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(let i = <span class="number">0</span>;i&lt;eachList.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(这里面判断遍历的经纬度是否在屏幕范围内，使用getBounds()方法)&#123;</span><br><span class="line">        var text = <span class="keyword">new</span> AMap.Text(&#123;</span><br><span class="line">          text: eachList[i].companyName,</span><br><span class="line">          anchor:'center', // 设置文本标记锚点</span><br><span class="line">          cursor:'pointer',</span><br><span class="line">          style:&#123;</span><br><span class="line">            'border-radius': '10px',</span><br><span class="line">            'background-color': 'white',</span><br><span class="line">            'width': '130px',</span><br><span class="line">            'border-width': 0,</span><br><span class="line">            'text-align': 'center',</span><br><span class="line">            'font-size': '10px',</span><br><span class="line">            'color': 'blue',</span><br><span class="line">            'position': 'relative',</span><br><span class="line">            'left': '81px',</span><br><span class="line">            'top': '-19px',</span><br><span class="line">          &#125;,</span><br><span class="line">          position: [eachList[i].longitude,eachList[i].latitude]</span><br><span class="line">        &#125;);</span><br><span class="line">        self.realText.push(text)</span><br><span class="line">        text.setMap(self.<span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;今天算是彻底解决了地图部分的难点，第一次上线项目，确实遇到很多问题，好在也慢慢在解决了。下面说一下，在做地图这块一路上主要遇到的问题&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="海量点" scheme="http://localhost:4000/tags/%E6%B5%B7%E9%87%8F%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>记一次解决axios请求status返回canceled的过程</title>
    <link href="http://localhost:4000/2019/06/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3axios%E8%AF%B7%E6%B1%82status%E8%BF%94%E5%9B%9Ecanceled%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://localhost:4000/2019/06/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3axios%E8%AF%B7%E6%B1%82status%E8%BF%94%E5%9B%9Ecanceled%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2019-06-12T13:25:00.000Z</published>
    <updated>2019-06-12T13:42:27.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><ul><li>昨天下午<br>在APP一个页面的数据绑定时发现拿不到数据，到network里看了一下，发现那个post请求的红了，status是canceled,也就是取消，作为一个英语六级(差两分)的程序员，看到ed我第一反应就是被动，被取消了，被谁取消了？那铁定是被后台服务器端的取消了，那不关我前端的事咯！果断告诉后端的小老弟，他们那边是接受到这个请求的，但显示的是请求被中断，大家也都普遍是没多少经验的菜鸟，他们也以为是自己后端服务器的问题，然后那天忙活到下班都没解决。</li><li>今天<br>今天后端的同学除了做其他的几个接口，就继续搞昨天那个问题了，经过各种调试分析，最后用一个以太网的软件发现其实服务器是正确返回了数据的，并且status是200，那么，问题就是前端的了。</li></ul><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>在chrome的network里是真的没什么线索，但是我发现每次请求的时间都是1.01s,就被取消了，然后红字，status显示canceled。于是我把注意力转向了我们使用的ajax请求。<br>我们使用的是github上别人封装的axios,我找到源码，如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  post (url, data) &#123;</span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">      method: 'post',</span><br><span class="line">      baseURL: 'http://192.168.0.105:19090',</span><br><span class="line">      url,</span><br><span class="line">      dataType: <span class="string">"json"</span>,</span><br><span class="line">      data: qs.stringify(data),</span><br><span class="line">      <span class="comment">// timeout啊，怎么就设置成1S了？坑了大伙</span></span><br><span class="line">      timeout: <span class="number">1000</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        'X-Requested-With': 'XMLHttpRequest',</span><br><span class="line">        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(</span><br><span class="line">      (response) =&gt; &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(response)</span><br><span class="line">        <span class="keyword">return</span> checkStatus(response)</span><br><span class="line">      &#125;</span><br><span class="line">    ).then(</span><br><span class="line">      (res) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> checkCode(res)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>很快就发现了这个timeout,咋回事 居然是1000？？往后加了个0，果然解决了。<br>这里其实就是这个timeout决定前端请求的时间，因为我请求的那个数据量比较大，因此请求时间1S内是无法完成的，之前请求的数据量比较小，所以没有发现这个问题。</p><h2 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h2><p>果然遇到的都是小问题，但是这么小的问题，也能卡住我一天。这就是经验的积累吧，虽然是小小的经验，但是长期的积累就是通向大神的道路，希望自己能坚持记录这些问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题阐述&quot;&gt;&lt;a href=&quot;#问题阐述&quot; class=&quot;headerlink&quot; title=&quot;问题阐述&quot;&gt;&lt;/a&gt;问题阐述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;昨天下午&lt;br&gt;在APP一个页面的数据绑定时发现拿不到数据，到network里看了一下，发现那个post请求的红
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="axios" scheme="http://localhost:4000/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>vue.cli3.x打包上传服务器后首次加载太慢的坑</title>
    <link href="http://localhost:4000/2019/06/10/vue-cli3-x%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E9%A6%96%E6%AC%A1%E5%8A%A0%E8%BD%BD%E5%A4%AA%E6%85%A2%E7%9A%84%E5%9D%91/"/>
    <id>http://localhost:4000/2019/06/10/vue-cli3-x%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E9%A6%96%E6%AC%A1%E5%8A%A0%E8%BD%BD%E5%A4%AA%E6%85%A2%E7%9A%84%E5%9D%91/</id>
    <published>2019-06-10T13:45:07.000Z</published>
    <updated>2019-06-10T14:01:48.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>端午节前发现的问题，6号那天只上了半天班就放假了，那半天也是没找出个所以然，今天节后搞了半天才解决，主要是项目build后上传云端服务器第一次进入首页会加载很长时间，作为一个小白，花了一番功夫才解决。</p><h2 id="分析与解决"><a href="#分析与解决" class="headerlink" title="分析与解决"></a>分析与解决</h2><p>打包后我发现chunk-vendors.js这个文件比较大，有880KB左右，并且在浏览器network中看到也是这个文件加载时间最长，长的时候甚至超过20秒，严重影响了使用体验。于是我就从这里下手</p><ul><li>这个vendors.js是所有第三方插件的集合，我主要用了ElementUI，后面我发现就这玩意儿占了880KB的三分之二，究其原因是我没有按需引入，而是简单粗暴的全局导入了。这里我将ElementUI使用CDN方式导入，但是有一点要注意，CDN导入ElementUI后Vue也必须使用CDN导入，并且要放在ElementUI的前面！最后，必须在<strong>vue.config.js</strong>文件中配置如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">externals: &#123;</span><br><span class="line">    &apos;vue&apos;: &apos;Vue&apos;,</span><br><span class="line">    &apos;element-ui&apos;: &apos;ElEMENT&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这是告诉webpack你用了外部标签引入</p><ul><li><p>这样做了过后还是慢得很，尽管vendor.js只有160KB了！那么又看network,我又发现vendor.css这个文件，加载时间很长，200多KB大。当时我在想vendor.js是第三方插件，那么这个vendor.css应该是第三方样式吧？第三方样式我只用了ElmentUI,并且用link标签导入了，要这家伙何用？果断删除掉，然后速度又快了一点，在火狐与IE浏览器里打开速度基本正常了，chrome浏览器里也只要5S左右了。<br><strong>但是问题还是没解决，还是慢啊！</strong></p></li><li><p>于是又发现了个神器，gzip</p></li></ul><p>服务器端配合配置</p><p>还是有疑问：<br>1.脚手架中怎样让js不影响页面渲染？<br>2.为何一两百KB的JS文件CSS文件下载还是那么慢？<br>3.为何还是每个页面都加载了所有JS与CSS？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题阐述&quot;&gt;&lt;a href=&quot;#问题阐述&quot; class=&quot;headerlink&quot; title=&quot;问题阐述&quot;&gt;&lt;/a&gt;问题阐述&lt;/h2&gt;&lt;p&gt;端午节前发现的问题，6号那天只上了半天班就放假了，那半天也是没找出个所以然，今天节后搞了半天才解决，主要是项目build后上
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue.cli3" scheme="http://localhost:4000/tags/vue-cli3/"/>
    
  </entry>
  
  <entry>
    <title>ES6特性之解构</title>
    <link href="http://localhost:4000/2019/06/01/ES6%E7%89%B9%E6%80%A7%E4%B9%8B%E8%A7%A3%E6%9E%84/"/>
    <id>http://localhost:4000/2019/06/01/ES6%E7%89%B9%E6%80%A7%E4%B9%8B%E8%A7%A3%E6%9E%84/</id>
    <published>2019-06-01T13:31:21.000Z</published>
    <updated>2019-06-08T05:54:36.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>假设我们要把一个对象里的值都”倒”出来，怎么做最简单？以往我是这么做的<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设要倒出的对象是obj</span></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name: <span class="string">"chow"</span>,</span><br><span class="line">    habit: <span class="string">"basketball"</span>,</span><br><span class="line">    language: <span class="string">"javascript"</span>,</span><br><span class="line">    job: <span class="string">"programmer"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function putItUp(obj)&#123;</span><br><span class="line">    let name,habit,language,job;</span><br><span class="line">    name = obj.name;</span><br><span class="line">    habit = obj.habit;</span><br><span class="line">    language = obj.language;</span><br><span class="line">    job = obj.job;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样操作显然并不优雅，虽然水平不高，但是也要向着优雅编程的方向前进！</p><p>对象解构大法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: <span class="string">"chow"</span>,</span><br><span class="line">    habit: <span class="string">"basketball"</span>,</span><br><span class="line">    language: <span class="string">"javascript"</span>,</span><br><span class="line">    job: <span class="string">"programmer"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function putItUp()&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(name,habit,language,job);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">putItUp( &#123;name,habit,language,job&#125; = obj); <span class="comment">// chow basketball javascript programmer</span></span><br></pre></td></tr></table></figure></p><p>左边{}里的是obj内的键，注意不能写错了，当然那个键名是可以修改的，后面会说。右边就是要结构的对象，多层嵌套对象的结构同理</p><h3 id="多层对象解构"><a href="#多层对象解构" class="headerlink" title="多层对象解构"></a>多层对象解构</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多层嵌套对象解构</span></span><br><span class="line">let person = &#123;</span><br><span class="line">    name: <span class="string">"chow"</span>,</span><br><span class="line">    habit: <span class="string">"basketball"</span>,</span><br><span class="line">    language: <span class="string">"javascript"</span>,</span><br><span class="line">    job: <span class="string">"programmer"</span></span><br><span class="line">    address:&#123;</span><br><span class="line">        zipcode: <span class="number">1234</span>,</span><br><span class="line">        street: 'rainbow',</span><br><span class="line">        number: <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let &#123;address: &#123;zipcode, street, number&#125;&#125; = person;</span><br><span class="line"><span class="comment">// 或者是let &#123;zipcode, street, number&#125; = person.address;</span></span><br><span class="line">console.<span class="built_in">log</span>(zipcode, street, number); <span class="comment">// 1234 rainbow 42</span></span><br></pre></td></tr></table></figure><h3 id="修改键名"><a href="#修改键名" class="headerlink" title="修改键名"></a>修改键名</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多层嵌套对象解构</span></span><br><span class="line">let person = &#123;</span><br><span class="line">    name: <span class="string">"chow"</span>,</span><br><span class="line">    habit: <span class="string">"basketball"</span>,</span><br><span class="line">    language: <span class="string">"javascript"</span>,</span><br><span class="line">    job: <span class="string">"programmer"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let &#123; name: myName,habit: thisHabit,language,job&#125; = person;</span><br><span class="line">console.<span class="built_in">log</span>(myName, thisHabit, language,job); <span class="comment">// chow basketball javascript programmer</span></span><br></pre></td></tr></table></figure><p>这样相当于修改了对象内成员的键名</p><h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>和对象解构类似<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var <span class="built_in">list</span> = [<span class="string">"C"</span>,<span class="string">"H"</span>,<span class="string">"O"</span>,<span class="string">"W"</span>];</span><br><span class="line"><span class="comment">// 只需要将&#123;&#125;换为[]</span></span><br><span class="line">var [C,H,O,W] = <span class="built_in">list</span>;</span><br><span class="line">console.<span class="built_in">log</span>(C,H,O,W); <span class="comment">// C H O W;</span></span><br></pre></td></tr></table></figure></p><p>二维数组也很简单<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var <span class="built_in">list</span> = [<span class="string">"C"</span>,[<span class="string">"H"</span>,<span class="string">"O"</span>],<span class="string">"W"</span>];</span><br><span class="line"><span class="comment">// 只需要将&#123;&#125;换为[]</span></span><br><span class="line">var [C,[H,O],W] = <span class="built_in">list</span>;</span><br><span class="line">console.<span class="built_in">log</span>(C,H,O,W); <span class="comment">// C H O W;</span></span><br></pre></td></tr></table></figure></p><ul><li>未完待续</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象解构&quot;&gt;&lt;a href=&quot;#对象解构&quot; class=&quot;headerlink&quot; title=&quot;对象解构&quot;&gt;&lt;/a&gt;对象解构&lt;/h2&gt;&lt;p&gt;假设我们要把一个对象里的值都”倒”出来，怎么做最简单？以往我是这么做的&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ES6" scheme="http://localhost:4000/tags/ES6/"/>
    
      <category term="解构" scheme="http://localhost:4000/tags/%E8%A7%A3%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>总结在ElementUI中的一些组件使用</title>
    <link href="http://localhost:4000/2019/06/01/%E6%80%BB%E7%BB%93%E5%9C%A8ElementUI%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://localhost:4000/2019/06/01/%E6%80%BB%E7%BB%93%E5%9C%A8ElementUI%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2019-06-01T04:36:14.000Z</published>
    <updated>2019-06-08T05:54:14.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>最近在做一个后台管理系统，前端使用vue全家桶+ElementUI搭建，总结一下目前为止一些重要组件的使用</p><h2 id="ElementUI表格"><a href="#ElementUI表格" class="headerlink" title="ElementUI表格"></a>ElementUI表格</h2><p>ElmentUI的表格是通过:data=”xxx” 然后单元格使用prop=”数组中的键”来渲染的。我昨天遇到一个问题是要根据条件单独更改某个单元格内文字的颜色，查了一下，用下面的方法可以实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;el-table</span><br><span class="line">      :data=<span class="string">"tableData"</span></span><br><span class="line">      style=<span class="string">"width: 100%"</span>&gt;</span><br><span class="line">      &lt;el-table-column prop=<span class="string">"date"</span> label=<span class="string">"日期"</span> width=<span class="string">"180"</span>&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 假设我想让等级为2以上的字体变成红色</span></span><br><span class="line">      &lt;el-table-column prop=<span class="string">"name"</span> label=<span class="string">"等级"</span> width=<span class="string">"180"</span>&gt; <span class="comment">// 这里的prop可以不用写了</span></span><br><span class="line">        &lt;<span class="keyword">template</span> slot-scope=<span class="string">"scope"</span>&gt;</span><br><span class="line">            &lt;span v-<span class="keyword">if</span>=<span class="string">"scope.row.name &gt; 2"</span> style=<span class="string">"color: red"</span>&gt;二级以上&lt;/span&gt;</span><br><span class="line">            &lt;span v-<span class="keyword">else</span>&gt;二级以下&lt;/span&gt;</span><br><span class="line">        &lt;/<span class="keyword">template</span>&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-table-column prop=<span class="string">"address"</span> label=<span class="string">"地址"</span>&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">&lt;/el-table&gt;</span><br></pre></td></tr></table></figure></p><h2 id="ElementUI表单验证"><a href="#ElementUI表单验证" class="headerlink" title="ElementUI表单验证"></a>ElementUI表单验证</h2><p>表单验证这里我总结一下步骤:</p><ul><li><p>在&lt;\el-form&gt;上 写上ref钩子以及规则属性</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;el-dialog title=<span class="string">"新增"</span> :visible.sync=<span class="string">"addVisible"</span> width=<span class="string">"30%"</span> @close=<span class="string">"close"</span> :close-on-click-modal=<span class="string">"false"</span>&gt;</span><br><span class="line">    &lt;el-form ref=<span class="string">"info"</span> :model=<span class="string">"info"</span> label-width=<span class="string">"80px"</span> :rules=<span class="string">"rules"</span>&gt;</span><br><span class="line">        ......</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure></li><li><p>在data中写上一个对象属性rules，内部成员都是数组对象形式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">    levelType: [</span><br><span class="line">        &#123; required: <span class="literal">true</span>, message: <span class="string">"请选择预警等级"</span>, trigger: <span class="string">"blur"</span> &#125;</span><br><span class="line">        &#123; min: 5, max: 15, message: '长度在 5 到 15 个字符', trigger: 'blur' &#125;</span><br><span class="line">    ],</span><br><span class="line">    warnState: [</span><br><span class="line">        &#123; required: <span class="literal">true</span>, message: <span class="string">"请选择有效状态"</span>, trigger: <span class="string">"blur"</span> &#125;</span><br><span class="line">        &#123; min: 5, max: 15, message: '长度在 5 到 15 个字符', trigger: 'blur' &#125;</span><br><span class="line">    ],</span><br><span class="line">    startDate: [</span><br><span class="line">        &#123; required: <span class="literal">true</span>, message: <span class="string">"请选择开始时间"</span>, trigger: <span class="string">"blur"</span> &#125;</span><br><span class="line">        &#123; min: 5, max: 15, message: '长度在 5 到 15 个字符', trigger: 'blur' &#125;</span><br><span class="line">    ],</span><br><span class="line">    endDate: [</span><br><span class="line">        &#123; required: <span class="literal">true</span>, message: <span class="string">"请选择结束时间"</span>, trigger: <span class="string">"blur"</span> &#125;</span><br><span class="line">        &#123; min: 5, max: 15, message: '长度在 5 到 15 个字符', trigger: 'blur' &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为表单选项添加prop属性，prop等于的就是刚才rules对象里的对应值。这里要注意一点，每个表单选项里的v-model双向数据必须是xxx.xxx即对象形式的，不能直接写属性。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;el-form-item label=<span class="string">"预警等级"</span> prop=<span class="string">"levelType"</span>&gt;</span><br><span class="line">    &lt;el-select v-model=<span class="string">"info.levelType"</span> placeholder=<span class="string">"选择预警类型"</span>&gt;</span><br><span class="line">        &lt;el-option v-<span class="keyword">for</span>=<span class="string">"item in levelType"</span> :key=<span class="string">"item"</span> :label=<span class="string">"item"</span> :value=<span class="string">"item"</span>&gt;&lt;/el-option&gt;</span><br><span class="line">    &lt;/el-select&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-form-item label=<span class="string">"有效状态"</span> prop=<span class="string">"warnState"</span>&gt;</span><br><span class="line">    &lt;el-select v-model=<span class="string">"info.warnState"</span> placeholder=<span class="string">"选择预警类型"</span>&gt;</span><br><span class="line">        &lt;el-option v-<span class="keyword">for</span>=<span class="string">"item in warnState"</span> :key=<span class="string">"item"</span> :label=<span class="string">"item"</span> :value=<span class="string">"item"</span>&gt;&lt;/el-option&gt;</span><br><span class="line">    &lt;/el-select&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-form-item label=<span class="string">"开始时间"</span> prop=<span class="string">"startDate"</span>&gt;</span><br><span class="line">    &lt;el-date-picker v-model=<span class="string">"info.startDate"</span> type=<span class="string">"datetime"</span> placeholder=<span class="string">"选择开始时间"</span>&gt;&lt;/el-date-picker&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-form-item label=<span class="string">"结束时间"</span> prop=<span class="string">"endDate"</span>&gt;</span><br><span class="line">    &lt;el-date-picker v-model=<span class="string">"info.endDate"</span> type=<span class="string">"datetime"</span> placeholder=<span class="string">"选择结束时间"</span>&gt;&lt;/el-date-picker&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br></pre></td></tr></table></figure></li><li><p>一般来说我们点击确认的时候会验证全部表单，这里给我们的确认按钮绑定事件，并将前面的ref钩子传入函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;span slot=<span class="string">"footer"</span> class=<span class="string">"dialog-footer"</span>&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">"addVisible = false"</span>&gt;取 消&lt;/el-button&gt;</span><br><span class="line">    &lt;el-button type=<span class="string">"primary"</span> @click=<span class="string">"saveAdd('info')"</span>&gt;确 定&lt;/el-button&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></li><li><p>点击确认后，进行表单验证</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">saveAdd(info) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$refs[info].validate(valid =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">          <span class="comment">// 验证成功后要进行的操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.$message.info(<span class="string">"请将必填信息填写完整！"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>最后还有一点，这里我的应用场景是新增信息，而新增信息框是一个弹出式的，可以关闭，那么我们还有最后一步，就是在关闭后清除所有错误提示，避免在用户输入错误表单提示后下一次点开错误提示还在那儿</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭弹框清除表单验证的提示信息</span></span><br><span class="line">close()&#123;</span><br><span class="line">    this.$refs['info'].resetFields();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用背景&quot;&gt;&lt;a href=&quot;#使用背景&quot; class=&quot;headerlink&quot; title=&quot;使用背景&quot;&gt;&lt;/a&gt;使用背景&lt;/h2&gt;&lt;p&gt;最近在做一个后台管理系统，前端使用vue全家桶+ElementUI搭建，总结一下目前为止一些重要组件的使用&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="ElementUI" scheme="http://localhost:4000/tags/ElementUI/"/>
    
  </entry>
  
  <entry>
    <title>this的使用与原理解析</title>
    <link href="http://localhost:4000/2019/05/26/this%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://localhost:4000/2019/05/26/this%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2019-05-26T04:18:28.000Z</published>
    <updated>2019-06-08T06:01:09.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于this关键字"><a href="#关于this关键字" class="headerlink" title="关于this关键字"></a>关于this关键字</h1><ul><li>每个函数的this是在调用时被绑定的，并非是在编写时绑定，它的上下文取决于函数调用时的各种条件。<strong>this的绑定和函数声明的位置没有任何关系</strong>，只取决于<strong>函数的调用方式</strong>。</li><li>当一个函数被调用时，会创建一个活动记录(即执行上下文)，这个记录会包含函数在哪里被调用(<strong>调用栈</strong>)、函数的<strong>调用方式</strong>、传入的参数信息等。this就是这个记录的一个属性，会在函数执行的过程中用到。</li></ul><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>调用位置是函数在代码中被调用执行的位置(不是声明的位置)，如:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">one</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    console.<span class="built_in">log</span>(a);<span class="comment">// 2</span></span><br><span class="line">two();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">two</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(a);<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">var a = <span class="number">1</span>;</span><br><span class="line">one();</span><br></pre></td></tr></table></figure></p><p>这里的two调用位置就是one函数里</p><ul><li>只有仔细分析调用位置才能弄清楚this到底引用的是什么</li></ul><h3 id="分析调用栈"><a href="#分析调用栈" class="headerlink" title="分析调用栈"></a>分析调用栈</h3><p>调用栈和调用位置:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">baz</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是 baz</span></span><br><span class="line">    <span class="comment">// 当前调用位置是全局作用域</span></span><br><span class="line"></span><br><span class="line">    console.log('baz');</span><br><span class="line">    bar(); <span class="comment">// &lt;-- 这里是bar函数的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是 baz -&gt; bar</span></span><br><span class="line">    <span class="comment">// 当前调用位置在baz函数中</span></span><br><span class="line"></span><br><span class="line">    console.log('bar');</span><br><span class="line">    foo(); <span class="comment">// &lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class="line">    <span class="comment">// 当前调用位置在函数bar中</span></span><br><span class="line"></span><br><span class="line">    console.log('foo');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz() <span class="comment">// &lt;-- baz函数的调用位置，在全局环境中</span></span><br></pre></td></tr></table></figure></p><p>我们可以把调用栈想成函数调用链，但这种方法容易出错。另一个更好的办法是在浏览器，如chrome浏览器，在f12调试模式下的代码中插入一条debbuger代码，打断点，我们可以在Call Stack栏中看到当前函数的调用栈。关于debugger后面再做详细笔记。</p><h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><p>this有四种绑定规则:</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">var a = <span class="number">1</span>;</span><br><span class="line">foo(); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure><p>这里的this指向了全局window对象，函数调用时应用了this的默认绑定。但注意，在严格模式下，则不能将全局对象用于默认绑定，上面代码运行在严格模式下会输出TypeError.</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><ul><li>隐式绑定考虑调用位置是否被某个对象拥有或者包含，即在一个对象内部包含一个指向函数的属性:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj =&#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure></li></ul><p>对于上面的foo函数，调用位置会使用obj对象的上下文来引用函数，可以认为foo被obj对象包含。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象，因此这里this.a就是obj.a。从这个例子也能看出，this的引用与函数声明位置无关，与函数的调用位置有关。</p><ul><li>对于上面的例子的补充说明：对象属性引用链中只有上一层或最后一层在调用位置中起作用，看下面例子:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: <span class="number">333</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); <span class="comment">// 输出3 而非333</span></span><br></pre></td></tr></table></figure></li></ul><p>可以看到这里this还是指向了obj2对象的上下文。</p><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><ul><li>隐式丢失是指被隐式绑定的函数会丢失绑定对象，然后应用了默认绑定。看下面例子<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj =&#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = <span class="number">4</span>; <span class="comment">// 全局声明了变量a=4</span></span><br><span class="line"></span><br><span class="line">var newObj = obj.foo;</span><br><span class="line">newObj(); <span class="comment">// 输出4 而不是2</span></span><br></pre></td></tr></table></figure></li></ul><p>这里看起来newObj是obj.foo的一个引用，但实际上它引用的是foo函数本身，因此newObj()是一个不带任何修饰符(即类似xxx.newObj的形式)的函数调用，所以应用了默认绑定，this指向了window对象。</p><ul><li>下面看另一个更微妙的例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">console.<span class="built_in">log</span>( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数doFoo接受一个函数参数，并执行它</span></span><br><span class="line"><span class="function">function <span class="title">doFoo</span><span class="params">(fn)</span></span>&#123;</span><br><span class="line">fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = '全局里的a';</span><br><span class="line">doFoo( obj.foo ); <span class="comment">// 输出'全局里的a'</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>参数传递其实就是一种隐式赋值</strong>，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><ul><li>显式绑定简单粗暴地说就是使用<strong>apply()</strong>与<strong>call()</strong>，考虑下方最基本的用法:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">cool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">cool.apply( obj ); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure></li></ul><p>通过apply或call强制将this绑定到obj。</p><h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><ul><li>硬绑定可以解决丢失绑定的问题<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">cool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = function()&#123;</span><br><span class="line">    cool.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 输出2</span></span><br><span class="line">setTimeout( bar,<span class="number">100</span> ); <span class="comment">// 还是输出2 没有因为隐式赋值改变值</span></span><br><span class="line"></span><br><span class="line">bar.call( window );<span class="comment">// 2 硬绑定的bar不能在修改它的this指向</span></span><br></pre></td></tr></table></figure></li></ul><p>上面的代码中，我们创建了函数bar,并在其内部调用了cool.call(obj),强制将cool的this绑定到了obj.无论之后如何调用函数bar,它总会手动在obj上调用cool，这种显示的强制绑定被称为硬绑定。硬绑定在ES5是有内置方法的：使用bind即可实现。</p><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>new是最后一种可以影响函数调用时this绑定行为的方法。</p><h4 id="new一个函数时发生了什么"><a href="#new一个函数时发生了什么" class="headerlink" title="new一个函数时发生了什么"></a>new一个函数时发生了什么</h4><p>1.创建(或者说构造)一个全新对象。<br>2.这个新对象会被执行[[Prototype]]连接。<br>3.这个新对象会绑定到函数调用的this。<br>4.如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line">console,<span class="built_in">log</span>(bar.a); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>使用new来调用foo()时，会构造出一个新对象，并把它绑定到foo()调用中的this上。</p><h2 id="四种规则的优先级"><a href="#四种规则的优先级" class="headerlink" title="四种规则的优先级"></a>四种规则的优先级</h2><ul><li>首先可以确定，<strong>默认绑定的优先级是最低的</strong>，那么看看隐式绑定和显式绑定的优先级</li></ul><h3 id="隐式绑定与显式绑定优先级比较"><a href="#隐式绑定与显式绑定优先级比较" class="headerlink" title="隐式绑定与显式绑定优先级比较"></a>隐式绑定与显式绑定优先级比较</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(); <span class="comment">// 2</span></span><br><span class="line">obj2.foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2 ); <span class="comment">// 3</span></span><br><span class="line">obj2.foo.call( obj1 ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>可以看出来显式绑定的优先级更高，也就是说判断时应该先考虑是否存在显示绑定。</p><h3 id="隐式绑定与new绑定优先级比较"><a href="#隐式绑定与new绑定优先级比较" class="headerlink" title="隐式绑定与new绑定优先级比较"></a>隐式绑定与new绑定优先级比较</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(<span class="number">2</span>);</span><br><span class="line">console.<span class="built_in">log</span>(obj1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2, <span class="number">3</span> ); </span><br><span class="line">console.<span class="built_in">log</span>(obj2.a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">var bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>);</span><br><span class="line">console.<span class="built_in">log</span>(obj1.a); <span class="comment">// 2</span></span><br><span class="line">console.<span class="built_in">log</span>(bar.a); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>得出结论new绑定优先级比隐式绑定优先级高。</p><h3 id="new与显式绑定"><a href="#new与显式绑定" class="headerlink" title="new与显式绑定"></a>new与显式绑定</h3><p>直接说结果，new绑定优先级更高。</p><p><strong>new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.函数是否在new中调用？如果是的话this绑定的是新创建的对象。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var bar = <span class="keyword">new</span> foo();</span><br></pre></td></tr></table></figure></p><p>2.函数是否通过call、apply、(显式绑定)或者硬绑定调用？如果是的话，this绑定的是括号里的指定对象。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var bar = foo.call(obj);</span><br></pre></td></tr></table></figure></p><p>3.函数是否在某个上下文中调用(隐式绑定)？如果是的话，this绑定的是那个上下文对象。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var bar = obj.foo();</span><br></pre></td></tr></table></figure></p><p>4.如果都不是，那么就是默认绑定。在严格模式下，就绑定到undefined，否则绑定到全局对象。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><ul><li>凡事都有例外，这里说几个特殊的情况<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = <span class="number">2</span>;</span><br><span class="line">foo.call(null); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><p>如果把null或者undefined作为this的绑定对象传入call、apply或者bind中，这些值在调用时会被忽略，实际应用的是默认规则，绑定全局对象。</p><ul><li>那么一般什么情况下会传入null呢？<br>一种非常常见的做法是使用apply来“展开”一个数组，并当做参数传入一个函数。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(a,b)</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组"展开"</span></span><br><span class="line">foo.apply( null, [<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bind进行柯里化</span></span><br><span class="line">var bar = foo.bind( null, <span class="number">2</span>);</span><br><span class="line">bar(<span class="number">3</span>); <span class="comment">// a:2,b:3</span></span><br></pre></td></tr></table></figure></li></ul><p>传入null其实并不是最优解，这种方式可能会导致一些bug，因此我们可以使用空对象，将this绑定到它上面。我们一般用<strong>Object.create(null)</strong>来创建一个空对象。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(a,b)</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">var emptyObj = Object.create(null);</span><br><span class="line">foo.apply( emptyObj, [<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bind进行柯里化</span></span><br><span class="line">var bar = foo.bind( emptyObj, <span class="number">2</span>);</span><br><span class="line">bar(<span class="number">3</span>); <span class="comment">// a:2,b:3</span></span><br></pre></td></tr></table></figure></p><ul><li>在最新的es6中有了新的展开符号三个点: …[1,2,3]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于this关键字&quot;&gt;&lt;a href=&quot;#关于this关键字&quot; class=&quot;headerlink&quot; title=&quot;关于this关键字&quot;&gt;&lt;/a&gt;关于this关键字&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;每个函数的this是在调用时被绑定的，并非是在编写时绑定，它的上下文取决
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="this" scheme="http://localhost:4000/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>js数组的拷贝与清空</title>
    <link href="http://localhost:4000/2019/05/18/js%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B8%85%E7%A9%BA/"/>
    <id>http://localhost:4000/2019/05/18/js%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B8%85%E7%A9%BA/</id>
    <published>2019-05-18T05:03:54.000Z</published>
    <updated>2019-06-08T05:55:00.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>昨天写代码的时候，有一个需求是需要一个临时的数组b暂时存储数据，在这个数组中进行如去重、筛选等操作，之后再将结果倒入渲染页面的那个数组a里，在将数据倒入渲染数组a里后，临时数组b要清空。</p><h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><ul><li>我先用的方法是写b.length = 0,结果很奇怪,看下面的例子:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">var b = a;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(b); <span class="comment">// 输出[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟对b进行操作</span></span><br><span class="line">b= b.concat([<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// 输出[1,2,3,4,5,1,2]</span></span><br><span class="line"></span><br><span class="line">a = b; <span class="comment">// 将进行操作后的b数组拷贝给a数组</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(a); <span class="comment">// 输出[1,2,3,4,5,1,2]</span></span><br><span class="line"></span><br><span class="line">b.length = <span class="number">0</span>; <span class="comment">// 将b数组长度设为0 清空b数组 </span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(b); <span class="comment">// 这时候b输出为 []</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(a); <span class="comment">// a数组也输出[] a也被清空了！</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>这里的我设置b.length=0后，a数组也被清空了!</strong></p><ul><li>我马上又用了另一个方法清空数组,b = [],看下面例子:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">var b = a;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(b);</span><br><span class="line"></span><br><span class="line">b= b.concat([<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(a); <span class="comment">// 输出[1,2,3,4,5,1,2]</span></span><br><span class="line"></span><br><span class="line">b= []; <span class="comment">// 设置为一个空数组 其实这种方法只是换了个引用，并没有真正的清空，原数据还在内存当中，这也是问题所在</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(b); <span class="comment">// b输出为 []</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(a); <span class="comment">// a输出为[1,2,3,4,5,1,2],没有被清空！</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>这里用这种写法就正常了！</strong></p><h2 id="寻找原因"><a href="#寻找原因" class="headerlink" title="寻找原因"></a>寻找原因</h2><p>这里要涉及到<strong>深浅拷贝</strong>的问题,下面说一下深拷贝和浅拷贝的定义</p><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>在说明前先理解一下栈内存与堆内存，这也是深浅拷贝的背景</p><h4 id="拓展背景"><a href="#拓展背景" class="headerlink" title="拓展背景"></a>拓展背景</h4><p>Javascript有五种基本数据类型（也就是简单数据类型），它们分别是：Undefined，Null，Boolean，Number和String。还含有一种复杂的数据类型（也叫引用类型），就是对象，注意Undefined和Null的区别，Undefined类型和Null类型只有一个值，分别就是undefined和null。</p><ul><li>对于基本数据类型<br>他们的值在内存中占据着固定大小的空间，并被保存在<strong>栈内存</strong>中。当一个变量向另一个变量复制基本类型的值，会创建这个值的<strong>副本</strong>，并且我们不能给基本数据类型的值添加属性<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x = <span class="number">1</span>;</span><br><span class="line">var y = x;</span><br><span class="line">x.name = 'zhou';</span><br><span class="line">console.<span class="built_in">log</span>(y); <span class="comment">//1</span></span><br><span class="line">console.<span class="built_in">log</span>(x.name); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li></ul><p>上面的x是基本数据类型(Number)， y是x的一个副本，它们两者都占有不同位置但相等的内存空间，只是它们的值相等，若改变其中一方，另一方<strong>不会</strong>随之改变。</p><ul><li>对于引用类型<br>复杂的数据类型即是引用类型，它的值是对象，保存在<strong>堆内存</strong>中，包含引用类型值的变量实际上包含的不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是<strong>指针地址</strong>而已，因此两个变量最终都指向<strong>同一个</strong>对象<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: 'zhou',</span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">var newPerson = person;</span><br><span class="line">newPerson.name = 'qi';</span><br><span class="line">console.<span class="built_in">log</span>(person); <span class="comment">// &#123;name: "qi", age: 22&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>上面可以看到新建的对象newPerson等于person对象后，改变其中name的值，原始person对象的name也改变了，说明他们都指向同一个指针</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝的例子其实最前面我写了，就是a数组与b数组，下面在写个简单的例子<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var <span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">var newList = <span class="built_in">list</span>;</span><br><span class="line">newList[1] = 'hello';</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">list</span>); <span class="comment">// [1,'hello',3,4]</span></span><br><span class="line">console.<span class="built_in">log</span>(newList);<span class="comment">// [1,'hello',3,4]</span></span><br></pre></td></tr></table></figure></p><p>这种情况下改变两个中任意的一个，都会导致另一个也改变</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>我们可以使用slice()与concat()方法实现深拷贝，前者可以接受两个参数，开始索引与结束索引，也可以只输入一个参数，即开始到最后，即可拷贝数组，后者即是合并数组，但也可以像下面这样用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">var arrCopy = arr.concat();</span><br><span class="line">arrCopy[0] = 'test'</span><br><span class="line">console.<span class="built_in">log</span>(arr); <span class="comment">// ["a", "b", "c"] 因为是深拷贝arr数组没有被改变</span></span><br><span class="line">console.<span class="built_in">log</span>(arrCopy); <span class="comment">// ["test", "b", "c"]</span></span><br></pre></td></tr></table></figure></p><h3 id="数组清空的方法"><a href="#数组清空的方法" class="headerlink" title="数组清空的方法"></a>数组清空的方法</h3><h4 id="1-slice方法"><a href="#1-slice方法" class="headerlink" title="1.slice方法:"></a>1.slice方法:</h4><p>slice方法接受开始与结束索引，并后返回一个新数组<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">a = a.slice(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">console.<span class="built_in">log</span>(a); <span class="comment">// 输出[]</span></span><br></pre></td></tr></table></figure></p><h4 id="2-数组长度大法"><a href="#2-数组长度大法" class="headerlink" title="2.数组长度大法:"></a>2.数组长度大法:</h4><p>在JavaScript数组是可读写的,因此直接设置数组为0即可<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var b = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">b.length = <span class="number">0</span>;</span><br><span class="line">console.<span class="built_in">log</span>(b); <span class="comment">// 输出[]</span></span><br></pre></td></tr></table></figure></p><h4 id="3-设置为空数组"><a href="#3-设置为空数组" class="headerlink" title="3.设置为空数组:"></a>3.设置为空数组:</h4><p>实际上是更改了数组的引用地址，原数据还在<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var c = [<span class="string">'你'</span>,<span class="string">'好'</span>,<span class="string">'吗'</span>];</span><br><span class="line">c = [];</span><br><span class="line">console.<span class="built_in">log</span>(c); <span class="comment">// 输出[]</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以说我最开始遇到的问题就明了了:</p><ul><li>设置长度为0或是通过slice方法设置长度为0,会清除那个引用地址的值，而让一个数组等于[]其实只是让这个数组的引用地址改变了，之前的引用还在那儿。</li><li>我直接让a = b,这样就是浅拷贝，因此才会出现两个数组指向同一个引用地址，其中一个改变，另一个也跟着改。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h2&gt;&lt;p&gt;昨天写代码的时候，有一个需求是需要一个临时的数组b暂时存储数据，在这个数组中进行如去重、筛选等操作，之后再将结果倒入渲染页面
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数组" scheme="http://localhost:4000/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="深浅拷贝" scheme="http://localhost:4000/tags/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="数组清空" scheme="http://localhost:4000/tags/%E6%95%B0%E7%BB%84%E6%B8%85%E7%A9%BA/"/>
    
  </entry>
  
  <entry>
    <title>历史级的季后赛</title>
    <link href="http://localhost:4000/2019/05/04/%E5%8E%86%E5%8F%B2%E7%BA%A7%E7%9A%84%E5%AD%A3%E5%90%8E%E8%B5%9B/"/>
    <id>http://localhost:4000/2019/05/04/%E5%8E%86%E5%8F%B2%E7%BA%A7%E7%9A%84%E5%AD%A3%E5%90%8E%E8%B5%9B/</id>
    <published>2019-05-04T07:10:26.000Z</published>
    <updated>2019-05-04T07:37:41.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="史诗级的季后赛"><a href="#史诗级的季后赛" class="headerlink" title="史诗级的季后赛"></a>史诗级的季后赛</h2><p>今天见证了一场四加时的NBA季后赛，开拓者VS掘金这场史诗级的季后赛。利指导今天手感不算好，不过今天CJ是真的厉害，太横了。不过我是没想到最后接管比赛的居然是胡德！这个之前在骑士混得这么差的胡德居然在最后时刻变成了爹！<br>作为利指导的粉丝，看到开拓者能赢球还是很高兴的，不过掘金这场也打得很顽强，真的是一场非常精彩的季后赛对决，要知道上一次季后赛四加时实在六十多年前了！当真是有生之年啊233333</p><h2 id="惆怅"><a href="#惆怅" class="headerlink" title="惆怅"></a>惆怅</h2><p>虽说见证了这么好看的比赛，但是想想明天要上班了，落差有点大，本来想继续啃啃《你不知道的JavaScript》(上卷)，但是又看不进去。马上进社会了，不过作为程序员还是得不停的学，自己的水平还很低，还得加把劲那！</p><h2 id="鸡你太美"><a href="#鸡你太美" class="headerlink" title="鸡你太美"></a>鸡你太美</h2><p><img src="/BeCoderQ.github.io/2019/05/04/历史级的季后赛/cxknmsl.jpg" alt="鸡你太美"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;史诗级的季后赛&quot;&gt;&lt;a href=&quot;#史诗级的季后赛&quot; class=&quot;headerlink&quot; title=&quot;史诗级的季后赛&quot;&gt;&lt;/a&gt;史诗级的季后赛&lt;/h2&gt;&lt;p&gt;今天见证了一场四加时的NBA季后赛，开拓者VS掘金这场史诗级的季后赛。利指导今天手感不算好，不过今天
      
    
    </summary>
    
    
      <category term="生活" scheme="http://localhost:4000/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="NBA" scheme="http://localhost:4000/tags/NBA/"/>
    
      <category term="篮球" scheme="http://localhost:4000/tags/%E7%AF%AE%E7%90%83/"/>
    
  </entry>
  
</feed>

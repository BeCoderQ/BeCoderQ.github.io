<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>ChowMe</title>
  <icon>https://www.gravatar.com/avatar/a73d30b0d26382bb941766ce55d0904e</icon>
  <subtitle>Hello,World</subtitle>
  <link href="/BeCoderQ.github.io/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2021-09-14T07:51:24.566Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>Chow</name>
    <email>zhouqm814@sina.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode算法之旅---二叉树</title>
    <link href="http://localhost:4000/2021/09/09/leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://localhost:4000/2021/09/09/leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-09-09T07:52:26.000Z</published>
    <updated>2021-09-14T07:51:24.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>这是我第一次接触二叉树的算法题，因此先对二叉树的基本概念做一些笔记</p><p><img src="/BeCoderQ.github.io/2021/09/09/leetcode算法之旅-二叉树/binary-tree-base.png" alt="图"></p><ul><li>根节点：二叉树最顶层节点</li><li>分支节点：除了根节点以外且拥有叶子节点</li><li>叶子节点，非根节点且除自身外没有其他子节点</li></ul><p>二叉树的定义：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TreeNode &#123;</span><br><span class="line">  left!: TreeNode | <span class="literal">null</span>;</span><br><span class="line">right!: TreeNode | <span class="literal">null</span>;</span><br><span class="line">val: unknown;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params">left: TreeNode, right: TreeNode, val: unknown</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的三个数学性质"><a href="#二叉树的三个数学性质" class="headerlink" title="二叉树的三个数学性质"></a>二叉树的三个数学性质</h2><ol><li>在二叉树的第i层上，至多有2^i - 1个节点，i=1时，只有一个即根节点。</li><li>深度为k的二叉树至多有2^k - 1个节点。</li><li>对任何一棵二叉树T，如果总结点数为n0，度为2(子树数目为2)的节点数为n2,则n0=n2+1</li></ol><h2 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h2><p>二叉树分为完全二叉树(complete binary tree)和满二叉树(full binary tree)。</p><ul><li>满二叉树：一棵深度为k且有2^k - 1个节点的二叉树称为满二叉树。</li><li>完全二叉树：完全二叉树是指最后一层左边是满的，右边可能满也可能不满，然后其余层都是满的二叉树称为完全二叉树(满二叉树也是一种完全二叉树)。</li></ul><p><img src="/BeCoderQ.github.io/2021/09/09/leetcode算法之旅-二叉树/type.png" alt="图"></p><h2 id="二叉树的几种遍历方式"><a href="#二叉树的几种遍历方式" class="headerlink" title="二叉树的几种遍历方式"></a>二叉树的几种遍历方式</h2><p>如下图的一棵二叉树：</p><p><img src="/BeCoderQ.github.io/2021/09/09/leetcode算法之旅-二叉树/order.png" alt="图"></p><ul><li>先序遍历：1 2 4 6 7 8 3 5</li><li>中序遍历：4 7 6 8 2 1 3 5</li><li>后序遍历：7 8 6 4 2 5 3 1</li></ul><p><img src="/BeCoderQ.github.io/2021/09/09/leetcode算法之旅-二叉树/order-detail.png" alt="图"></p><h2 id="例题-相同的二叉树"><a href="#例题-相同的二叉树" class="headerlink" title="例题-相同的二叉树"></a>例题-相同的二叉树</h2><p><img src="/BeCoderQ.github.io/2021/09/09/leetcode算法之旅-二叉树/question1.png" alt="图"></p><p>二叉树的问题不外乎就是递归、迭代，这里我用递归方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; p</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; q</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isSame = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">(<span class="params">p1, q1</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 两者有一者可能为空就判断是否相等，实际其实是判断是否有一者为null，不等返回false</span></span><br><span class="line">        <span class="keyword">if</span>(!p1 || !q1) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 !== q1) isSame = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span>(p1.val !== q1.val) isSame = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里开始递归，其实就是左右互相对比，而递归结束的条件就是上面的第一个if</span></span><br><span class="line">        fn(p1.left, q1.left);</span><br><span class="line">        fn(p1.right, q1.right);</span><br><span class="line">    &#125;</span><br><span class="line">    fn(p, q);</span><br><span class="line">    <span class="keyword">return</span> isSame;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一定不是最佳解法，不过这是我想出来的第一个解法，就直接用它了。</p><h2 id="例题-对称二叉树"><a href="#例题-对称二叉树" class="headerlink" title="例题-对称二叉树"></a>例题-对称二叉树</h2><p><img src="/BeCoderQ.github.io/2021/09/09/leetcode算法之旅-二叉树/question2.png" alt="图"></p><p>这题我认为很典型，是一道入门的好题，我用了两种方法解题，一种是递归，另一种是迭代。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/** 递归法 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!root.left || !root.right) <span class="keyword">return</span> !root.left &amp;&amp; !root.right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">(<span class="params">l, r</span>)=&gt;</span> (!l || !r) ? (!l &amp;&amp; !r) : l.val === r.val  &amp;&amp; fn(l.left, r.right) &amp;&amp; fn(l.right, r.left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn(root.left, root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题有一个热评写得非常好，我直接复制过来：</p><blockquote><p>递归的难点在于：找到可以递归的点 为什么很多人觉得递归一看就会，一写就废。 或者说是自己写无法写出来，关键就是你对递归理解的深不深。</p><p>对于此题： 递归的点怎么找？从拿到题的第一时间开始，思路如下：</p><p>1.怎么判断一棵树是不是对称二叉树？ 答案：如果所给根节点，为空，那么是对称。如果不为空的话，当他的左子树与右子树对称时，他对称</p><p>2.那么怎么知道左子树与右子树对不对称呢？在这我直接叫为左树和右树 答案：如果左树的左孩子与右树的右孩子对称，左树的右孩子与右树的左孩子对称，那么这个左树和右树就对称。</p><p>仔细读这句话，是不是有点绕？怎么感觉有一个功能A我想实现，但我去实现A的时候又要用到A实现后的功能呢？</p><p>当你思考到这里的时候，递归点已经出现了： 递归点：我在尝试判断左树与右树对称的条件时，发现其跟两树的孩子的对称情况有关系。</p><p>想到这里，你不必有太多疑问，上手去按思路写代码，函数A（左树，右树）功能是返回是否对称</p><p>def 函数A（左树，右树）： 左树节点值等于右树节点值 且 函数A（左树的左子树，右树的右子树），函数A（左树的右子树，右树的左子树）均为真 才返回真</p><p>实现完毕。。。</p><p>写着写着。。。你就发现你写出来了。。。。。。</p></blockquote><ul><li>这里第一个if是判断，如果左节点和右节点有一个为空另一个不为空，那么就返回false</li><li>递归函数里面，我简写成了三元表达式，实际第一个判断和外面的if是一样的，后面其实就是利用递归开辟的一个栈来进行与(&amp;)操作。</li></ul><p>看了评论后递归很好理解。</p><h3 id="迭代（栈）"><a href="#迭代（栈）" class="headerlink" title="迭代（栈）"></a>迭代（栈）</h3><p>迭代的话，使用队列或者栈其实都是一样的，这里我用的是栈（FILO）。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/** 栈迭代法 */</span></span><br><span class="line">    <span class="keyword">if</span>(!root.left || !root.right) <span class="keyword">return</span> !root.left &amp;&amp; !root.right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stack = [root.left, root.right];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> r = stack.pop(), l = stack.pop();</span><br><span class="line">        <span class="comment">// 排除两者皆null的同值情况</span></span><br><span class="line">        <span class="keyword">if</span>(!l &amp;&amp; !r) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!l || !r || l.val !== r.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右子树对称入栈</span></span><br><span class="line">        stack.push(l.left);</span><br><span class="line">        stack.push(r.right);</span><br><span class="line">        stack.push(l.right);</span><br><span class="line">        stack.push(r.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>全程维护一个stack数组栈，因为判断对称本质就是判断左树左节点和右树右节点、左树右节点和右树左节点是否相同，那么我们就可以按顺序入栈，并在每次开始时拿到出栈的值进行比对，迭代的结束条件即是空栈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;p&gt;这是我第一次接触二叉树的算法题，因此先对二叉树的基本概念做一些笔记&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/BeCoderQ.githu
      
    
    </summary>
    
    
      <category term="算法" scheme="http://localhost:4000/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://localhost:4000/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://localhost:4000/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>业务中的装饰器图（码）鉴</title>
    <link href="http://localhost:4000/2021/08/27/%E5%AE%9E%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9B%BE%EF%BC%88%E7%A0%81%EF%BC%89%E9%89%B4/"/>
    <id>http://localhost:4000/2021/08/27/%E5%AE%9E%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9B%BE%EF%BC%88%E7%A0%81%EF%BC%89%E9%89%B4/</id>
    <published>2021-08-27T01:06:11.000Z</published>
    <updated>2021-09-09T07:49:06.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h2><p>不管是在JavaScript中还是TypeScript中使用装饰器，都需要将js/tsconfig.json文件中的<code>experimentalDecorators</code>属性设置为true: </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有一点，<strong>装饰器只能在类的内部或直接装饰类的时候使用</strong>，在例如Vue2的钩子写法或Vue3的setUp函数内是会报错的！</p><h2 id="我的开发环境"><a href="#我的开发环境" class="headerlink" title="我的开发环境"></a>我的开发环境</h2><p>最近的项目开发环境都是<strong>Vue2.6 + TypeScript + Vue-Property-Decorator</strong>，这套组合写下来有点React更新函数式写法之前的味道，写着还是挺顺手的，基础写法如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Vue &#125; <span class="keyword">from</span> <span class="string">"vue-property-decorator"</span>;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Living <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Vue-Property-Decorator</strong>核心用了<strong>Vue-Class-Component</strong>这个库，后者抛出了<code>createDecorator</code>这个函数，有兴趣的朋友可以看看源码。<strong>Vue-Property-Decorator</strong>在很多地方利用了Vue的Mixins特性，不过这些在我们做业务使用的时候无需关心，因为这是它的内部实现。但如果你有一些想法，想做一些骚操作，那你可能就要去了解一下了。</p><h2 id="异步请求的loading装饰器"><a href="#异步请求的loading装饰器" class="headerlink" title="异步请求的loading装饰器"></a>异步请求的loading装饰器</h2><p>正片开始前说两句，对于<strong>防抖、节流</strong>这类装饰器我就不写了，因为网上的例子很多，我就说一些在我的业务开发中自己写的装饰器。</p><p>loading装饰器用于装饰单个的请求函数，用于在请求前显示加载中之类的效果，请求拿到结果后将效果去掉，代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 请求加载动画</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; loadingKey 加载的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onLoading</span>(<span class="params">loadingKey: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onLoading</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>): <span class="title">any</span></span>;</span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onLoading</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> loadingKey = (isString(args[<span class="number">0</span>]) &amp;&amp; args[<span class="number">0</span>]); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">const</span> loadingFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">     _target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">     _property: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">     desciptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">   </span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 原函数指针</span></span><br><span class="line">     <span class="keyword">const</span> targetFn = desciptor.value;</span><br><span class="line">     desciptor.value = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>[loadingKey|| <span class="string">"loading"</span>] = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">await</span> targetFn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>[loadingKey || <span class="string">"loading"</span>] = <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> args[<span class="number">0</span>] <span class="keyword">instanceof</span> Vue ? </span><br><span class="line">     loadingFn.apply(<span class="literal">null</span>, [...args <span class="keyword">as</span> [<span class="built_in">any</span>, <span class="built_in">string</span>, PropertyDescriptor]]) : </span><br><span class="line">     loadingFn</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>它的工作原理就是在执行原函数前拿到上下文中控制加载动画显示的变量（默认为loading）并将其设置为true，然后执行原函数。这里为了兼容带参柯理化和无参写法最了参数上的判断。具体使用如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Home <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  loading = <span class="literal">false</span>;</span><br><span class="line">  <span class="meta">@onLoading</span></span><br><span class="line">  <span class="keyword">async</span> getAdviceList() &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> yourRequest();</span><br><span class="line">    <span class="comment">// 其他操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上代码被装饰为了：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Home <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  loading = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">async</span> getAdviceList() &#123;</span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> yourRequest();</span><br><span class="line">    <span class="comment">// 其他操作</span></span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到对装饰器来说，函数自己是个实体，你想让装饰器的一些操作在函数内部执行的话就只能通过入参回调的方式，但这样会破环函数的结构，并且让后面接手的老哥非常费解。</p><h2 id="类属性绑定到Vuex装饰器"><a href="#类属性绑定到Vuex装饰器" class="headerlink" title="类属性绑定到Vuex装饰器"></a>类属性绑定到Vuex装饰器</h2><p>我目前接手的几个项目请求的封装有点与众不同：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> LiveRequest &#123;</span><br><span class="line">  <span class="comment">// 这些复用率高的vuex属性他们都把它放到了一个getter里 还挺多</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">get</span> appId() &#123;</span><br><span class="line">    <span class="keyword">return</span> store.state.appId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">get</span> token() &#123;</span><br><span class="line">    <span class="keyword">return</span> store.state.token;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getDetail(infoClassifyId: <span class="built_in">string</span>): <span class="built_in">Promise</span>&lt;IGetDetail&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">`/live/detail/<span class="subst">$&#123;infoClassifyId&#125;</span>.html`</span>, &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        token: <span class="keyword">this</span>.token,</span><br><span class="line">        appId: <span class="keyword">this</span>.appId</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> liveReq = <span class="keyword">new</span> LiveRequest;</span><br></pre></td></tr></table></figure><p>所有模块的请求都是在一个类里面，并且因为vuex的一些属性复用率高，就写在getter里，方便后续直接this.xxx调用。因为历史遗留问题，这块不能随便改。其实倒也没什么问题，就是get xxx这样的写着太麻烦了，于是我以简化getter写法获取vuex属性为目的，写了一个装饰器：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @param options </span></span><br><span class="line"><span class="comment">  * @description 为非Vue文件类属性绑定state值，修改值后也可以同步到vuex，但不建议修改</span></span><br><span class="line"><span class="comment">  * @attention 属性装饰器无法直接修改值，修改的值会在对象原型上(__proto__)，</span></span><br><span class="line"><span class="comment">  * 但可以利用原型链的特点，在类中定义undefined属性。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">const</span> bindQueue: <span class="built_in">string</span>[] = [];</span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindState</span>(<span class="params">options: &#123; stateKey?: <span class="built_in">string</span>; &#125;</span>): <span class="title">any</span></span>;</span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindState</span>(<span class="params">target: <span class="built_in">any</span>, attr: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindState</span>(<span class="params">options: &#123; stateKey?: <span class="built_in">string</span>; &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 找到原型的倒数第二层，即Object层，并用重写的访问器将其覆盖掉</span></span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> 尝试引入链表的模式 避免属性覆盖</span></span><br><span class="line">   <span class="keyword">const</span> findObjectProto = <span class="function">(<span class="params">object: <span class="built_in">Object</span>, target: <span class="built_in">Object</span></span>)=&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(object);</span><br><span class="line">     <span class="keyword">if</span>(proto.<span class="keyword">constructor</span>.name === "Object") &#123;</span><br><span class="line">       <span class="built_in">Object</span>.setPrototypeOf(object, target);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       findObjectProto(proto, target);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 逻辑部分</span></span><br><span class="line">   <span class="keyword">const</span> SyncState = <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, attr: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 同样是为了兼容传参和不传参的写法，这里和后面都有判断</span></span><br><span class="line">     <span class="keyword">const</span> &#123; stateKey = attr &#125; = options.<span class="keyword">constructor</span>?.name !== "Object" ? </span><br><span class="line">       &#123; stateKey: attr &#125; : </span><br><span class="line">       options;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 如果传递了state的Key，要判断state中是否有这个属性</span></span><br><span class="line">     <span class="keyword">if</span>(stateKey <span class="keyword">in</span> store.state) &#123;</span><br><span class="line">       <span class="comment">// bindQueue为当前绑定的属性的队列，用于拼装传入Object.defineProperties的对象</span></span><br><span class="line">       !bindQueue.includes(stateKey) &amp;&amp; bindQueue.push(stateKey);</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">const</span> pureObject = <span class="built_in">Object</span>.create(&#123;&#125;), </span><br><span class="line">         descriptorMap: &#123; [k: <span class="built_in">string</span>]: PropertyDescriptor  &#125; = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 根据队列，拼装重写的访问器map</span></span><br><span class="line">       bindQueue.forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</span><br><span class="line">         descriptorMap[key] = &#123;</span><br><span class="line">           <span class="keyword">get</span>() &#123;</span><br><span class="line">             <span class="comment">// console.log(`来自$&#123;key&#125;属性的访问器：`, store.state);</span></span><br><span class="line">             <span class="keyword">return</span> store.state[key <span class="keyword">as</span> keyof <span class="keyword">typeof</span> store.state];</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="comment">// <span class="doctag">TODO:</span> 为保证数据的单一流向，是否要去掉可修改的功能？</span></span><br><span class="line">           <span class="keyword">set</span>(value: unknown) &#123;</span><br><span class="line">             store.commit(<span class="string">"SET_STATE"</span>, &#123;</span><br><span class="line">               [stateKey]: value</span><br><span class="line">             &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;);  </span><br><span class="line">       <span class="keyword">const</span> getter = <span class="built_in">Object</span>.defineProperties(pureObject, descriptorMap);</span><br><span class="line">       findObjectProto(target, getter);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">`state中没有键为<span class="subst">$&#123;stateKey&#125;</span>的属性！`</span>);</span><br><span class="line">     &#125; </span><br><span class="line">   &#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">const</span> args = [...arguments] <span class="keyword">as</span> [<span class="built_in">any</span>, <span class="built_in">string</span>];</span><br><span class="line"> <span class="comment">// 同样，这里根据传入参数判断返回类型</span></span><br><span class="line">   <span class="keyword">return</span> options.<span class="keyword">constructor</span>?.name !== "Object" ? SyncState.apply(<span class="params"><span class="literal">null</span>, [...args]</span>) : SyncState;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这是一个属性装饰器，接受到的属性只有两个：target即所在类原型，attr即属性名。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样改值只是拿到了地址上存储的值，在store更改后是无法同步的</span></span><br><span class="line">target[attr] = store.state[attr];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此上面我用了访问器 也就是下面这段</span></span><br><span class="line"> bindQueue.forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</span><br><span class="line">   descriptorMap[key] = &#123;</span><br><span class="line">     <span class="keyword">get</span>() &#123;</span><br><span class="line">       <span class="keyword">return</span> store.state[key <span class="keyword">as</span> keyof <span class="keyword">typeof</span> store.state];</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="keyword">set</span>(value: unknown) &#123;</span><br><span class="line">       store.commit(<span class="string">"SET_STATE"</span>, &#123;</span><br><span class="line">         [stateKey]: value</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>有一点需要特别注意，<strong>这里的属性装饰器拿到的第一个参数target并不是类本身（<code>function YourClass</code>），也不是实例化后的类（<code>new YourClass</code>），只是单纯的类的原型（<code>YourClass.prototype</code>）</strong>，这就要牵引出另一个问题，如果你也是用的es6语法糖class声明类，<strong>那么你在class内声明的属性不会在原型链上，它们只在你实例化类的时候存在。</strong></p><p>上面说了一堆，其实就是说如果你要在属性装饰器中改变属性的值，本质上是并没有修改的，因为类似上述操作只是往这个类的原型上添加了一个属性并赋值而已。</p><p>所以我这个装饰器的实现实际只是覆盖顶层原型。属性装饰器其中还有一些怪异的行为，例如类的原型的原型（prototype.<em>proto</em>）被覆盖后再实例化类（new），覆盖的同名属性会丢失（实际这个装饰器也是利用了这个不知道算不算bug的特性实现的）。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用就比最开始方便多了:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> LiveRequest &#123;</span><br><span class="line">  <span class="meta">@bindState</span></span><br><span class="line">  token!: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@bindState</span></span><br><span class="line">  appId!: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  getDetail(infoClassifyId: <span class="built_in">string</span>): <span class="built_in">Promise</span>&lt;IGetDetail&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">`/live/detail/<span class="subst">$&#123;infoClassifyId&#125;</span>.html`</span>, &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        token: <span class="keyword">this</span>.token,</span><br><span class="line">        appId: <span class="keyword">this</span>.appId</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带延迟的toast装饰器"><a href="#带延迟的toast装饰器" class="headerlink" title="带延迟的toast装饰器"></a>带延迟的toast装饰器</h2><p>这个和上面的loading装饰器其实差不多，区别是在接口响应超过一定时限才显示，代码很简单：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰接口调用函数，在指定时间未返回结果时弹出loading效果</span></span><br><span class="line"><span class="comment"> * @param options Toast选项以及等待时间和@property条件执行回调或布尔值</span></span><br><span class="line"><span class="comment"> * @returns void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toastWithDelay</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: ToastOptions &amp; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    wait?: <span class="built_in">number</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    condition?: <span class="built_in">boolean</span> | ((...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">boolean</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    _target: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">    _key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line">    descriptor.value = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args: unknown[]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/** 这一段是特殊的业务需求 */</span></span><br><span class="line">        <span class="keyword">let</span> flag: <span class="built_in">boolean</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.condition === <span class="string">"function"</span>) &#123;</span><br><span class="line">          flag = options.condition(...args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options.condition === <span class="string">"boolean"</span>) &#123;</span><br><span class="line">          flag = options.condition;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 这一段是特殊的业务需求 */</span></span><br><span class="line">        flag &amp;&amp; Toast.loading(options);</span><br><span class="line">      &#125;, options.wait || <span class="number">1500</span>);</span><br><span class="line">      <span class="keyword">await</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      <span class="comment">// 清除定时器</span></span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      <span class="comment">// 清除Toast</span></span><br><span class="line">      Toast.clear();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ui库是vant，因此这里用的vant的Toast，因为业务场景需要，所以加了个condition参数，用来限定在特定场景才显示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰器让代码更简洁、优雅，但也有一个问题，现在流行函数式编程，在函数式编程中装饰器就没有用武之地了。取舍的话，这是仁者见仁，智者见智的事情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用装饰器&quot;&gt;&lt;a href=&quot;#使用装饰器&quot; class=&quot;headerlink&quot; title=&quot;使用装饰器&quot;&gt;&lt;/a&gt;使用装饰器&lt;/h2&gt;&lt;p&gt;不管是在JavaScript中还是TypeScript中使用装饰器，都需要将js/tsconfig.json文件中的
      
    
    </summary>
    
    
      <category term="记录" scheme="http://localhost:4000/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="typescript" scheme="http://localhost:4000/tags/typescript/"/>
    
      <category term="装饰器" scheme="http://localhost:4000/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>实现Vuex精准的类型推断Beta版</title>
    <link href="http://localhost:4000/2021/07/19/%E5%AE%9E%E7%8E%B0Vuex%E6%9C%80%E7%B2%BE%E5%87%86%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%ADBeta%E7%89%88/"/>
    <id>http://localhost:4000/2021/07/19/%E5%AE%9E%E7%8E%B0Vuex%E6%9C%80%E7%B2%BE%E5%87%86%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%ADBeta%E7%89%88/</id>
    <published>2021-07-19T06:15:54.000Z</published>
    <updated>2021-07-19T09:11:51.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="和Vuex耗上了"><a href="#和Vuex耗上了" class="headerlink" title="和Vuex耗上了"></a>和Vuex耗上了</h1><p>上一次我也对Vuex进行了推断，但结果很难让人满意: <a href="http://zyyzg.cn/2021/06/02/%E8%AE%B0%E4%B8%80%E6%AC%A1Vuex%E4%B8%ADcommit%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C%E7%9A%84%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">http://zyyzg.cn/2021/06/02/%E8%AE%B0%E4%B8%80%E6%AC%A1Vuex%E4%B8%ADcommit%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C%E7%9A%84%E8%BF%87%E7%A8%8B/</a></p><p>于是这次认真思考了一下，有了一个新的方案，复杂的映射后（我觉得过程写得很麻烦，毕竟水平有限）能拿到勉强满意的结果了：</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><img src="/BeCoderQ.github.io/2021/07/19/实现Vuex最精准的类型推断Beta版/state.gif" alt="图"></p><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p><img src="/BeCoderQ.github.io/2021/07/19/实现Vuex最精准的类型推断Beta版/commit.gif" alt="图"></p><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p><img src="/BeCoderQ.github.io/2021/07/19/实现Vuex最精准的类型推断Beta版/dispatch.gif" alt="图"></p><p>可以看到state能够拿到modules内的，commit和dispatch能拿到命名空间key，并且第二个参数(payload)的类型也能够与之对应。</p><h3 id="store-index-ts文件"><a href="#store-index-ts文件" class="headerlink" title="store/index.ts文件"></a>store/index.ts文件</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex, &#123; Commit &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isOwnKey, NonNeverState, GetState, GetMutationKeyParamMap, GetActionKeyParamMap &#125; <span class="keyword">from</span> <span class="string">"vuex-with-type"</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  token: <span class="string">""</span>,</span><br><span class="line">  openId: <span class="string">""</span>,</span><br><span class="line">  name: <span class="string">""</span>,</span><br><span class="line">  appId: <span class="string">"1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** modules测试 */</span></span><br><span class="line"><span class="keyword">const</span> modOneState = &#123;</span><br><span class="line">  name: <span class="string">"z"</span>,</span><br><span class="line">  age: <span class="number">24</span>,</span><br><span class="line">  job: <span class="string">'frontier-engineer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modOneMutation = &#123;</span><br><span class="line">  SET_STATE(state: <span class="keyword">typeof</span> modOneState, obj: Partial&lt;<span class="keyword">typeof</span> modOneState&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isOwnKey(key, obj)) &#123;</span><br><span class="line">        state[key] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  SET_NAME(state: &#123; name: <span class="built_in">string</span> &#125;, v: <span class="built_in">string</span>) &#123;</span><br><span class="line">    state.name = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modTwoState = &#123;</span><br><span class="line">  name: <span class="string">"q"</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  job: <span class="string">'back-end-engineer'</span>,</span><br><span class="line">  <span class="number">996</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modTwoMutation = &#123;</span><br><span class="line">  SET_STATE(state: <span class="keyword">typeof</span> modTwoState, obj: Partial&lt;<span class="keyword">typeof</span> modTwoState&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isOwnKey(key, obj)) &#123;</span><br><span class="line">        state[key] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  SET_AGE(state: &#123; age: <span class="built_in">number</span> &#125;, v: <span class="built_in">number</span>) &#123;</span><br><span class="line">    state.age = v;</span><br><span class="line">  &#125;,</span><br><span class="line">  SET_996(state: &#123; <span class="number">996</span>: <span class="built_in">boolean</span> &#125;, v: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">    state[<span class="number">996</span>] = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将vuex store独立出来</span></span><br><span class="line"><span class="keyword">const</span> storeOptions = &#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    SET_STATE(s: NonNeverState&lt;<span class="keyword">typeof</span> state&gt;, obj: Partial&lt;NonNeverState&lt;<span class="keyword">typeof</span> state&gt;&gt;) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOwnKey(key, obj)) &#123;</span><br><span class="line">          s[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SET_NAME(s: NonNeverState&lt;<span class="keyword">typeof</span> state&gt;, v: <span class="built_in">string</span>) &#123;</span><br><span class="line">      s.name = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    SET_ASYNC_STATE(&#123; commit &#125;: &#123; commit: Commit &#125;, obj: Partial&lt;NonNeverState&lt;<span class="keyword">typeof</span> state&gt;&gt;) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">          commit(<span class="string">"SET_STATE"</span>, obj);</span><br><span class="line">          resolve(obj);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    modOne: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line">      state: modOneState,</span><br><span class="line">      mutations: modOneMutation,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        SET_ASYNC_NAME(&#123; commit &#125;: &#123; commit: Commit &#125;, name: <span class="built_in">string</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">              commit(<span class="string">"modOne/SET_NAME"</span>, name);</span><br><span class="line">              resolve(name);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      modules: &#123;</span><br><span class="line">        modOneSon: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line">          state: &#123;</span><br><span class="line">            jk: <span class="literal">true</span></span><br><span class="line">          &#125;,</span><br><span class="line">          mutations: &#123;</span><br><span class="line">            SET_JK(state: &#123; jk: <span class="built_in">boolean</span> &#125;, v: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">              state.jk = v;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          actions: &#123;</span><br><span class="line">            SET_ASYNC_JK(&#123; commit &#125;: &#123; commit: Commit &#125;, v: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">                  commit(<span class="string">"modOne/modOneSon/SET_JK"</span>, v);</span><br><span class="line">                  resolve(v);</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          modules: &#123;</span><br><span class="line">            modOneSonSon: &#123;</span><br><span class="line">              namespaced: <span class="literal">true</span>,</span><br><span class="line">              state: &#123;</span><br><span class="line">                kpi: <span class="literal">true</span></span><br><span class="line">              &#125;,</span><br><span class="line">              mutations: &#123;</span><br><span class="line">                SET_KPI(state: &#123; kpi: <span class="built_in">boolean</span> &#125;, v: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">                  state.kpi = v;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              actions: &#123;</span><br><span class="line">                SET_ASYNC_KPI(&#123; commit &#125;: &#123; commit: Commit &#125;, v: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> &#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">                      commit(<span class="string">"modOne/modOneSon/modOneSonSon/SET_KPI"</span>, v);</span><br><span class="line">                      resolve(v);</span><br><span class="line">                    &#125;);</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    modTwo: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line">      state: modTwoState,</span><br><span class="line">      mutations: modTwoMutation,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        SET_ASYNC_AGE(&#123; commit &#125;: &#123; commit: Commit &#125;, v: <span class="built_in">number</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">              commit(<span class="string">"modTwo/SET_AGE"</span>, v);</span><br><span class="line">              resolve(v);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        SET_ASYNC_996(&#123; commit &#125;: &#123; commit: Commit &#125;, v: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">              commit(<span class="string">"modTwo/SET_996"</span>, v);</span><br><span class="line">              resolve(v);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> TState = NonNeverState&lt;GetState&lt;<span class="keyword">typeof</span> storeOptions&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> TMutation = GetMutationKeyParamMap&lt;<span class="keyword">typeof</span> storeOptions&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> TAction = GetActionKeyParamMap&lt;<span class="keyword">typeof</span> storeOptions&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store&lt;TState&gt;(storeOptions);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>利用工作间隙断断续续写了两三周时间，中间也出现因为隔了很长时间没写都忘记上次想到哪儿了XD，确实遇到了几个问题，以下由易到难：</p><h2 id="模板字符串拼接"><a href="#模板字符串拼接" class="headerlink" title="模板字符串拼接"></a>模板字符串拼接</h2><p>因为要实现<code>modules</code>嵌套后<code>mutation</code>与`action以”/“为分隔的命名空间，必须要用上TS4.1出的模板字符串新特性：<a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html</a>. </p><p>本质上这就是js里的模板字符串拼接，不过我遇到的问题是传入的范型扔到字符串拼接type后会报错：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义key的类型</span></span><br><span class="line"><span class="keyword">type</span> KeyType = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 拼接key</span></span><br><span class="line"><span class="keyword">type</span> AddPrefix&lt;Prefix <span class="keyword">extends</span> KeyType, Keys <span class="keyword">extends</span> KeyType&gt; = <span class="string">`<span class="subst">$&#123;Prefix&#125;</span>/<span class="subst">$&#123;Keys&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 使用遇到问题</span></span><br><span class="line"><span class="keyword">type</span> AddPrefixKeys&lt;P, S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = GetValue&lt;&#123;</span><br><span class="line">  [K <span class="keyword">in</span> S]: P <span class="keyword">extends</span> <span class="string">""</span> ? K : AddPrefix&lt;P, K&gt;;</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>这里P会报错：<strong>类型“P”不满足约束“KeyType”</strong>。实际上把范型P那儿改成<code>P extends KeyType</code>就可以了，但是在一些使用场景下你拿到并试图传入的并不一定能将类型缩窄到<code>KeyType</code>，所以自己写了个方法解决这个问题。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Revert2Key&lt;T&gt; = T <span class="keyword">extends</span> KeyType ? T : KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddPrefixKeys&lt;P, S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = GetValue&lt;&#123;</span><br><span class="line">  [K <span class="keyword">in</span> S]: P <span class="keyword">extends</span> <span class="string">""</span> ? K : AddPrefix&lt;Revert2Key&lt;P&gt;, K&gt;;</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>但后面发现其实还可以用交叉类型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AddPrefixKeys&lt;P, S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = GetValue&lt;&#123;</span><br><span class="line">  [K <span class="keyword">in</span> S]: P <span class="keyword">extends</span> <span class="string">""</span> ? K : AddPrefix&lt;P &amp; <span class="built_in">string</span>, K&gt;;</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><p>很明显，第二种方式更优雅。</p><h2 id="使用者定义state时，出现never类型如何解决？"><a href="#使用者定义state时，出现never类型如何解决？" class="headerlink" title="使用者定义state时，出现never类型如何解决？"></a>使用者定义state时，出现never类型如何解决？</h2><p>其实当我们给一个state其中一个变量赋初始值为[]时，它的类型就会被自动推断为<code>never[]</code>。我写了一个工具来解决这个问题：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DealNeverType&lt;T&gt; = T <span class="keyword">extends</span> never ? <span class="built_in">any</span> : T <span class="keyword">extends</span> never[] ? <span class="built_in">any</span>[] : T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> NonNeverState&lt;R <span class="keyword">extends</span> object&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof R]: R[K] <span class="keyword">extends</span> (<span class="built_in">any</span>[] | never) ? </span><br><span class="line">  DealNeverType&lt;R[K]&gt; : (R[K] <span class="keyword">extends</span> object ? </span><br><span class="line">  NonNeverState&lt;R[K]&gt; : DealNeverType&lt;R[K]&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上开始我写的版本，这其中有个很大的问题，原因是我没有理解never这个特殊类型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckNever&lt;T&gt; = T <span class="keyword">extends</span> never ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 结果并不是想象那样</span></span><br><span class="line"><span class="keyword">type</span> Test = CheckNever&lt;never&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure><p>另外，never是所有类型的subType，这里只随便举个例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Test2 = never <span class="keyword">extends</span> symbol ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>很快，我在Typescript的仓库找到了答案：<a href="https://github.com/microsoft/TypeScript/issues/23182。" target="_blank" rel="noopener">https://github.com/microsoft/TypeScript/issues/23182。</a></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DealNeverType&lt;T&gt; = [T] <span class="keyword">extends</span> [never] ? <span class="built_in">any</span> : ([T] <span class="keyword">extends</span> [never[]] ? <span class="built_in">any</span>[] : T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> NonNeverState&lt;R <span class="keyword">extends</span> object&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof R]: R[K] <span class="keyword">extends</span> (<span class="built_in">any</span>[] | never) ? </span><br><span class="line">  DealNeverType&lt;R[K]&gt; : (R[K] <span class="keyword">extends</span> object ? </span><br><span class="line">  NonNeverState&lt;R[K]&gt; : DealNeverType&lt;R[K]&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案就是让他们变成元祖。</p><h2 id="当Store树有N层modules，如何获取所有的key？"><a href="#当Store树有N层modules，如何获取所有的key？" class="headerlink" title="当Store树有N层modules，如何获取所有的key？"></a>当Store树有N层modules，如何获取所有的key？</h2><p>老实说这个其实是最简单的问题，不过我中间走了一次弯路，还是把它老老实实写出来吧！</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 判断是否添加/</span></span><br><span class="line"><span class="keyword">type</span> AddSlashe&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">""</span> ? T : <span class="string">`<span class="subst">$&#123;T &amp; <span class="built_in">string</span>&#125;</span>/`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> GetMutationKeys&lt;N <span class="keyword">extends</span> ModuleStoreOptions, Prefix = <span class="string">""</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof N]: N[K] <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">  (</span><br><span class="line">    AddPrefix&lt;<span class="string">`<span class="subst">$&#123;AddSlashe&lt;Prefix&gt;&#125;</span><span class="subst">$&#123;K &amp; <span class="built_in">string</span>&#125;</span>`</span> , keyof N[K][<span class="string">"mutations"</span>] &amp; <span class="built_in">string</span>&gt; | </span><br><span class="line">    GetMutationKeys&lt;N[K][<span class="string">"modules"</span>], <span class="string">`<span class="subst">$&#123;AddSlashe&lt;Prefix&gt;&#125;</span><span class="subst">$&#123;K &amp; <span class="built_in">string</span>&#125;</span>`</span>&gt;</span><br><span class="line">  ) : </span><br><span class="line">  AddPrefix&lt;<span class="string">`<span class="subst">$&#123;AddSlashe&lt;Prefix&gt;&#125;</span><span class="subst">$&#123;K &amp; <span class="built_in">string</span>&#125;</span>`</span>, keyof N[K][<span class="string">"mutations"</span>] &amp; <span class="built_in">string</span>&gt;; </span><br><span class="line">&#125;[keyof N];</span><br></pre></td></tr></table></figure><p>通过判断当前对象是否有<code>modules</code>来决定是否走递归三元分支</p><p><img src="/BeCoderQ.github.io/2021/07/19/实现Vuex最精准的类型推断Beta版/infer-1.png" alt="图"></p><p>可以看到类型确实推断出来了，是那么回事，不过我发现这个方法行不通：</p><ul><li>这样只能拿到mutations或者actions的key，我拿不到参数（即commit(xxx, payload)函数的这个payload）。</li><li>这样拿不到第一层state，用户要单独传入modules类型再与外层state交叉，很麻烦。</li></ul><p>第二个问题很好解决，先不谈，第一个问题就要难一点：要实现本文最上面的图示的效果，就必须要把mutations的key与函数的第二个参数联系起来。</p><p>这也就引出了下一个问题</p><h2 id="如何将modules嵌套的key与函数参数对应起来？"><a href="#如何将modules嵌套的key与函数参数对应起来？" class="headerlink" title="如何将modules嵌套的key与函数参数对应起来？"></a>如何将modules嵌套的key与函数参数对应起来？</h2><p>实现这点大体要分为两个步骤：</p><h3 id="获取mutations或actions的payload类型"><a href="#获取mutations或actions的payload类型" class="headerlink" title="获取mutations或actions的payload类型"></a>获取mutations或actions的payload类型</h3><p>想实现上面的效果，<code>infer</code>关键字就要大显神威了，下面是一个获取mutation或action函数第二个参数的类型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GetSecondParamType&lt;M, MK <span class="keyword">extends</span> <span class="built_in">string</span>, K <span class="keyword">extends</span> <span class="built_in">string</span>, KEY = <span class="string">"mutations"</span>, E = never&gt; = M <span class="keyword">extends</span> &#123; </span><br><span class="line">  [X <span class="keyword">in</span> MK]: &#123; </span><br><span class="line">    [X1 <span class="keyword">in</span> KEY &amp; <span class="built_in">string</span>]: &#123; </span><br><span class="line">      [X2 <span class="keyword">in</span> K]: <span class="function">(<span class="params">s: <span class="built_in">any</span>, v: infer N</span>)=&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; ? N | E : never;</span><br></pre></td></tr></table></figure><p>看起来很头大，换一种写法看着会好一点：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> XXX&lt;....&gt; = M <span class="keyword">extends</span> &#123;</span><br><span class="line">mod: &#123;</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    SET_NAME: <span class="function">(<span class="params">state: <span class="built_in">any</span>, value: <span class="built_in">any</span>[]</span>)=&gt;</span> <span class="built_in">any</span>     </span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类型转门用于推断vuex的modules内的mutations或actions，M是模块类型，MK是要推断的指定模块的key，KEY是选择mutations还是actions，K是指定要推断的mutations或actions的某一个函数。</p><h4 id="infer关键字"><a href="#infer关键字" class="headerlink" title="infer关键字"></a>infer关键字</h4><p>可以把infer理解为一个陷阱(trap)，以TS内置的ReturnType为例:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>当传入函数时，就一定<code>extends (...args: any)</code>，那么把<code>infer R</code>放到函数返回值的地方，它就会捕获到函数的返回类型。</p><h4 id="为什么要设置这么多范型参数，像K直接传入keyof-mutations不行吗？"><a href="#为什么要设置这么多范型参数，像K直接传入keyof-mutations不行吗？" class="headerlink" title="为什么要设置这么多范型参数，像K直接传入keyof mutations不行吗？"></a>为什么要设置这么多范型参数，像K直接传入keyof mutations不行吗？</h4><p>答案是不行，继续往后看，你会发现直接传入keyof mutations会让结果变成<strong>一对多</strong>。</p><h4 id="这里最后一个范型参数E是做什么的"><a href="#这里最后一个范型参数E是做什么的" class="headerlink" title="这里最后一个范型参数E是做什么的"></a>这里最后一个范型参数E是做什么的</h4><p>这个E可以让所有推断的类型有一个联合类型，比如<code>null</code>。这里设置初始值为never是因为<code>任何类型 | never</code>都会得到其本身，这能兼容不传入E的情况。</p><h3 id="递归将key和payload对应起来"><a href="#递归将key和payload对应起来" class="headerlink" title="递归将key和payload对应起来"></a>递归将key和payload对应起来</h3><p>到这一步代码就显得非常凌乱了😂：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义键类型</span></span><br><span class="line"><span class="keyword">type</span> KeyType = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断出参数类型 返回元祖</span></span><br><span class="line"><span class="keyword">type</span> ParamsType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer R) =&gt; <span class="built_in">any</span> ? R : <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象值</span></span><br><span class="line"><span class="keyword">type</span> GetValue&lt;T&gt; = T[keyof T];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型转交叉类型</span></span><br><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="function">(<span class="params">k: U</span>) =&gt;</span> <span class="built_in">void</span> : never) <span class="keyword">extends</span> (<span class="function">(<span class="params">k: infer I</span>) =&gt;</span> <span class="built_in">void</span>) ? I : never</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddPrefix&lt;Prefix <span class="keyword">extends</span> KeyType, Keys <span class="keyword">extends</span> KeyType&gt; = <span class="string">`<span class="subst">$&#123;Prefix&#125;</span>/<span class="subst">$&#123;Keys&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断是否添加/</span></span><br><span class="line"><span class="keyword">type</span> AddSlashe&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">""</span> ? T : <span class="string">`<span class="subst">$&#123;T &amp; <span class="built_in">string</span>&#125;</span>/`</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 支持联合类型的字符串模板拼接 support string splicing of union type </span></span><br><span class="line"><span class="keyword">type</span> AddPrefixKeys&lt;P, S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = GetValue&lt;&#123;</span><br><span class="line">  [K <span class="keyword">in</span> S]: P <span class="keyword">extends</span> <span class="string">""</span> ? K : AddPrefix&lt;P &amp; <span class="built_in">string</span>, K&gt;;</span><br><span class="line">&#125;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块Store的类型，用于继承判断 type of modules's store</span></span><br><span class="line"><span class="keyword">type</span> ModuleStoreOptions = &#123; </span><br><span class="line">  [k: <span class="built_in">string</span>]: &#123; </span><br><span class="line">    mutations: &#123; [x: <span class="built_in">string</span>]: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>)=&gt;</span> <span class="built_in">any</span> &#125;; </span><br><span class="line">    state: <span class="built_in">any</span>; </span><br><span class="line">    actions?: &#123; [x: <span class="built_in">string</span>]: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>)=&gt;</span> <span class="built_in">any</span> &#125;; </span><br><span class="line">    modules?: ModuleStoreOptions </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取mutation或action函数第二个参数的类型 get second param type of function which named K</span></span><br><span class="line"><span class="keyword">type</span> GetSecondParamType&lt;M, MK <span class="keyword">extends</span> <span class="built_in">string</span>, K <span class="keyword">extends</span> <span class="built_in">string</span>, KEY = <span class="string">"mutations"</span>, E = never&gt; = M <span class="keyword">extends</span> &#123; </span><br><span class="line">  [X <span class="keyword">in</span> MK]: &#123; </span><br><span class="line">    [X1 <span class="keyword">in</span> KEY &amp; <span class="built_in">string</span>]: &#123; </span><br><span class="line">      [X2 <span class="keyword">in</span> K]: <span class="function">(<span class="params">s: <span class="built_in">any</span>, v: infer N</span>)=&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; ? N | E : never;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetModuleMutationKeyParamMap&lt;M <span class="keyword">extends</span> ModuleStoreOptions, P = <span class="string">""</span>&gt; = UnionToIntersection&lt;GetValue&lt;&#123;</span><br><span class="line">  <span class="comment">// 这里拿到传入的模块M的key 如modOne</span></span><br><span class="line">  [R <span class="keyword">in</span> keyof M]:</span><br><span class="line">  <span class="comment">// 判断内部是否还有modules，如modOne: &#123; modules: ... &#125;</span></span><br><span class="line">    M[R] <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">    <span class="comment">// 注意我们需要的只是值，而不是对象，因此这里都是拿GetValue类型包着的。</span></span><br><span class="line">    GetValue&lt;&#123;</span><br><span class="line">      <span class="comment">// 遍历M modules下R的mutations</span></span><br><span class="line">      [K <span class="keyword">in</span> keyof M[R][<span class="string">"mutations"</span>]]: &#123; </span><br><span class="line">        <span class="comment">// 最后 这里才是遍历key，并对应payload类型的地方，这也是最后输出的结果</span></span><br><span class="line">        [K1 <span class="keyword">in</span> AddPrefixKeys&lt;<span class="string">`<span class="subst">$&#123;AddSlashe&lt;P&gt;&#125;</span><span class="subst">$&#123;R &amp; <span class="built_in">string</span>&#125;</span>`</span>, K &amp; <span class="built_in">string</span>&gt;]: GetSecondParamType&lt;M, R &amp; <span class="built_in">string</span>, K &amp; <span class="built_in">string</span>&gt;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;&gt; &amp; GetMutationKeyParamMap&lt;M[R][<span class="string">"modules"</span>], P <span class="keyword">extends</span> <span class="string">""</span> ? R : AddPrefix&lt;P &amp; <span class="built_in">string</span>, R &amp; <span class="built_in">string</span>&gt;&gt; : </span><br><span class="line">    GetValue&lt;&#123;</span><br><span class="line">      [K <span class="keyword">in</span> keyof M[R][<span class="string">"mutations"</span>]]: &#123;</span><br><span class="line">        [K1 <span class="keyword">in</span> AddPrefix&lt;<span class="string">`<span class="subst">$&#123;AddSlashe&lt;P&gt;&#125;</span><span class="subst">$&#123;R &amp; <span class="built_in">string</span>&#125;</span>`</span>, K &amp; <span class="built_in">string</span>&gt;]: GetSecondParamType&lt;M, R &amp; <span class="built_in">string</span>, K &amp; <span class="built_in">string</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&gt;</span><br><span class="line">&#125;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持直接传入整个vuex store树 解析出mutation的key与函数第二个参数类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> GetMutationKeyParamMap&lt;M <span class="keyword">extends</span> (ModuleStoreOptions | GetValue&lt;ModuleStoreOptions&gt;), P = <span class="string">""</span>&gt; = </span><br><span class="line">    M <span class="keyword">extends</span> ModuleStoreOptions ? </span><br><span class="line">    GetModuleMutationKeyParamMap&lt;M, P&gt; : </span><br><span class="line">    M <span class="keyword">extends</span> GetValue&lt;ModuleStoreOptions&gt; ? </span><br><span class="line">    (</span><br><span class="line"><span class="comment">// 对于非modules的第一层，直接推出类型就行了</span></span><br><span class="line">      &#123; [K <span class="keyword">in</span> keyof M[<span class="string">"mutations"</span>]]: ParamsType&lt;M[<span class="string">"mutations"</span>][K &amp; <span class="built_in">string</span>]&gt;[<span class="number">1</span>] &#125; &amp;</span><br><span class="line">      (</span><br><span class="line">        M <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">        GetModuleMutationKeyParamMap&lt;M[<span class="string">"modules"</span>]&gt; : </span><br><span class="line">        &#123;&#125;</span><br><span class="line">      )</span><br><span class="line">    ) : never;</span><br></pre></td></tr></table></figure><p>从上往下看，多了三个东西：<code>GetValue</code>和<code>AddPrefixKeys</code>以及<code>UnionToIntersection</code>，前两者很好理解，前者是获取对象值的，后者是扩展了模板字符串拼接类型<code>AddPrefix</code>，可以接收联合类型拼接：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AddPrefixKeys&lt;P, S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = GetValue&lt;&#123;</span><br><span class="line">  [K <span class="keyword">in</span> S]: P <span class="keyword">extends</span> <span class="string">""</span> ? K : AddPrefix&lt;P &amp; <span class="built_in">string</span>, K&gt;;</span><br><span class="line">&#125;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = AddPrefixKeys&lt;<span class="string">"vwt"</span>, <span class="string">"1"</span> | <span class="string">"2"</span> | <span class="string">"3"</span>&gt;; <span class="comment">// "vwt/1 | vwt/2 | vwt/3"</span></span><br></pre></td></tr></table></figure><p>第三个<code>UnionToIntersection</code>，其实是用来把联合类型转为交叉类型的：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; name: <span class="built_in">string</span> &#125; | &#123; age: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Intersection = UnionToIntersection&lt;A&gt;; <span class="comment">// &#123; name: string; age: number &#125;</span></span><br></pre></td></tr></table></figure><p><strong>推断key和param对应的过程不仅要推出他们的类型，还要让结构扁平化</strong>。</p><h4 id="GetModuleMutationKeyParamMap类型"><a href="#GetModuleMutationKeyParamMap类型" class="headerlink" title="GetModuleMutationKeyParamMap类型"></a>GetModuleMutationKeyParamMap类型</h4><p>这个类型用于推断modules内的mutation类型，推断结果会是这样：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  SET_NAME: <span class="built_in">string</span>;</span><br><span class="line">  modOne/SET_STATE: Partial&lt;<span class="keyword">typeof</span> modOneState&gt;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做了三个工作：</p><ul><li>使用递归与交叉类型把嵌套modules中原本树形结构的mutation扁平化（UnionToIntersection）</li><li>利用多层对象遍历(就是那堆xxx in keyof)保证<code>GetSecondParamType</code>拿到的mutations函数的KEY不是联合类型</li><li>同样是利用递归，把上一轮的嵌套结果P传入下一轮，实现mod/modOne/modOneSon这样的效果</li></ul><h4 id="GetMutationKeyParamMap类型"><a href="#GetMutationKeyParamMap类型" class="headerlink" title="GetMutationKeyParamMap类型"></a>GetMutationKeyParamMap类型</h4><p>这个类型就没那么复杂了，就是判断用户传入的类型是整个Vuex store还是只穿了modules的类型，作为一个兼容两者的类型暴露出去。</p><p>actions的获取过程和mutations的基本就是一样的，就变了个key的名字，就不单独写出来了</p><h1 id="解决最后一个麻烦"><a href="#解决最后一个麻烦" class="headerlink" title="解决最后一个麻烦"></a>解决最后一个麻烦</h1><p>到这里其实还有个最重要的问题还没有解决，那就是声明合并的问题，在vuex的官方声明文件<code>vue.d.ts</code>中，有这么几行代码：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "vue/types/vue" &#123;</span><br><span class="line">  <span class="keyword">interface</span> Vue &#123;</span><br><span class="line">    $store: Store&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vuex官方声明了$store对象，但给了个any类型，这也导致后续声明合并都无效，最多也就合并下Commit这些类型，所以我直接用node程序把这个代码删掉了hhh。</p><p>之后创建一个声明文件：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CommitOptions, DispatchOptions, Payload, Store &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TAction, TMutation, TState &#125; <span class="keyword">from</span> <span class="string">"@/store"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TupleTypeToUnions&lt;T, K = <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;K&gt; ? T[<span class="built_in">number</span>] : T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除指定key，可接受元祖</span></span><br><span class="line"><span class="keyword">type</span> ExcludeKey&lt;T, U&gt; = T <span class="keyword">extends</span> (U <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; ? TupleTypeToUnions&lt;U&gt; : U) ? never : T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除state与commit、dispatch 方便后续重写 </span></span><br><span class="line"><span class="keyword">type</span> CutStore = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> ExcludeKey&lt;keyof Store&lt;<span class="built_in">any</span>&gt;, [<span class="string">"state"</span>, <span class="string">"commit"</span>, <span class="string">"dispatch"</span>]&gt;]: Store&lt;<span class="built_in">any</span>&gt;[K];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "vue/types/vue" &#123;</span><br><span class="line">  <span class="keyword">interface</span> Vue &#123;</span><br><span class="line">    $store: CutStore &amp; &#123;</span><br><span class="line">      commit: &#123;</span><br><span class="line">        &lt;R <span class="keyword">extends</span> keyof TMutation&gt;(</span><br><span class="line">          <span class="keyword">type</span>: R,</span><br><span class="line">          payload?: TMutation[R],</span><br><span class="line">          options?: CommitOptions</span><br><span class="line">        ): <span class="built_in">void</span>;</span><br><span class="line">        &lt;P <span class="keyword">extends</span> Payload&gt;(payloadWithType: P, options?: CommitOptions): <span class="built_in">void</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; &amp; &#123;</span><br><span class="line">      dispatch: &#123;</span><br><span class="line">        &lt;R <span class="keyword">extends</span> keyof TAction&gt;(</span><br><span class="line">          <span class="keyword">type</span>: R,</span><br><span class="line">          payload?: TAction[R],</span><br><span class="line">          options?: DispatchOptions</span><br><span class="line">        ): <span class="built_in">void</span>;</span><br><span class="line">        &lt;P <span class="keyword">extends</span> Payload&gt;(payloadWithType: P, options?: DispatchOptions): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; &amp; &#123;</span><br><span class="line">      state: TState;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "vuex/types/index" &#123;</span><br><span class="line">  <span class="keyword">interface</span> Commit &#123;</span><br><span class="line">    &lt;K <span class="keyword">extends</span> keyof TMutation&gt;(</span><br><span class="line">      <span class="keyword">type</span>: K,</span><br><span class="line">      payload?: TMutation[K],</span><br><span class="line">      options?: CommitOptions</span><br><span class="line">    ): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> Dispatch &#123;</span><br><span class="line">    &lt;K <span class="keyword">extends</span> keyof TAction&gt;(</span><br><span class="line">      <span class="keyword">type</span>: K,</span><br><span class="line">      payload?: TAction[K],</span><br><span class="line">      options?: DispatchOptions</span><br><span class="line">    ): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此算是完工了。</p><h1 id="工具完整代码"><a href="#工具完整代码" class="headerlink" title="工具完整代码"></a>工具完整代码</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UnionToIntersection&lt;U&gt; = </span><br><span class="line">  (U <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="function">(<span class="params">k: U</span>) =&gt;</span> <span class="built_in">void</span> : never) <span class="keyword">extends</span> (<span class="function">(<span class="params">k: infer I</span>) =&gt;</span> <span class="built_in">void</span>) ? I : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断出函数的参数类型 infer param type of function</span></span><br><span class="line"><span class="keyword">type</span> ParamsType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer R) =&gt; <span class="built_in">any</span> ? R : <span class="built_in">any</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * never是一个特殊类型，比如你让 any extends never ? 1 : 2，这个结果会是1 | 2，另外，never extends never[]是true</span></span><br><span class="line"><span class="comment"> * 解决这些特殊情况可以把它转为元祖类型后进行对比 </span></span><br><span class="line"><span class="comment"> * to prevent T being distributive, wrap it with []</span></span><br><span class="line"><span class="comment"> * ref. https://github.com/microsoft/TypeScript/issues/23182</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DealNeverType&lt;T&gt; = [T] <span class="keyword">extends</span> [never] ? <span class="built_in">any</span> : ([T] <span class="keyword">extends</span> [never[]] ? <span class="built_in">any</span>[] : T);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * state =  &#123;</span></span><br><span class="line"><span class="comment"> *    arr: []</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> * 这种会被推断为never[]</span></span><br><span class="line"><span class="comment"> * this one will be infered to never[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> NonNeverState&lt;R <span class="keyword">extends</span> object&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof R]: R[K] <span class="keyword">extends</span> (<span class="built_in">any</span>[] | never) ? </span><br><span class="line">  DealNeverType&lt;R[K]&gt; : (R[K] <span class="keyword">extends</span> object ? </span><br><span class="line">  NonNeverState&lt;R[K]&gt; : DealNeverType&lt;R[K]&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义键类型</span></span><br><span class="line"><span class="keyword">type</span> KeyType = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值 get value of an object</span></span><br><span class="line"><span class="keyword">type</span> GetValue&lt;T&gt; = T[keyof T];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddPrefix&lt;Prefix <span class="keyword">extends</span> KeyType, Keys <span class="keyword">extends</span> KeyType&gt; = <span class="string">`<span class="subst">$&#123;Prefix&#125;</span>/<span class="subst">$&#123;Keys&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断是否添加/</span></span><br><span class="line"><span class="keyword">type</span> AddSlashe&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">""</span> ? T : <span class="string">`<span class="subst">$&#123;T &amp; <span class="built_in">string</span>&#125;</span>/`</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 支持联合类型的字符串模板拼接 support string splicing of union type </span></span><br><span class="line"><span class="keyword">type</span> AddPrefixKeys&lt;P, S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = GetValue&lt;&#123;</span><br><span class="line">  [K <span class="keyword">in</span> S]: P <span class="keyword">extends</span> <span class="string">""</span> ? K : AddPrefix&lt;P &amp; <span class="built_in">string</span>, K&gt;;</span><br><span class="line">&#125;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块Store的类型，用于继承判断 type of modules's store</span></span><br><span class="line"><span class="keyword">type</span> ModuleStoreOptions = &#123; </span><br><span class="line">  [k: <span class="built_in">string</span>]: &#123; </span><br><span class="line">    mutations: &#123; [x: <span class="built_in">string</span>]: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>)=&gt;</span> <span class="built_in">any</span> &#125;; </span><br><span class="line">    state: <span class="built_in">any</span>; </span><br><span class="line">    actions?: &#123; [x: <span class="built_in">string</span>]: <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>)=&gt;</span> <span class="built_in">any</span> &#125;; </span><br><span class="line">    modules?: ModuleStoreOptions </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取mutation或action函数第二个参数的类型 get second param type of function which named K</span></span><br><span class="line"><span class="keyword">type</span> GetSecondParamType&lt;M, MK <span class="keyword">extends</span> <span class="built_in">string</span>, K <span class="keyword">extends</span> <span class="built_in">string</span>, KEY = <span class="string">"mutations"</span>, E = never&gt; = M <span class="keyword">extends</span> &#123; </span><br><span class="line">  [X <span class="keyword">in</span> MK]: &#123; </span><br><span class="line">    [X1 <span class="keyword">in</span> KEY &amp; <span class="built_in">string</span>]: &#123; </span><br><span class="line">      [X2 <span class="keyword">in</span> K]: <span class="function">(<span class="params">s: <span class="built_in">any</span>, v: infer N</span>)=&gt;</span> <span class="built_in">any</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; ? N | E : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取modules中的mutation key与第二个参数类型</span></span><br><span class="line"><span class="keyword">type</span> GetModuleMutationKeyParamMap&lt;M <span class="keyword">extends</span> ModuleStoreOptions, P = <span class="string">""</span>&gt; = UnionToIntersection&lt;GetValue&lt;&#123;</span><br><span class="line">  [R <span class="keyword">in</span> keyof M]: </span><br><span class="line">    M[R] <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">    GetValue&lt;&#123; </span><br><span class="line">      [K <span class="keyword">in</span> keyof M[R][<span class="string">"mutations"</span>]]: &#123;</span><br><span class="line">        [K1 <span class="keyword">in</span> AddPrefixKeys&lt;<span class="string">`<span class="subst">$&#123;AddSlashe&lt;P&gt;&#125;</span><span class="subst">$&#123;R &amp; <span class="built_in">string</span>&#125;</span>`</span>, K &amp; <span class="built_in">string</span>&gt;]: GetSecondParamType&lt;M, R &amp; <span class="built_in">string</span>, K &amp; <span class="built_in">string</span>&gt;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;&gt; &amp; GetMutationKeyParamMap&lt;M[R][<span class="string">"modules"</span>], P <span class="keyword">extends</span> <span class="string">""</span> ? R : AddPrefix&lt;P &amp; <span class="built_in">string</span>, R &amp; <span class="built_in">string</span>&gt;&gt; : </span><br><span class="line">    GetValue&lt;&#123;</span><br><span class="line">      [K <span class="keyword">in</span> keyof M[R][<span class="string">"mutations"</span>]]: &#123;</span><br><span class="line">        [K1 <span class="keyword">in</span> AddPrefix&lt;<span class="string">`<span class="subst">$&#123;AddSlashe&lt;P&gt;&#125;</span><span class="subst">$&#123;R &amp; <span class="built_in">string</span>&#125;</span>`</span>, K &amp; <span class="built_in">string</span>&gt;]: GetSecondParamType&lt;M, R &amp; <span class="built_in">string</span>, K &amp; <span class="built_in">string</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&gt;</span><br><span class="line">&#125;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持直接传入整个vuex store树 解析出mutation的key与函数第二个参数类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> GetMutationKeyParamMap&lt;M <span class="keyword">extends</span> (ModuleStoreOptions | GetValue&lt;ModuleStoreOptions&gt;), P = <span class="string">""</span>&gt; = </span><br><span class="line">    M <span class="keyword">extends</span> ModuleStoreOptions ? </span><br><span class="line">    GetModuleMutationKeyParamMap&lt;M, P&gt; : </span><br><span class="line">    M <span class="keyword">extends</span> GetValue&lt;ModuleStoreOptions&gt; ? </span><br><span class="line">    (</span><br><span class="line">      &#123; [K <span class="keyword">in</span> keyof M[<span class="string">"mutations"</span>]]: ParamsType&lt;M[<span class="string">"mutations"</span>][K &amp; <span class="built_in">string</span>]&gt;[<span class="number">1</span>] &#125; &amp;</span><br><span class="line">      (</span><br><span class="line">        M <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">        GetModuleMutationKeyParamMap&lt;M[<span class="string">"modules"</span>]&gt; : </span><br><span class="line">        &#123;&#125;</span><br><span class="line">      )</span><br><span class="line">    ) : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取模块下的action的key与函数第二个参数map</span></span><br><span class="line"><span class="keyword">type</span> GetModuleActionKeyParamMap&lt;M <span class="keyword">extends</span> ModuleStoreOptions, P = <span class="string">""</span>&gt; = UnionToIntersection&lt;GetValue&lt;&#123;</span><br><span class="line">  [R <span class="keyword">in</span> keyof M]: </span><br><span class="line">    M[R] <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">    GetValue&lt;&#123; </span><br><span class="line">      [K <span class="keyword">in</span> keyof M[R][<span class="string">"actions"</span>]]: &#123;</span><br><span class="line">        [K1 <span class="keyword">in</span> AddPrefixKeys&lt;<span class="string">`<span class="subst">$&#123;AddSlashe&lt;P&gt;&#125;</span><span class="subst">$&#123;R &amp; <span class="built_in">string</span>&#125;</span>`</span>, K &amp; <span class="built_in">string</span>&gt;]: GetSecondParamType&lt;M, R &amp; <span class="built_in">string</span>, K &amp; <span class="built_in">string</span>, <span class="string">"actions"</span>&gt;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;&gt; &amp; GetActionKeyParamMap&lt;M[R][<span class="string">"modules"</span>], P <span class="keyword">extends</span> <span class="string">""</span> ? R : AddPrefix&lt;P &amp; <span class="built_in">string</span>, R &amp; <span class="built_in">string</span>&gt;&gt; : </span><br><span class="line">    GetValue&lt;&#123;</span><br><span class="line">      [K <span class="keyword">in</span> keyof M[R][<span class="string">"actions"</span>]]: &#123;</span><br><span class="line">        [K1 <span class="keyword">in</span> AddPrefix&lt;<span class="string">`<span class="subst">$&#123;AddSlashe&lt;P&gt;&#125;</span><span class="subst">$&#123;R &amp; <span class="built_in">string</span>&#125;</span>`</span>, K &amp; <span class="built_in">string</span>&gt;]: GetSecondParamType&lt;M, R &amp; <span class="built_in">string</span>, K &amp; <span class="built_in">string</span>, <span class="string">"actions"</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&gt;</span><br><span class="line">&#125;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持直接传入整个vuex store树 解析出action的key与函数第二个参数类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> GetActionKeyParamMap&lt;M <span class="keyword">extends</span> (ModuleStoreOptions | GetValue&lt;ModuleStoreOptions&gt;), P = <span class="string">""</span>&gt; = </span><br><span class="line">    M <span class="keyword">extends</span> ModuleStoreOptions ? </span><br><span class="line">    GetModuleActionKeyParamMap&lt;M, P&gt; : </span><br><span class="line">    M <span class="keyword">extends</span> Required&lt;GetValue&lt;ModuleStoreOptions&gt;&gt; ? </span><br><span class="line">    (</span><br><span class="line">      &#123; [K <span class="keyword">in</span> keyof M[<span class="string">"actions"</span>]]: ParamsType&lt;M[<span class="string">"actions"</span>][K &amp; <span class="built_in">string</span>]&gt;[<span class="number">1</span>] &#125; &amp;</span><br><span class="line">      (</span><br><span class="line">        M <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">        GetModuleActionKeyParamMap&lt;M[<span class="string">"modules"</span>]&gt; : </span><br><span class="line">        &#123;&#125;</span><br><span class="line">      )</span><br><span class="line">    ) : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块state的类型 会递归拿到嵌套模块的state类型</span></span><br><span class="line"><span class="keyword">type</span> GetSubState&lt;M <span class="keyword">extends</span> ModuleStoreOptions&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof M]?: M[K] <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">    M[K][<span class="string">"state"</span>] &amp; GetSubState&lt;M[K][<span class="string">"modules"</span>]&gt; : </span><br><span class="line">    M[K][<span class="string">"state"</span>]</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取根据传入的vuex store 获取state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> GetState&lt;M <span class="keyword">extends</span> (ModuleStoreOptions | GetValue&lt;ModuleStoreOptions&gt;)&gt; = M <span class="keyword">extends</span> ModuleStoreOptions ? </span><br><span class="line">  GetSubState&lt;M&gt; : (</span><br><span class="line">    &#123; [K <span class="keyword">in</span> keyof M[<span class="string">"state"</span>]]: M[<span class="string">"state"</span>][K] &#125; &amp; (</span><br><span class="line">    M <span class="keyword">extends</span> &#123; modules: ModuleStoreOptions &#125; ? </span><br><span class="line">    GetState&lt;M[<span class="string">"modules"</span>]&gt; : </span><br><span class="line">    &#123;&#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个文章也是断断续续写的，写完感觉乱七八糟。以上是大概实现，实际上还有坑没填，比如namespaced设置为false的没有单独处理，又比如commit与dispatch只支持了一种写法，再比如要通过删除库源码的一部分才能实现（不过好在ts只是元编程基本不涉及数据逻辑），另外感觉写得过于复杂了。最后的最后，这整套我有整合发布到npm上，使用<code>npm i vuex-with-type</code>安装，<code>npx vwt init</code>使用。掘金写文章，发npm包都是第一次，如果本文有人看，希望能留下评论批评指点一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;和Vuex耗上了&quot;&gt;&lt;a href=&quot;#和Vuex耗上了&quot; class=&quot;headerlink&quot; title=&quot;和Vuex耗上了&quot;&gt;&lt;/a&gt;和Vuex耗上了&lt;/h1&gt;&lt;p&gt;上一次我也对Vuex进行了推断，但结果很难让人满意: &lt;a href=&quot;http://zyy
      
    
    </summary>
    
    
      <category term="记录" scheme="http://localhost:4000/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="typescript" scheme="http://localhost:4000/tags/typescript/"/>
    
      <category term="vuex" scheme="http://localhost:4000/tags/vuex/"/>
    
      <category term="开源" scheme="http://localhost:4000/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>记一次Vuex中commit类型校验的过程</title>
    <link href="http://localhost:4000/2021/06/02/%E8%AE%B0%E4%B8%80%E6%AC%A1Vuex%E4%B8%ADcommit%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://localhost:4000/2021/06/02/%E8%AE%B0%E4%B8%80%E6%AC%A1Vuex%E4%B8%ADcommit%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2021-06-02T09:29:07.000Z</published>
    <updated>2021-06-15T02:14:53.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>技术栈是<code>vue2.x</code> +<code>typescript</code>+<code>nuxt</code>，接手的项目虽说用的ts，不过并没有完成一些关键的校验。接手后我先改了一下store文件的校验：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个工具类型用来处理state中直接写[]这样数据导致的never类型</span></span><br><span class="line"><span class="keyword">type</span> DealNeverType&lt;T <span class="keyword">extends</span> object&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> never[]</span><br><span class="line">    ? <span class="built_in">any</span>[]</span><br><span class="line">    : T[K] <span class="keyword">extends</span> never</span><br><span class="line">    ? <span class="built_in">any</span></span><br><span class="line">    : T[K];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> TState = DealNeverType&lt;ReturnType&lt;<span class="keyword">typeof</span> state&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  SET_STATE(state: TState, obj: Partial&lt;TState&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isOwnKey(key, obj)) &#123;</span><br><span class="line">        state[key] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> TMutations = keyof <span class="keyword">typeof</span> mutations;</span><br></pre></td></tr></table></figure><p>项目搭建人是想的将<code>commit(key, value)</code>简化一点，统一的用<code>commit(&quot;SET_STATE&quot;, { key: value })</code>来改值，这个到没有问题，就是没有做任何类型校验。<code>isOwnKey</code>函数的话是这样：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数工具，类型保护解决索引类型报错问题</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isOwnKey</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="built_in">string</span> | <span class="built_in">number</span> | symbol,</span></span></span><br><span class="line"><span class="function"><span class="params">  object: object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">key</span> <span class="title">is</span> <span class="title">keyof</span> <span class="title">typeof</span> <span class="title">object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>在vuex4.x之前一直都存在这个问题，那就是官方declare了一个全局的声明，它将<code>$store</code>声明合并在了<code>interface Vue</code>中，这无可厚非，但问题是它的类型是<code>Store&lt;any&gt;</code>！holy shit.</p><p>这让后面的校验就像便秘一样难受，尤其是<code>state</code>的校验，暂时还是没找到方法，不过这次先说<code>commit</code>，这个暂时解决了的。</p><h2 id="尝试过的方案"><a href="#尝试过的方案" class="headerlink" title="尝试过的方案"></a>尝试过的方案</h2><p>我大概使用了3个方法：</p><h3 id="声明合并Vue中的-store"><a href="#声明合并Vue中的-store" class="headerlink" title="声明合并Vue中的$store"></a>声明合并Vue中的$store</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先去掉commit，避免与vuex原生的Commit类型打架最后变成交叉类型</span></span><br><span class="line"><span class="keyword">type</span> NoCommitStore = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> Exclude&lt;keyof Store&lt;<span class="built_in">any</span>&gt;, <span class="string">"commit"</span>&gt;]: Store&lt;<span class="built_in">any</span>&gt;[K];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "vue/types/vue" &#123;</span><br><span class="line">  <span class="keyword">interface</span> Vue &#123;</span><br><span class="line">    $store: NoCommitStore &amp; &#123;</span><br><span class="line">      commit: &#123;</span><br><span class="line">        (</span><br><span class="line">          <span class="keyword">type</span>: TMutations,</span><br><span class="line">          payload?: Partial&lt;TState&gt;,</span><br><span class="line">          options?: CommitOptions</span><br><span class="line">        ): <span class="built_in">void</span>;</span><br><span class="line">        &lt;P <span class="keyword">extends</span> Payload&gt;(payloadWithType: P, options?: CommitOptions): <span class="built_in">void</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很快就宣布破产了，IDE会给出如下的提示：</p><p><img src="/BeCoderQ.github.io/2021/06/02/记一次Vuex中commit类型校验的过程/error.png" alt="图"></p><h3 id="仅合并Vuex暴露的Commit类型"><a href="#仅合并Vuex暴露的Commit类型" class="headerlink" title="仅合并Vuex暴露的Commit类型"></a>仅合并Vuex暴露的Commit类型</h3><p>这个方法貌似靠谱点，先看一下Vuex官方声明文件中的<code>Commit</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Commit &#123;</span><br><span class="line">  (<span class="keyword">type</span>: <span class="built_in">string</span>, payload?: <span class="built_in">any</span>, options?: CommitOptions): <span class="built_in">void</span>;</span><br><span class="line">  &lt;P <span class="keyword">extends</span> Payload&gt;(payloadWithType: P, options?: CommitOptions): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看第一个声明，<code>payload</code>类型是<code>any</code>，这就导致我后面不管怎么重载这个函数，最后类型永远都是<code>any</code>。醉了。又宣告失败。</p><h3 id="加上范型重载Commit类型"><a href="#加上范型重载Commit类型" class="headerlink" title="加上范型重载Commit类型"></a>加上范型重载Commit类型</h3><p><code>any</code>类型把我们拦在门外，但是我们可以新定义一个重载类型：加上范型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "vuex/types/index" &#123;</span><br><span class="line">  <span class="keyword">interface</span> Commit &#123;</span><br><span class="line">    &lt;T <span class="keyword">extends</span> TMutations&gt;(</span><br><span class="line">      <span class="keyword">type</span>: T,</span><br><span class="line">      payload?: Partial&lt;TState&gt;,</span><br><span class="line">      options?: CommitOptions</span><br><span class="line">    ): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候需要往commit函数内传一个范型类型，这样校验便完成了：</p><p><img src="/BeCoderQ.github.io/2021/06/02/记一次Vuex中commit类型校验的过程/type-1.png" alt="图"></p><p>第一个type是没问题的，再看看第二个参数：</p><p><img src="/BeCoderQ.github.io/2021/06/02/记一次Vuex中commit类型校验的过程/type-2.png" alt="图"></p><p>同样没问题！虽然要带一个范型拖油瓶，不过也算是在不改声明源码的情况下完成了类型校验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际还是通过声明合并，利用了<code>Commit</code>类型可以重载，想重写<code>$store</code>肯定是不行了，这也导致<code>state</code>的校验几乎不可能实现。虽然在Vuex4中解决了这个问题，但也不能指望所有项目都去升级到4.x来解决类型校验的问题吧？目前看来，出了断言似乎没有更好的方法了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;技术栈是&lt;code&gt;vue2.x&lt;/code&gt; +&lt;code&gt;typescript&lt;/code&gt;+&lt;code&gt;nuxt&lt;/code&gt;，接手
      
    
    </summary>
    
    
      <category term="总结" scheme="http://localhost:4000/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="typescript" scheme="http://localhost:4000/tags/typescript/"/>
    
      <category term="vuex" scheme="http://localhost:4000/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.x与Vue3.x插件式全局组件写法对别</title>
    <link href="http://localhost:4000/2021/05/25/Vue2-x%E4%B8%8EVue3-x%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%86%99%E6%B3%95%E5%AF%B9%E5%88%AB/"/>
    <id>http://localhost:4000/2021/05/25/Vue2-x%E4%B8%8EVue3-x%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%86%99%E6%B3%95%E5%AF%B9%E5%88%AB/</id>
    <published>2021-05-25T07:14:55.000Z</published>
    <updated>2021-05-27T06:18:29.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会有区别"><a href="#为什么会有区别" class="headerlink" title="为什么会有区别"></a>为什么会有区别</h2><p>Vue2.x中我们使用<code>extend</code>方法传入组件类得到可以被实例化的类，以此获得组件上下文的控制权，挂载也很简单，直接使用<code>Vue.prototype.xxx = xxx</code>挂载到Vue根实例的原型上。但在Vue3.x中，这两个东西都没有了，因此写法上会有很大的区别。</p><h2 id="Vue2-x实现一个全局的toast组件"><a href="#Vue2-x实现一个全局的toast组件" class="headerlink" title="Vue2.x实现一个全局的toast组件"></a>Vue2.x实现一个全局的toast组件</h2><p>2.x例子是我在uni-app实现的，不过和一般的vue写法是一样的，下面是目录结构：</p><p><img src="/BeCoderQ.github.io/2021/05/25/Vue2-x与Vue3-x插件式全局组件写法对别/2.x-menu.png" alt="图"></p><p>在插件暴露的对象中<code>extend</code>后，实例化可以拿到组件上下文，便可以改变内部属性了：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">"./Toast.vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toastPlugin = &#123;</span><br><span class="line">    install</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">v: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="comment">// 2.x通过extend方法拿到一个传入组件的实例</span></span><br><span class="line">    <span class="keyword">const</span> ToastConstructor = v.extend(Toast),  </span><br><span class="line">        ins = <span class="keyword">new</span> ToastConstructor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 挂载在一个dom上</span></span><br><span class="line">    ins.$mount(div);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(ins.$el);</span><br><span class="line">    </span><br><span class="line">    Vue.prototype.toast = <span class="function">(<span class="params">&#123; msg = "", delay = 2000 &#125;</span>)=&gt;</span> &#123;</span><br><span class="line">        ins.msg = msg;</span><br><span class="line">        ins.delay = delay;</span><br><span class="line">        ins.show = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> toastPlugin;</span><br></pre></td></tr></table></figure><p>Toast.vue文件还是正常写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view class=&quot;toast&quot; v-show=&quot;show&quot;&gt;</span><br><span class="line">        &lt;view&gt;&#123;&#123; msg &#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; Component, Prop, Vue &#125; from &quot;vue-property-decorator&quot;;</span><br><span class="line">    @Component(&#123;</span><br><span class="line">        components: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    export default class Toast extends Vue &#123;</span><br><span class="line">        public msg: string = &quot;&quot;;</span><br><span class="line">        public delay: number = 2000;</span><br><span class="line">        public show: boolean = false;</span><br><span class="line"></span><br><span class="line">        mounted() &#123;</span><br><span class="line">            setTimeout(()=&gt; &#123;</span><br><span class="line">                this.show = false;</span><br><span class="line">            &#125;, this.delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">    .mask::before &#123;</span><br><span class="line">        background: rgba(0, 0, 0, 0.2);</span><br><span class="line">        position: fixed;</span><br><span class="line">        z-index: 9999;</span><br><span class="line">    &#125;</span><br><span class="line">    .toast &#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        background: rgba(0, 0, 0, 0.4);</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        align-items: center;</span><br><span class="line">        justify-content: space-around;</span><br><span class="line">        width: 60vw;</span><br><span class="line">        min-height: 20vh;</span><br><span class="line">        top: 40%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%, -50%);</span><br><span class="line">        color: #ffffff;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这样就完成了最简单的toast:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.toast(&#123;</span><br><span class="line">  msg: <span class="string">"加载中"</span>,</span><br><span class="line">  delay: <span class="number">2000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2021/05/25/Vue2-x与Vue3-x插件式全局组件写法对别/2.x-toast.png" alt="图"></p><p>当然，别忘了<code>Vue.use(Toast)</code>!</p><h2 id="vue3-x实现一个全局notification-tips"><a href="#vue3-x实现一个全局notification-tips" class="headerlink" title="vue3.x实现一个全局notification(tips)"></a>vue3.x实现一个全局notification(tips)</h2><p>在尝试使用Vue3实现全局的notification提示前，有几个疑问：</p><ul><li>没有了<code>Vue.extend</code>方法如何获取组件的上下文？</li><li>如何实现传入组件将其以插槽形式渲染出来？</li></ul><p>下面上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @mouseover=&quot;onMouseOver&quot; @mouseleave=&quot;onMouseLeave&quot;&gt;</span><br><span class="line">        &lt;span v-if=&quot;msg&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;slot/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, nextTick, onMounted, ref &#125; from &quot;vue&quot;;</span><br><span class="line">    export default defineComponent(&#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            msg: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                default: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            duration: &#123;</span><br><span class="line">                type: Number,</span><br><span class="line">                default: 2000</span><br><span class="line">            &#125;,</span><br><span class="line">            resolve: &#123;</span><br><span class="line">                type: Function,</span><br><span class="line">                default: ()=&gt; &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        setup(props, &#123; attrs, emit &#125;) &#123;</span><br><span class="line">            let timer: number | null = null;</span><br><span class="line"></span><br><span class="line">            function onMouseOver() &#123;</span><br><span class="line">                timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">            &#125;    </span><br><span class="line"></span><br><span class="line">            function onMouseLeave() &#123;</span><br><span class="line">                timer = setTimeout(()=&gt; &#123;</span><br><span class="line">                    document.querySelector(&quot;.tips&quot;)?.remove();</span><br><span class="line">                    props.resolve();</span><br><span class="line">                &#125;, props.duration)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            onMounted(onMouseLeave);</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                msg: props.msg,</span><br><span class="line">                onMouseOver,</span><br><span class="line">                onMouseLeave</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">    .tips &#123;</span><br><span class="line">        @extend .shadow-light;</span><br><span class="line">        @include br(10px);</span><br><span class="line">        padding: 10px;</span><br><span class="line">        min-width: 20vw;</span><br><span class="line">        max-width: 30vw;</span><br><span class="line">        min-height: 10vh;</span><br><span class="line">        position: relative;</span><br><span class="line">        right: 16px;</span><br><span class="line">        margin-bottom: 16px;</span><br><span class="line">        animation: rtl 1s ease;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @keyframes rtl &#123;</span><br><span class="line">        from &#123;</span><br><span class="line">            transform: translateX(-100%);</span><br><span class="line">            opacity: .1;</span><br><span class="line">        &#125;</span><br><span class="line">        to &#123;</span><br><span class="line">            transform: translateX(0);</span><br><span class="line">            opacity: 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">// 父容器</span><br><span class="line">.tips-container &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 32px;</span><br><span class="line">    right: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>组件这边很简单，props接受<code>msg</code>，<code>duration</code>，<code>resolve</code>三个参数，分别是显示的文字消息，展示的时间，最后一个回调函数实际是Promise类的resolve回调函数，用来实现在一些特定事件后通知用户。其他就是一些基本功能：鼠标悬浮时常显，移开后重新计时消失。最后还有一个插槽，用于显示用户传入的组件。这边没有什么问题，就是有一点很奇怪，为什么没有用v-if控制此组件的显示？另外tips是什么鬼？接下来上插件部分的代码就揭晓了：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createVNode, h, render, Component &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Tips <span class="keyword">from</span> <span class="string">"./Tips.vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    install(app: <span class="built_in">any</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 挂载到全局</span></span><br><span class="line">        app.config.globalProperties.$tips = (</span><br><span class="line">          &#123; msg = <span class="string">""</span>, duration = <span class="number">2000</span>, slot &#125;: </span><br><span class="line">          &#123; msg: <span class="built_in">string</span>, duration: <span class="built_in">number</span>, slot: Component &#125;</span><br><span class="line">        )=&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fatherDom = <span class="built_in">document</span>.querySelector(<span class="string">".tips-container"</span>);</span><br><span class="line">            <span class="keyword">let</span> tipsDiv = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>),</span><br><span class="line">                mountEl = fatherDom ? fatherDom : <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);    </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!fatherDom) &#123;</span><br><span class="line">                mountEl.className = <span class="string">"tips-container"</span>;</span><br><span class="line">                body.appendChild(mountEl);</span><br><span class="line">            &#125;</span><br><span class="line">            mountEl.appendChild(tipsDiv);</span><br><span class="line">            tipsDiv.className = <span class="string">"tips"</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> vm = createVNode(Tips, &#123;</span><br><span class="line">                    key: <span class="built_in">Date</span>.now() + <span class="built_in">Math</span>.random(),</span><br><span class="line">                    msg,</span><br><span class="line">                    duration,</span><br><span class="line">                    resolve</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="keyword">default</span>: <span class="function"><span class="params">()</span>=&gt;</span> createVNode(slot)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">const</span> context = vm.component?.proxy!;</span><br><span class="line">                <span class="comment">// Tips组件上下文 可以控制组件内部属性</span></span><br><span class="line">                <span class="comment">// setTimeout(()=&gt; &#123;</span></span><br><span class="line">                <span class="comment">//     context.msg = "改变显示文本";</span></span><br><span class="line">                <span class="comment">// &#125;, 1000)</span></span><br><span class="line">                <span class="comment">// 这个写法来自vue-next仓库issue-2097：https://github.com/vuejs/vue-next/issues/2097</span></span><br><span class="line">                <span class="keyword">if</span>(app._context) &#123;</span><br><span class="line">                    vm.appContext = app._context;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 样式scope获取</span></span><br><span class="line">                tipsDiv.setAttribute(Tips.__scopeId, <span class="string">""</span>)</span><br><span class="line">                render(vm, tipsDiv);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释一下前面的疑问：</p><ul><li><p>Vue3中没有了<code>Vue.extend</code>方法，我们可以使用<code>createVNode</code>方法来实现，它的类型如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">_createVNode</span>(<span class="params"><span class="keyword">type</span>: VNodeTypes | ClassComponent | <span class="keyword">typeof</span> NULL_DYNAMIC_COMPONENT, props?: (Data &amp; VNodeProps) | <span class="literal">null</span>, children?: unknown, patchFlag?: <span class="built_in">number</span>, dynamicProps?: <span class="built_in">string</span>[] | <span class="literal">null</span>, isBlockNode?: <span class="built_in">boolean</span></span>): <span class="title">VNode</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到它能够接受<code>ClassComponent</code>，并返回<code>VNode</code>，那么就可以直接将导入的组件扔进去，然后转换成<code>VNode</code>了，如图可以看到<code>VNode</code>对象中的属性，它是能拿到<code>component</code>实例的：</p><p><img src="/BeCoderQ.github.io/2021/05/25/Vue2-x与Vue3-x插件式全局组件写法对别/3.x-vnode.png" alt="图"></p><p>没错，这样就可以拿到上下文了，上面代码注释的那部分就可以响应式的修改组件内属性msg的值。</p><p>实际上，还可以用另一种写法：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = h(Tips, &#123;</span><br><span class="line">  key: <span class="built_in">Date</span>.now() + <span class="built_in">Math</span>.random(),</span><br><span class="line">  msg, </span><br><span class="line">  duration,</span><br><span class="line">  resolve</span><br><span class="line">&#125;, <span class="function"><span class="params">()</span>=&gt;</span> createVNode(slot));</span><br></pre></td></tr></table></figure><p>效果是一样的，都是最后使用<code>render</code>函数渲染。</p></li><li><p>第二个问题上面其实也解决了，<code>createVNode</code>函数也接受传入一个<code>VNode</code>类型的值（这里传入一个回调返回一个<code>VNode</code>）,这个值就是插槽了，对象的key就是具名插槽的name，默认插槽即为default。</p></li><li><p>最后，为啥不用v-if控制，原因其实是<code>createVNode</code>创造的组件并不会因为多次调用而生成多个真实的dom节点，这导致多次调用总是后面一个覆盖前面一个，注意，我是传了key的。因此只能在<code>$tips</code>中创建新的dom往根节点里面插。</p></li></ul><p>调用上，我利用hook做了一个简单的上下文映射：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hook */</span></span><br><span class="line"><span class="keyword">import</span> &#123; ComponentPublicInstance, getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useContext</span>(<span class="params"></span>): <span class="title">ComponentPublicInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; proxy: context &#125; = &lt;ProxyContext&gt;getCurrentInstance()</span><br><span class="line">    <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在vue文件中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, onMounted, ref &#125; from &quot;vue&quot;;</span><br><span class="line">  import &#123; useContext &#125; from &quot;@/hook/use-context&quot;;</span><br><span class="line">  // TextSlot组件是一个简单的文本组件，测试插槽功能。这里就不写了。</span><br><span class="line">  import TextSlot from &quot;./TextSlot.vue&quot;</span><br><span class="line">    export default defineComponent(&#123;</span><br><span class="line">        setup(props, &#123; attrs, emit &#125;) &#123;</span><br><span class="line">          // 上下文</span><br><span class="line">          const ctx = useContext();</span><br><span class="line">            onMounted(()=&gt; &#123;</span><br><span class="line">              ctx.$notification(&#123;</span><br><span class="line">                msg: &quot;测试22&quot;,</span><br><span class="line">                duration: 8000,</span><br><span class="line">                slot: TextSlot</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">              // 延迟一秒后再来一个</span><br><span class="line">              setTimeout(()=&gt; &#123;</span><br><span class="line">                ctx.$notification(&#123;</span><br><span class="line">                  msg: &quot;延迟一秒的&quot;,</span><br><span class="line">                  duration: 6000</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;, 3000)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>看一下效果：</p><p><img src="/BeCoderQ.github.io/2021/05/25/Vue2-x与Vue3-x插件式全局组件写法对别/3.x-notification.gif" alt="图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么会有区别&quot;&gt;&lt;a href=&quot;#为什么会有区别&quot; class=&quot;headerlink&quot; title=&quot;为什么会有区别&quot;&gt;&lt;/a&gt;为什么会有区别&lt;/h2&gt;&lt;p&gt;Vue2.x中我们使用&lt;code&gt;extend&lt;/code&gt;方法传入组件类得到可以被实例化的类，以此
      
    
    </summary>
    
    
      <category term="总结" scheme="http://localhost:4000/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue3" scheme="http://localhost:4000/tags/vue3/"/>
    
      <category term="插件" scheme="http://localhost:4000/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用JavaScript实现单双向链表</title>
    <link href="http://localhost:4000/2021/05/18/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://localhost:4000/2021/05/18/%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2021-05-18T07:52:08.000Z</published>
    <updated>2021-05-20T06:33:57.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表用来存储有序的元素集合，与数组不同，链表中的元素并非保存在连续的存储空间内，每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构成。当要移动或删除元素时，只需要修改相应元素上的指针就可以了。对链表元素的操作要比对数组元素的操作效率更高</p><p><img src="/BeCoderQ.github.io/2021/05/18/使用JavaScript实现单双向链表/linklist.png" alt="图"></p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>顾名思义这个链表是单向的，即它的指针只会指向下一个元素，于是我们可以定义一个单向链表的类：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现LinkList类，先看一下骨架：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPosIllegal</span>(<span class="params">pos, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; size - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 向链表添加元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkList&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    append(el) &#123;&#125;</span><br><span class="line">    <span class="comment">// @ts-check 在指定位置添加元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;boolean&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    insertAt(pos, el) &#123;&#125;</span><br><span class="line">    <span class="comment">// @ts-check 移除某元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    remove(el) &#123;&#125;</span><br><span class="line">    <span class="comment">// @ts-check 移除指定位置的元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    removeAt(pos) &#123;&#125;</span><br><span class="line">    <span class="comment">// @ts-check 返回传入元素的索引</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el </span></span><br><span class="line"><span class="comment">     * @returns &#123;number&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    indexOf(el) &#123;&#125;</span><br><span class="line">    <span class="comment">// @ts-check 传入索引返回元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getElementAt(pos) &#123;&#125;</span><br><span class="line">    <span class="comment">// @ts-check 链表长度</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @returns &#123;number&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">get</span> size() &#123;&#125;</span><br><span class="line">    <span class="comment">// 清除链表</span></span><br><span class="line">    clear() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表<code>LinkList</code>类会有一个<strong>head</strong>属性与<strong>length</strong>属性，前者为此链表的头部元素，后者为链表长度。首先，我们先实现getElementAt函数，因为后面很多函数都会使用它，然后实现append，它的逻辑比较简单。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// @ts-check 向链表添加元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkList&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    append(el) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> LinkNode(el);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，则添加的就是head 反之，添加到尾部</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> tailNode = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.length - <span class="number">1</span>);</span><br><span class="line">            tailNode.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 实现链式的调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 传入索引返回元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getElementAt(pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>getElementAt</code>中首先使用外部工具函数<code>isPosIllegal</code>判断传入索引是否合法，然后使用for循环不断的给变量<code>currentNode</code>赋值，直到达到传入的索引</li><li>对于<code>append</code>函数，功能为将传入元素插入到链表尾部，因此只需要判断当前链表是否为空，是直接赋值给head，反之拿到当前最后一个元素，将指针指向传入元素。</li></ul><p>接下来实现插入操作：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// @ts-check 向链表添加元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkList&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    append(el) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> LinkNode(el);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，则添加的就是head 反之，添加到尾部</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> tailNode = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.length - <span class="number">1</span>);</span><br><span class="line">            tailNode.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 实现链式的调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// @ts-check 在指定位置添加元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;boolean&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    insertAt(pos, el) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> LinkNode(el);</span><br><span class="line">        <span class="comment">// 寻找目标索引的上一个</span></span><br><span class="line">        <span class="keyword">if</span>(pos === <span class="number">0</span>) &#123;</span><br><span class="line">            node.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> prevNode = <span class="keyword">this</span>.getElementAt(pos - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            node.next = prevNode.next;</span><br><span class="line">            prevNode.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 传入索引返回元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getElementAt(pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于插入，我们要考虑一个特殊情况，就是插入头部，也很简单，插入头部直接替换head即可，其他情况包括索引多1的越界值都可以一起处理。接下来实现删除元素的函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// @ts-check 移除某元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    remove(el) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.indexOf(el);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index !== <span class="number">-1</span>) <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 移除指定位置的元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    removeAt(pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> targetNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pos === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">            targetNode = <span class="keyword">this</span>.head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> removeNode = <span class="keyword">this</span>.getElementAt(pos),</span><br><span class="line">            prevNode = <span class="keyword">this</span>.getElementAt(pos - <span class="number">1</span>);</span><br><span class="line">            prevNode.next = removeNode.next;</span><br><span class="line">            targetNode = removeNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> targetNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 传入索引返回元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getElementAt(pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下下面简陋的图：</p><p><img src="/BeCoderQ.github.io/2021/05/18/使用JavaScript实现单双向链表/remove_single.png" alt="图"></p><p>还是考虑删除第一个的特殊情况，很简单，head替换为下一个，其他情况需要首先拿到要删除的目标元素，然后将目标元素的上一个元素的指针指向目标元素下一个元素，以此实现删除效果。另一个remove方法就很简单了，传入目标元素，遍历链表拿到相同值的元素。这里只是简单处理了基本类型元素。</p><p>最后几个方法就很简单了，直接上完整版：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 向链表添加元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkList&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    append(el) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> LinkNode(el);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，则添加的就是head 反之，添加到尾部</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> tailNode = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.length - <span class="number">1</span>);</span><br><span class="line">            tailNode.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 在指定位置添加元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;boolean&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    insertAt(pos, el) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> LinkNode(el);</span><br><span class="line">        <span class="comment">// 寻找目标索引的上一个</span></span><br><span class="line">        <span class="keyword">if</span>(pos === <span class="number">0</span>) &#123;</span><br><span class="line">            node.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> prevNode = <span class="keyword">this</span>.getElementAt(pos - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            node.next = prevNode.next;</span><br><span class="line">            prevNode.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 移除某元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    remove(el) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(currentNode.element === el) <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(i);</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 移除指定位置的元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    removeAt(pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> targetNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pos === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">            targetNode = <span class="keyword">this</span>.head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> removeNode = <span class="keyword">this</span>.getElementAt(pos),</span><br><span class="line">            prevNode = <span class="keyword">this</span>.getElementAt(pos - <span class="number">1</span>);</span><br><span class="line">            prevNode.next = removeNode.next;</span><br><span class="line">            targetNode = removeNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> targetNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 返回传入元素的索引</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el </span></span><br><span class="line"><span class="comment">     * @returns &#123;number&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    indexOf(el) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(currentNode.element === el) <span class="keyword">return</span> i;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 传入索引返回元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;LinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getElementAt(pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 链表长度</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @returns &#123;number&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">get</span> size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除链表</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行起来看看：</p><ul><li><p>插入：<img src="/BeCoderQ.github.io/2021/05/18/使用JavaScript实现单双向链表/insert_test.png" alt="图"></p></li><li><p>删除：<img src="/BeCoderQ.github.io/2021/05/18/使用JavaScript实现单双向链表/remove_test.png" alt="图"></p></li></ul><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="/BeCoderQ.github.io/2021/05/18/使用JavaScript实现单双向链表/db_linklist.png" alt="图"><br>双向链表与单向链表相比，还多了一个只想前一个元素的指针，我用<code>prev</code>表示，我们可以继承单向链表，重写部分方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表元素实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbLinkNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkList</span> <span class="keyword">extends</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    append(el) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> DbLinkNode(el);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">            <span class="keyword">this</span>.tail = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">            node.prev = <span class="keyword">this</span>.tail;</span><br><span class="line">            <span class="keyword">this</span>.tail = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 移除指定位置的元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;DbLinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    removeAt(pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> targetNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(pos) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">                targetNode = <span class="keyword">this</span>.head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">this</span>.length - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">this</span>.tail = <span class="keyword">this</span>.tail.prev;</span><br><span class="line">                targetNode = <span class="keyword">this</span>.tail;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 拿到要删除的元素，通过它又能拿到前一个元素与后一个元素</span></span><br><span class="line">                targetNode = <span class="keyword">this</span>.getElementAt(pos);</span><br><span class="line">                <span class="keyword">let</span> nextNode = targetNode.next,</span><br><span class="line">                    prevNode = targetNode.prev;</span><br><span class="line">                </span><br><span class="line">                prevNode.next = nextNode;</span><br><span class="line">                nextNode.prev = prevNode;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> targetNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @param &#123;any&#125; el</span></span><br><span class="line"><span class="comment">     * @return &#123;boolean&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    insertAt(pos, el) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> DbLinkNode(el);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(pos) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment">// 插入头部 考虑空链表与非空链表两种状态</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = node;</span><br><span class="line">                    <span class="keyword">this</span>.tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = <span class="keyword">this</span>.head;</span><br><span class="line">                    <span class="keyword">this</span>.head.prev = node;</span><br><span class="line">                    <span class="keyword">this</span>.head = node;   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;     </span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">this</span>.length:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.append(el);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 判断离头部近，还是尾部近，前者直接复用单链表方法</span></span><br><span class="line">                <span class="keyword">if</span>(pos &gt; <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.length / <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="keyword">let</span> targetNode = <span class="keyword">this</span>.getElementAt(pos),</span><br><span class="line">                        prevNode = targetNode.prev;</span><br><span class="line">                    <span class="comment">// 插入元素的下一个即是插入前所在此索引的元素        </span></span><br><span class="line">                    node.next = targetNode;</span><br><span class="line">                    node.prev = prevNode;</span><br><span class="line">                    targetNode.prev = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.insertAt(pos, el);</span><br><span class="line">                &#125;        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @ts-check 传入索引返回元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;number&#125; pos</span></span><br><span class="line"><span class="comment">     * @return &#123;DbLinkNode | null&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getElementAt(pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPosIllegal(pos, <span class="keyword">this</span>.length)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(pos) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">this</span>.length - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.tail;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 判断离头部近，还是尾部近，前者直接复用单链表方法</span></span><br><span class="line">                <span class="keyword">if</span>(pos &gt; <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.length / <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="keyword">let</span> currentNode = <span class="keyword">new</span> DbLinkNode();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="keyword">this</span>.length - <span class="number">1</span>; i &gt; pos; i--) &#123;</span><br><span class="line">                        currentNode = currentNode.prev;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> currentNode;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.getElementAt(pos);</span><br><span class="line">                &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实现的基础版本，不算复杂，这里直接代码全上了，有几个需要注意的点：</p><ul><li><code>getElement</code>：因为一个元素可以知道前一个与后一个，因此<code>getElementAt</code>函数可以不必全遍历，可以先判断传入的索引信息是离头近还是离尾巴近，这样可以减少时间复杂度，并且如果是前者我们可以直接调用基类，也就是单向链表的<code>getElement</code>方法。</li><li><code>removeAt</code>：需要考虑三种情况，即头部和尾部以及其他。</li><li><code>insertAt</code>：本质上还是三种情况，不过插入头部时我们要判断一下是否当前是空链表，尾部的情况可以直接调用<code>append</code>方法，其他情况类似<code>getElement</code>方法，通过判断离头部近还是尾部近，可以复用基类的方法。</li></ul><p>运行看看：</p><ul><li>插入：<img src="/BeCoderQ.github.io/2021/05/18/使用JavaScript实现单双向链表/db_insert_test.png" alt="图"></li><li>删除：<img src="/BeCoderQ.github.io/2021/05/18/使用JavaScript实现单双向链表/db_remove_test.png" alt="图"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于数组和链表，总结以下优缺点：</p><ul><li>数组可以利用下标快速找到元素，但因为数组是连续的，所以在插入与删除元素时会移动其他元素。</li><li>链表是不连续的，因此插入与删除的效率高，内存利用率更高，但是查找效率会比数组低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt;链表用来存储有序的元素集合，与数组不同，链表中的元素并非保存在连续的存储空间内，每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构
      
    
    </summary>
    
    
      <category term="总结" scheme="http://localhost:4000/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="数据结构，链表" scheme="http://localhost:4000/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>借助babel的AST解析，让老代码重获新生(转载)</title>
    <link href="http://localhost:4000/2021/04/24/%E5%80%9F%E5%8A%A9babel%E7%9A%84AST%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%AE%A9%E8%80%81%E4%BB%A3%E7%A0%81%E9%87%8D%E8%8E%B7%E6%96%B0%E7%94%9F-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://localhost:4000/2021/04/24/%E5%80%9F%E5%8A%A9babel%E7%9A%84AST%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%AE%A9%E8%80%81%E4%BB%A3%E7%A0%81%E9%87%8D%E8%8E%B7%E6%96%B0%E7%94%9F-%E8%BD%AC%E8%BD%BD/</id>
    <published>2021-04-24T07:12:36.000Z</published>
    <updated>2021-05-14T09:24:57.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在最近的工作中，接手了一个古老的项目，其中的 JS 代码是一整坨的面条代码，约 3000 行的代码全写在一个文件里，维护起来着实让人头疼。</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图1.png" alt="图"></p><p>想不通为啥之前维护项目的同学能够忍受这么难以维护的代码……既然现在这个锅被我拿下了，怎么着也不能容忍如此丑陋的代码继续存在着，必须把它优化一下。</p><p>横竖看了半天，由于逻辑都揉在了一个文件里，看都看得眼花缭乱，当务之急便是把它进行模块化拆分，把这一大坨面条状代码拆分成一个个模块并抽离成文件，这样才方便后续的持续优化。</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p>说干就干，既然要拆分成模块，首先就要分析源码的结构。虽然源码内容很长很复杂，但万幸的是它还是有一个清晰的结构，简化一下，就是下面这种形式：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图2.png" alt="图"></p><p>很容易看出，这是一种 ES5 时代的经典代码组织方式，在一个 IIFE 里面放一个构造函数，在构造函数的 <code>protorype</code> 上挂载不同的方法，以实现不同的功能。既然代码结构是清晰的，那么我们要做模块化的思路也很清晰，就是想办法把所有绑定在构造函数的 <code>prototype</code> 上的方法抽离出来，以模块文件的形式放置，而源码则使用 ES6 的 <code>import</code> 语句把模块引入进来，完成代码的模块化：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图3.png" alt="图"></p><p>为了完成这个效果，我们可以借助 <code>@babel</code> 全家桶来构造我们的转化脚本。</p><h2 id="利用AST分析代码结构"><a href="#利用AST分析代码结构" class="headerlink" title="利用AST分析代码结构"></a>利用AST分析代码结构</h2><p>关于 AST 的相关资料一搜一大堆，在这里就不赘述了。在本文中，我们会借助 AST 去分析源码，挑选源码中需要被抽离、改造的部分，因此 AST 可以说是本文的核心。在 <a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net/</a> 这个网站，我们可以贴入示例代码，在线查看它的 AST 长什么样：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图4.png" alt="图"></p><p>从右侧的 AST 树中可以很清晰地看到， <code>Demo.prototype.func=function(){}</code> 属于 <code>AssignmentExpression</code> 节点，即为“赋值语句”，拥有左右两个不同的节点（ <code>left</code>， <code>right</code>）。</p><p>由于一段 JS 代码里可能存在多种赋值语句，而我们只想处理形如 <code>Demo.prototype.func=function(){}</code> 的情况，所以我们需要继续对其左右两侧的节点进行深入分析。</p><p>首先看左侧的节点，它属于一个“MemberExpression”，其特征如下图箭头所示：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图5.png" alt="图"></p><p>对于左侧的节点，只要它的 <code>object.property.name</code> 的值为 <code>prototype</code> 即可，那么对应的函数名就是该节点的 <code>property.name</code>。</p><p>接着看右侧的节点，它属于一个“FunctionExpression”：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图6.png" alt="图"></p><p>我们要做的，就是把它提取出来作为一个独立的文件。</p><p>分析完了 AST 以后，我们已经知道需要被处理的代码都有一些什么样的特征，接下来就是针对这些特征进行操作了，这时候就需要我们的 <code>@babel</code> 全家桶出场了！</p><h2 id="处理代码"><a href="#处理代码" class="headerlink" title="处理代码"></a>处理代码</h2><p>首先我们需要安装四个工具，它们分别是：</p><ul><li><code>@babel/parser</code>：用于把 JS 源码转化成 AST；</li><li><code>@babel/traverse</code>：用于遍历 AST 树，获取当中的节点内容；</li><li><code>@babel/generator</code>：把 AST 节点转化成对应的 JS 代码；</li><li><code>@babel/types</code>：新建 AST 节点。</li></ul><p>接下来新建一个 <code>index.js</code> 文件，引入上面四个工具，并设法加载我们的源码（源码为 <code>demo/es5code.js</code>）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</span><br><span class="line">&#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>),</span><br><span class="line">      parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>),</span><br><span class="line">traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).defaultconst, </span><br><span class="line">      generator = <span class="built_in">require</span>(<span class="string">'@babel/generator'</span>).defaultconst, </span><br><span class="line">      t = <span class="built_in">require</span>(<span class="string">'@babel/types'</span>);</span><br><span class="line"><span class="keyword">const</span> INPUT_CODE = resolve(__dirname, <span class="string">'../demo/es5code.js'</span>);</span><br><span class="line"><span class="keyword">const</span> code = fs.readFileSync(<span class="string">`<span class="subst">$&#123;INPUT_CODE&#125;</span>`</span>, <span class="string">'utf-8'</span>);</span><br></pre></td></tr></table></figure><p>接着使用 <code>@babel/parser</code> 获取源码的 AST：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = parser.parse(code)</span><br></pre></td></tr></table></figure><p>拿到 AST 以后，就可以使用 <code>@babel/traverse</code> 来遍历它的节点。从上一节的 AST 分析可以知道，我们只需要关注“AssignmentExpression”节点即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;  AssignmentExpression (&#123; node &#125;) &#123;    <span class="comment">/* ... */</span>  &#125;&#125;)</span><br></pre></td></tr></table></figure><p>当前节点即为参数 <code>node</code>，我们需要分析它左右两侧的节点。只有当左侧节点的类型为“MemberExpression”且右侧节点的类型为“FunctionExpression”才需要进入下一步分析（因为形如 <code>a=1</code> 之类的节点也属于 AssignmentExpression 类型，不在我们的处理范围内）。</p><p>由于 JS 中可能存在不同的 MemberExpression 节点，如 <code>a.b.c=function(){}</code>，但我们现在只需要处理 <code>a.prototype.func</code> 的情况，意味着要盯着关键字 <code>prototype</code>。通过分析 AST 节点，我们知道这个关键字位于左侧节点的 <code>object.property.name</code> 属性中：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图7.png" alt="图"></p><p>同时对应的函数名则藏在左侧节点的 <code>property.name</code> 属性中：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图8.png" alt="图"></p><p>因此便可以很方便地提取出<strong>方法名</strong>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123; </span><br><span class="line">    AssignmentExpression(&#123; node &#125;) &#123; </span><br><span class="line">        <span class="keyword">const</span> &#123; left, right &#125; = node; </span><br><span class="line">        <span class="keyword">if</span> (left.type === <span class="string">'MemberExpression'</span> &amp;&amp; right.type === <span class="string">'FunctionExpression'</span>) &#123; </span><br><span class="line">            <span class="keyword">const</span> &#123; object, property &#125; = left; </span><br><span class="line">            <span class="keyword">if</span> (object.property.name === <span class="string">'prototype'</span>) &#123; </span><br><span class="line">                <span class="keyword">const</span> funcName = property.name; </span><br><span class="line">                <span class="built_in">console</span>.log(funcName) </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以很方便地把方法名打印出来检查：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图9.png" alt="图"></p><p>现在我们已经分析完左侧节点的代码，提取出了方法名。接下来则是处理右侧节点。由于右侧代码直接就是一个 FunctionExpression 节点，因此我们要做的就是通过 <code>@babel/generator</code> 把该节点转化成 JS 代码，并写入文件。</p><p>此外，我们也要把原来的代码从 <code>Demo.prototype.func=function(){}</code> 转化成 <code>Demo.prototype.func=func</code> 的形式，因此右侧的节点需要从“FuncitionExpression”类型转化成“Identifier”类型，我们可以借助 <code>@babel/types</code> 来处理。</p><p>还有一个事情别忘了，就是我们已经把右侧节点的代码抽离成了 JS 文件，那么我们也应该在最终改造完的源文件里把它们给引入进来，形如 <code>importfunc1from&#39;./func1&#39;</code>这种形式，因此可以继续使用 <code>@babel/types</code> 的 <code>importDeclaration()</code> 函数来生成对应的代码。这个函数参数比较复杂，可以封装成一个函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImportDeclaration</span>(<span class="params">funcName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.importDeclaration(</span><br><span class="line">        [t.importDefaultSpecifier(t.identifier(funcName))], </span><br><span class="line">        t.stringLiteral(<span class="string">`./<span class="subst">$&#123;funcName&#125;</span>`</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要传入一个 <code>funcName</code>，就可以生成一段 <code>importfuncNamefrom&#39;./funcName&#39;</code> 代码。</p><p>最终整体代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</span><br><span class="line">    &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>),</span><br><span class="line">    parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>),</span><br><span class="line">    traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).defaultconst,</span><br><span class="line">    generator = <span class="built_in">require</span>(<span class="string">'@babel/generator'</span>).defaultconst,</span><br><span class="line">    t = <span class="built_in">require</span>(<span class="string">'@babel/types'</span>);</span><br><span class="line"><span class="keyword">const</span> INPUT_CODE = resolve(__dirname, <span class="string">'../demo/es5code.js'</span>);</span><br><span class="line"><span class="keyword">const</span> code = fs.readFileSync(<span class="string">`<span class="subst">$&#123;INPUT_CODE&#125;</span>`</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFile</span>(<span class="params">filename, code</span>) </span>&#123; </span><br><span class="line">    fs.writeFileSync(<span class="string">`<span class="subst">$&#123;OUTPUT_FOLDER&#125;</span>/<span class="subst">$&#123;filename&#125;</span>.js`</span>, code, <span class="string">'utf-8'</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImportDeclaration</span>(<span class="params">funcName</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.importDeclaration(</span><br><span class="line">        [t.importDefaultSpecifier(t.identifier(funcName))], t.stringLiteral(<span class="string">`./<span class="subst">$&#123;funcName&#125;</span>`</span>)</span><br><span class="line">    ); </span><br><span class="line">&#125;</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">    AssignmentExpression(&#123; node &#125;) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; left, right &#125; = node; <span class="keyword">if</span> (left.type === <span class="string">'MemberExpression'</span> &amp;&amp; right.type === <span class="string">'FunctionExpression'</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; object, property &#125; = left; <span class="keyword">if</span> (object.property.name === <span class="string">'prototype'</span>) &#123;            <span class="comment">// 获取左侧节点的方法名</span></span><br><span class="line">                <span class="keyword">const</span> funcName = property.name;</span><br><span class="line">                <span class="comment">// 获取右侧节点对应的 JS 代码        </span></span><br><span class="line">                <span class="keyword">const</span> &#123; <span class="attr">code</span>: funcCode &#125; = generator(right);</span><br><span class="line">                <span class="comment">// 右侧节点改为 Identifier        </span></span><br><span class="line">                <span class="keyword">const</span> replacedNode = t.identifier(funcName);</span><br><span class="line">                node.right = replacedNode</span><br><span class="line">                <span class="comment">// 借助 `fs.writeFileSync()` 把右侧节点的 JS 代码写入外部文件        </span></span><br><span class="line">                createFile(funcName, <span class="string">'export default '</span> + funcCode);</span><br><span class="line">                <span class="comment">// 在文件头部引入抽离的文件        </span></span><br><span class="line">                ast.program.body.unshift(createImportDeclaration(funcName))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><p>在我们的项目目录中，其结构如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.├──</span> <span class="string">demo│</span>   <span class="string">└──</span> <span class="string">es5code.js├──</span> <span class="string">output├──</span> <span class="string">package.json└──</span> <span class="string">src</span>    <span class="string">└──</span> <span class="string">index.js</span></span><br></pre></td></tr></table></figure><p>运行脚本， <code>demo/es5code.js</code> 的代码将会被处理，然后输出到 <code>output</code> 目录：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.├──</span> <span class="string">demo│</span>   <span class="string">└──</span> <span class="string">es5code.js├──</span> <span class="string">output│</span>   <span class="string">├──</span> <span class="string">es6code.js│</span>   <span class="string">├──</span> <span class="string">func1.js│</span>   <span class="string">├──</span> <span class="string">func2.js│</span>   <span class="string">└──</span> <span class="string">func3.js├──</span> <span class="string">package.json└──</span> <span class="string">src</span>    <span class="string">└──</span> <span class="string">index.js</span></span><br></pre></td></tr></table></figure><p>运行前后代码：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图10.png" alt="图"></p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图11.png" alt="图"></p><p>大功告成！把脚本运用到我们的项目中，甚至可以发现原来的约 3000 行代码，已经被整理成了 300 多行：</p><p><img src="/BeCoderQ.github.io/2021/04/24/借助babel的AST解析，让老代码重获新生-转载/图12.png" alt="图"></p><p>放到真实环境去跑一遍这段代码，原有功能不受影响！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在最近的工作中，接手了一个古老的项目，其中的 JS 代码是一整坨的面条代码，约 3000 行的代码全写在一个文件里，维护起来着实让人头疼。&lt;
      
    
    </summary>
    
    
      <category term="学习" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="babel" scheme="http://localhost:4000/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>从零开始使用flutter开发一款本地阅读器</title>
    <link href="http://localhost:4000/2021/03/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8flutter%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%9C%AC%E5%9C%B0%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    <id>http://localhost:4000/2021/03/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8flutter%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E6%9C%AC%E5%9C%B0%E9%98%85%E8%AF%BB%E5%99%A8/</id>
    <published>2021-03-03T05:20:04.000Z</published>
    <updated>2021-03-08T02:36:06.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>在写这篇博客的时候这个app实际开发时长已经零零碎碎有半个多月了，都是利用下班以及周末的时间开发，确实遇到了非常非常多的问题，还包括一些到现在(21年3月3日)还未解决的疑难杂症，虽然没人看，不过后期会持续更新。</p><h2 id="用到的库"><a href="#用到的库" class="headerlink" title="用到的库"></a>用到的库</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">dio:</span> <span class="string">^3.0.9</span></span><br><span class="line">  <span class="attr">shared_preferences:</span> <span class="string">^0.5.12+4</span></span><br><span class="line">  <span class="attr">path_provider:</span> <span class="string">^1.6.24</span></span><br><span class="line">  <span class="attr">intl:</span> <span class="string">^0.16.1</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">^4.3.2+3</span></span><br><span class="line">  <span class="attr">permission_handler:</span> <span class="string">^5.0.1+1</span></span><br><span class="line">  <span class="attr">gbk2utf8:</span> <span class="string">^1.0.1</span></span><br><span class="line">  <span class="attr">fluttertoast:</span> <span class="string">^7.1.6</span></span><br><span class="line">  <span class="attr">file_picker:</span> <span class="string">^2.1.4</span></span><br><span class="line">  <span class="attr">screen:</span> <span class="string">^0.0.5</span></span><br><span class="line">  <span class="attr">event_bus:</span> <span class="string">^1.1.1</span></span><br><span class="line">  <span class="attr">get_ip:</span> <span class="string">^0.4.0</span></span><br></pre></td></tr></table></figure><h2 id="最初遇到的问题"><a href="#最初遇到的问题" class="headerlink" title="最初遇到的问题"></a>最初遇到的问题</h2><p>这个阅读器我构想的时候就只打算解析txt文本，本想txt文本解析应该很简单，但很快我便遇到了一堆问题。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/BeCoderQ.github.io/2021/03/03/从零开始使用flutter开发一款本地阅读器/structure.png" alt="插件"></p><p>lib文件中分的包有点多，我把一些高服用的控件放到了<code>widgets</code>文件，页面以及其相关耦合度高的控件放到<code>pages</code>文件夹内，其实基本和主流的分包差不多，比较特殊的是<code>layout</code>文件内，可以先看一下app的界面:</p><p><img src="/BeCoderQ.github.io/2021/03/03/从零开始使用flutter开发一款本地阅读器/home.png" alt="插件"></p><p>当然还只是一个demo，不过结构确定了：底部的舵式导航分别是本地书架、在线书城、个人页面。于是乎我将tabbar独立出来，就像React与Vue中的嵌套路由(nested router)一样使用，代码大概是这样：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/cupertino.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:simple_reader/pages/bookshelf/bookshelf_page.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:simple_reader/pages/mine/mine_page.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:simple_reader/pages/online/online_page.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState()=&gt; _LayoutState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LayoutState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Layout</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> activePage = <span class="number">0</span>;</span><br><span class="line">PageController _pageController = PageController(initialPage: <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 底部导航栏</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;BottomNavigationBarItem&gt; bottomNavItems = [</span><br><span class="line">BottomNavigationBarItem(</span><br><span class="line">icon: Icon(Icons.offline_bolt),</span><br><span class="line">      label: <span class="string">""</span></span><br><span class="line">),</span><br><span class="line">BottomNavigationBarItem(</span><br><span class="line">icon: Icon(Icons.whatshot),</span><br><span class="line">      label: <span class="string">""</span></span><br><span class="line">),</span><br><span class="line">BottomNavigationBarItem(</span><br><span class="line">icon: Icon(Icons.person),</span><br><span class="line">label: <span class="string">""</span></span><br><span class="line">)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 滑动pageView组件切换页面</span></span><br><span class="line"><span class="keyword">void</span> _onPageChange(<span class="built_in">int</span> index) &#123;</span><br><span class="line">setState(() &#123;</span><br><span class="line">activePage = index;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line"><span class="keyword">void</span> dispose() &#123;</span><br><span class="line">_pageController.dispose();</span><br><span class="line"><span class="keyword">super</span>.dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      backgroundColor: Theme.of(context).backgroundColor,</span><br><span class="line">      body: PageView(</span><br><span class="line">        children: [Bookshelf(), Online(), Mine()],</span><br><span class="line">        controller: _pageController,</span><br><span class="line">        onPageChanged: _onPageChange,</span><br><span class="line">      ),</span><br><span class="line">      bottomNavigationBar: SizedBox(</span><br><span class="line">        child: BottomNavigationBar(</span><br><span class="line">          <span class="comment">// backgroundColor: Theme.of(context).primaryColor,</span></span><br><span class="line">          backgroundColor: Colors.white,</span><br><span class="line">          items: bottomNavItems,</span><br><span class="line">          currentIndex: activePage,</span><br><span class="line">          type: BottomNavigationBarType.fixed, </span><br><span class="line">          showSelectedLabels: <span class="keyword">false</span>,</span><br><span class="line">          showUnselectedLabels: <span class="keyword">false</span>,</span><br><span class="line">          fixedColor: Colors.cyan, <span class="comment">// 选中的颜色</span></span><br><span class="line">          onTap: (index) &#123;</span><br><span class="line">            _pageController.jumpToPage(index);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本的编码问题"><a href="#文本的编码问题" class="headerlink" title="文本的编码问题"></a>文本的编码问题</h3><p>用户从网络下载的虽然都是txt文本，但是编码却有可能不一样，中文小说最常见的可能是utf-8、gbk2312，而查看flutter的文本解析源码会发现官方并没有提供gbk2312的编码解析，这也导致了直接将File类直接调用readAsLines等方法会有乱码。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>这个问题属实有点硬核，不过好在大佬是比较多的，github上一位大神自己写了一套gbk2312的解析库<code>gbk2utf8</code>：<a href="https://github.com/best-flutter/gbk2utf8。" target="_blank" rel="noopener">https://github.com/best-flutter/gbk2utf8。</a></p><h3 id="解析文本导致卡顿"><a href="#解析文本导致卡顿" class="headerlink" title="解析文本导致卡顿"></a>解析文本导致卡顿</h3><p>每次点击书籍进入，目前是根据存储的路径获取文件来按行读取：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lineText = <span class="keyword">await</span> file.readAsLines();</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// 如果文本以utf8解码出错，那么就按gbk格式解码</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; bytes = <span class="keyword">await</span> file.readAsBytes();</span><br><span class="line">  lineText = gbk.decode(bytes).split(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我会获取全文按换行来分割，这样的好处是能轻松的拿到章节。不过文章太长了，如一篇四五百万字的文章时，点击后明显就会卡1秒，这个使用体验是非常糟糕的。</p><p><img src="/BeCoderQ.github.io/2021/03/03/从零开始使用flutter开发一款本地阅读器/calcTime.png" alt="插件"></p><p>可以看到解析一个330万字的小说需要耗时700ms，非常耗时。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>Dart和JavaScript一样是一门单线程语言，同样是熟悉的Event Loop，MicroTask。就算我们使用Future异步来解析文本，他本质上还是在一个线程上跑，因此使用简单的异步是解决不了问题的，那么就要引入Dart中的”多线程”概念：<code>isolate</code>:<strong>「Isolate」在 Flutter 中并不共享内存。不同「Isolate」之间通过「消息」进行通信。</strong>需要注意的是isolate传入的回调函数必须是top-level，即不能是class内部的，但可以是静态函数。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新线程的回调函数必须是顶层函数 top-level 或者静态函数 static function of an instance</span></span><br><span class="line">Future&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ChapterTextDictionary&gt;&gt; getText(<span class="built_in">String</span> path) <span class="keyword">async</span> &#123;</span><br><span class="line">  FileToArticle fileInfo = <span class="keyword">await</span> FileOperate.getFile(path);</span><br><span class="line">  <span class="keyword">return</span> fileInfo.chapterTextDictionary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">xxx</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 开辟子线程解析文本</span></span><br><span class="line">  Future&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ChapterTextDictionary&gt;&gt; _isolateGetText() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(isLoaded) <span class="keyword">return</span> chapterTextDictionary;</span><br><span class="line">    isLoaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 这里的compute即是isolate，在不需要多个isolate通信时直接使用compute更简单</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ChapterTextDictionary&gt; response = <span class="keyword">await</span> compute(getText, widget.book.path);</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// 此书的正文与章节</span></span><br><span class="line">      chapterTextDictionary = response;</span><br><span class="line">      <span class="comment">// 初始化菜单列表</span></span><br><span class="line">      chapterList = chapterTextDictionary.keys.toList();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 正文总章节数</span></span><br><span class="line">    widget.book.totalChapters = chapterList.length;</span><br><span class="line">    brightness = <span class="keyword">await</span> Screen.brightness;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然解析时间没变 ，但大量的解析工作已经不会影响app的其他操作了。可以加上一个动画来提升体验。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由的缩放动画</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ZoomRoute</span> <span class="keyword">extends</span> <span class="title">PageRouteBuilder</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget widget;</span><br><span class="line">   ZoomRoute(<span class="keyword">this</span>.widget):<span class="keyword">super</span>(</span><br><span class="line">    transitionDuration:<span class="built_in">Duration</span>(milliseconds: <span class="number">1500</span>),</span><br><span class="line">    pageBuilder:(</span><br><span class="line">       BuildContext context,</span><br><span class="line">        Animation&lt;<span class="built_in">double</span>&gt;animation1,</span><br><span class="line">        Animation&lt;<span class="built_in">double</span>&gt;animation2,</span><br><span class="line">    )&#123;</span><br><span class="line">      <span class="keyword">return</span> widget;</span><br><span class="line">    &#125;,</span><br><span class="line">    transitionsBuilder:(</span><br><span class="line">     BuildContext context,</span><br><span class="line">      Animation&lt;<span class="built_in">double</span>&gt;animation1,</span><br><span class="line">      Animation&lt;<span class="built_in">double</span>&gt;animation2,</span><br><span class="line">       Widget child</span><br><span class="line">    )&#123;</span><br><span class="line">       <span class="comment">// 缩放的效果</span></span><br><span class="line">     <span class="keyword">return</span> ScaleTransition(</span><br><span class="line">        scale: Tween(</span><br><span class="line">            begin: <span class="number">0.0</span>,end: <span class="number">1.0</span>).animate(CurvedAnimation(</span><br><span class="line">            parent: animation1,</span><br><span class="line">            curve: Curves.fastOutSlowIn</span><br><span class="line">        )),</span><br><span class="line">        child: child,</span><br><span class="line">      );</span><br><span class="line">     &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个阅读app的开发记录将作为一个系列来写，阅读app难点就是文本的解析，分页计算，各种阅读记录，本文还没讲到，另外关于点开某本本地书籍后，是否该每次都解析整本书，我并没有找到一个准确的答案，大量解析耗费资源，哪怕是使用isloate，也无法解决时间问题，但是不解析全文，当用户通过目录随意跳动时，如何处理？这些问题在后续开发过程中我也会去研究，不过目前来看似乎很多app都是每次都重新解析全文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;杂谈&quot;&gt;&lt;a href=&quot;#杂谈&quot; class=&quot;headerlink&quot; title=&quot;杂谈&quot;&gt;&lt;/a&gt;杂谈&lt;/h2&gt;&lt;p&gt;在写这篇博客的时候这个app实际开发时长已经零零碎碎有半个多月了，都是利用下班以及周末的时间开发，确实遇到了非常非常多的问题，还包括一些到现
      
    
    </summary>
    
    
      <category term="记录" scheme="http://localhost:4000/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="flutter" scheme="http://localhost:4000/tags/flutter/"/>
    
      <category term="dart" scheme="http://localhost:4000/tags/dart/"/>
    
      <category term="android" scheme="http://localhost:4000/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>typescript正确食用姿势之集成pont-engine白嫖后端</title>
    <link href="http://localhost:4000/2021/01/01/typescript%E6%AD%A3%E7%A1%AE%E9%A3%9F%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%B9%8B%E9%9B%86%E6%88%90pont-engine%E7%99%BD%E5%AB%96%E5%90%8E%E7%AB%AF/"/>
    <id>http://localhost:4000/2021/01/01/typescript%E6%AD%A3%E7%A1%AE%E9%A3%9F%E7%94%A8%E5%A7%BF%E5%8A%BF%E4%B9%8B%E9%9B%86%E6%88%90pont-engine%E7%99%BD%E5%AB%96%E5%90%8E%E7%AB%AF/</id>
    <published>2021-01-01T06:53:25.000Z</published>
    <updated>2021-03-08T02:38:48.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目环境介绍"><a href="#项目环境介绍" class="headerlink" title="项目环境介绍"></a>项目环境介绍</h2><p>公司项目全线上了vue3，因此前端框架还是vue3，脚手架由vite改回了vue.cli4，原因还是部分库的兼容性问题➕打包后的一些大大小小的问题。主要的技术栈如下</p><ul><li><p>Vue 3.x</p></li><li><p>Typescript 4.0.5</p></li><li><p>Vuex 4.x</p></li><li><p>VueRouter 4.x</p></li><li><p>端到端测试工具Cypress</p></li><li><p>Swagger接口生成工具pont-engine。</p></li></ul><h2 id="Pont-engine"><a href="#Pont-engine" class="headerlink" title="Pont-engine"></a>Pont-engine</h2><p>Pont-engine是阿里出的一个解决前后端数据服务层的一个库，仓库地址: <a href="https://github.com/alibaba/pont" target="_blank" rel="noopener">https://github.com/alibaba/pont</a>  这个库的原理实际就是爬取swagger的数据然后生成前端的接口，并且支持高度自定义，而且他的源码非常易读，可以说能实现绝绝绝大多数的项目需求。当然前提是后端的同学必须用swagger，具体细节可以看仓库介绍，这里我只说一下安装流程和我的封装。</p><h2 id="使用Pont"><a href="#使用Pont" class="headerlink" title="使用Pont"></a>使用Pont</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我是使用的npm管理包，所以首先全局安装pont: <code>npm i -g pont-engine</code></p><p>接下来如果你使用的vscode 那么就非常简单了，直接在插件商城搜pont，安装之后底部就会有如下选项</p><p><img src="/BeCoderQ.github.io/2021/01/01/typescript正确食用姿势之集成pont-engine白嫖后端/plugin.png" alt="插件"></p><ul><li><p>sync: 重新请求远程接口数据，重新计算本地接口数据和远程接口数据在接口模块和接口返回对象（基类）上的差异。</p></li><li><p>all: 将本地所有接口模块、接口返回对象与远程已更新数据保持一致。</p></li><li><p>mod: 选择并同步本地接口模块，与远程接口数据保持一致。点击插件的 mod(差异量) 后，插件将显示本地与远程数据有差异的模块</p></li><li><p>bo: 选择并同步本地基类，与远程接口数据保持一致。点击插件的 bo(差异量) 后，插件将显示本地与远程数据有差异的基类</p></li><li><p>generate: 以本地接口模块、基类生成接口层代码。</p></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>有几个重要的文件：</p><p><img src="/BeCoderQ.github.io/2021/01/01/typescript正确食用姿势之集成pont-engine白嫖后端/config.png" alt="插件"></p><ul><li>pont-config.json中配置基本的信息，如爬取swagger接口文件的地址，你的模板文件的位置，生成的代码的位置</li><li>pont-template.ts是你自定义生产代码的模板文件，名称当然是可以自己随便取的，不过记得在config文件中同步</li><li>pont-transform这个文件会在转换json前调用里面的回调，具体使用可以查看官方文档</li></ul><h3 id="生成代码的目录"><a href="#生成代码的目录" class="headerlink" title="生成代码的目录"></a>生成代码的目录</h3><p><img src="/BeCoderQ.github.io/2021/01/01/typescript正确食用姿势之集成pont-engine白嫖后端/apitree.png" alt="api目录"></p><p>mods代表models，这些其实是后端的同学分的，几个index.ts作为导出的文件。api.d.ts中有供全局使用的类型。调用方式<code>defs.xxx</code></p><p>实际上官方默认你会用<code>API.请求Library.模块.模块请求函数</code>来发起请求，但说实话我感觉太长了，点了一大堆，因此我的使用是把所有模块全部拆开按需导入然后直接<code>模块.userInfoRequest()</code>这样发起请求。</p><h2 id="配置模板代码"><a href="#配置模板代码" class="headerlink" title="配置模板代码"></a>配置模板代码</h2><p>这一步其实才是最重要的，因为每个人每个公司项目结构需求都不同，接口请求的方式也是“千奇百怪”，我们可以在模板中继承pont暴露出来的<code>CodeGenerator</code>类来重写一些生成代码的函数，下面会介绍几个官方没有详细说明，但很重要的基类函数。</p><h3 id="getInterfaceContent函数"><a href="#getInterfaceContent函数" class="headerlink" title="getInterfaceContent函数"></a>getInterfaceContent函数</h3><p>这个当然不属于官方没有介绍的函数，这个在官网的demo中有，是最重要的一个方法，他返回的模板字符串会生成每个请求函数。<strong>有一个回调参数interface，这个对象能拿到请求方法、请求路径、请求参数等重要数据</strong>。</p><h3 id="getModIndex函数"><a href="#getModIndex函数" class="headerlink" title="getModIndex函数"></a>getModIndex函数</h3><p>这个函数是重写上面mods目录下每个模块的导出方式，又一个回调参数<code>mod</code>，可以获取到这个模块下某个请求的各种信息。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> MyGenerator <span class="keyword">extends</span> CodeGenerator &#123;</span><br><span class="line"><span class="comment">/* 其他代码 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**@override 重写里层Mods导出模板,支持直接返回请求函数*/</span></span><br><span class="line">  getModIndex(mod: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">                  /**</span></span><br><span class="line"><span class="string">                  * @description <span class="subst">$&#123;mod.description&#125;</span></span></span><br><span class="line"><span class="string">                  */</span></span><br><span class="line"><span class="string">                  <span class="subst">$&#123;mod.interfaces.map((inters: Interface) =&gt; &#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">                      <span class="keyword">return</span> <span class="string">`import * as <span class="subst">$&#123;inters.name&#125;</span> from './<span class="subst">$&#123;inters.name&#125;</span>';`</span>;</span></span></span><br><span class="line"><span class="string"><span class="subst">                  &#125;</span>).join('\n')&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                  <span class="subst">$&#123;mod.interfaces.map(</span></span></span><br><span class="line"><span class="string"><span class="subst">                      (inters: Interface) =&gt; <span class="string">`export const <span class="subst">$&#123;inters.name&#125;</span>Request = <span class="subst">$&#123;inters.name&#125;</span>.request;`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">                  ).join(<span class="string">'; \n'</span>)&#125;</span></span></span><br><span class="line"><span class="string">              `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我重写了导出方式，最后一个模块下的index.ts导出文件会变成如下形式</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 用户管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> getUser <span class="keyword">from</span> <span class="string">'./getUser'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> listUsers <span class="keyword">from</span> <span class="string">'./listUsers'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> login <span class="keyword">from</span> <span class="string">'./login'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUserRequest = getUser.request;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> listUsersRequest = listUsers.request;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginRequest = login.request;</span><br></pre></td></tr></table></figure><p>没错，这样的话使用就非常简洁了：<code>模块名.getUserRequest()</code></p><h3 id="getInterfaceContentInDeclaration函数"><a href="#getInterfaceContentInDeclaration函数" class="headerlink" title="getInterfaceContentInDeclaration函数"></a>getInterfaceContentInDeclaration函数</h3><p>这个函数会修改api.d.ts这个声明文件内的类型声明，如果要自定义的话，那么这个也是必不可少的，因为如果你不重写这个函数的话，你的所有类型都是错误的！</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**@override 重写api声明文件模板，兼容自定义的axios扩展属性*/</span></span><br><span class="line">getInterfaceContentInDeclaration(inter: Interface) &#123;</span><br><span class="line">        <span class="keyword">const</span> bodyParams = inter.getBodyParamsCode();</span><br><span class="line"><span class="keyword">const</span> requestParams = (inter.path.includes(<span class="string">'&#123;'</span>) ? <span class="string">`pathParams = &#123;&#125;, `</span> : <span class="string">''</span>) +</span><br><span class="line">                      (bodyParams ? <span class="string">`bodyParams: Params = &#123;&#125;`</span> : <span class="string">`params: Params = &#123;&#125;`</span>) + </span><br><span class="line">  <span class="string">`, options: import('@/service/types').PickCustomConfig = &#123;&#125;`</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">export <span class="subst">$&#123;inter.getParamsCode(<span class="string">'Params'</span>, <span class="keyword">this</span>.surrounding)&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export type Response = <span class="subst">$&#123;inter.responseType&#125;</span>;</span></span><br><span class="line"><span class="string">export const init: Response;</span></span><br><span class="line"><span class="string">export function request(<span class="subst">$&#123;requestParams&#125;</span>): Promise&lt;[import('axios').AxiosError | null, <span class="subst">$&#123;inter.responseType&#125;</span> | null]&gt;;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重写很简单，但有一点需要注意，在声明文件中不能直接导入类型文件，因此可以看到这里我使用import(‘库’).xxx来实现外部的类型声明，这个函数同样有一个Interface类型的回调参数。</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目环境介绍&quot;&gt;&lt;a href=&quot;#项目环境介绍&quot; class=&quot;headerlink&quot; title=&quot;项目环境介绍&quot;&gt;&lt;/a&gt;项目环境介绍&lt;/h2&gt;&lt;p&gt;公司项目全线上了vue3，因此前端框架还是vue3，脚手架由vite改回了vue.cli4，原因还是部分库的
      
    
    </summary>
    
    
      <category term="记录" scheme="http://localhost:4000/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="vue3" scheme="http://localhost:4000/tags/vue3/"/>
    
      <category term="typescript" scheme="http://localhost:4000/tags/typescript/"/>
    
      <category term="pont" scheme="http://localhost:4000/tags/pont/"/>
    
  </entry>
  
  <entry>
    <title>vite+vue3+vue-router4.0+vuex4.0+ts4.0搭建一个简单的项目架子</title>
    <link href="http://localhost:4000/2020/10/29/vite-vue3-vue-router4-0-vuex4-0-ts4-0%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E5%AD%90/"/>
    <id>http://localhost:4000/2020/10/29/vite-vue3-vue-router4-0-vuex4-0-ts4-0%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E5%AD%90/</id>
    <published>2020-10-29T07:52:34.000Z</published>
    <updated>2021-03-08T06:46:14.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p>按照github的文档所说，vite是基于原生的ES Module导入打包，同样是支持分块打包、热重载、摇树优化等功能，但比起webpack的打包速度会有巨大的提升，并且不会随着项目的增大而变慢。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化vite脚手架</span></span><br><span class="line">npm init vite-app &lt;项目名称&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动项目</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h3><p>项目主要还用了<code>vuex</code>、<code>vue-router</code>、<code>typescript</code>、<code>axios</code>，需要注意vuex与vue-router因为vue3不再暴露Vue构造函数的原因，必须使用4.0版本(没错，两者都是4.0)，暂时都还是beta版本，后续还是要关注github项目的动向。</p><p>对于typescript，因为全局安装过，直接在项目地址输入<code>tsc --init</code>，生成一个tsconfig.json文件，进行配置即可，axios安装照旧。</p><h3 id="配置vite-config-ts文件"><a href="#配置vite-config-ts文件" class="headerlink" title="配置vite.config.ts文件"></a>配置vite.config.ts文件</h3><p>既然整个项目是ts写的，那么配置文件也应该改为ts文件，还有个最大好处是能拿到vite配置的类型。下面贴上一些常用的配置属性</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; UserConfig, Plugin <span class="keyword">as</span> VitePlugin &#125; <span class="keyword">from</span> <span class="string">'vite'</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">const</span> viteConfig: UserConfig = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端口号</span></span><br><span class="line"><span class="comment">     * @default '3000'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    port: <span class="number">9876</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务地址</span></span><br><span class="line"><span class="comment">     * @default 'localhost'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    hostname: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行自动打开浏览器·</span></span><br><span class="line"><span class="comment">     * @default 'false'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    open: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩代码</span></span><br><span class="line"><span class="comment">     *  boolean | 'terser' | 'esbuild'</span></span><br><span class="line"><span class="comment">     * @default 'terser'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// minify: dev ? 'esbuild' : 'terser',</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本公共路径</span></span><br><span class="line"><span class="comment">     * @default '/'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    base: <span class="string">'/'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打包输入路径</span></span><br><span class="line"><span class="comment">     * @default 'dist'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    outDir: <span class="string">'dist'</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @default 'false'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sourcemap: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源输出路径</span></span><br><span class="line"><span class="comment">     * @default '_assets'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assetsDir: <span class="string">'_assets'</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源小于该大小将会内联，默认4096kb</span></span><br><span class="line"><span class="comment">     * @default '4096'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assetsInlineLimit: <span class="number">4096</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * esbuild转换目标。</span></span><br><span class="line"><span class="comment">     * @default 'es2020'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    esbuildTarget: <span class="string">'es2020'</span>,</span><br><span class="line">    silent: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 别名</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">        <span class="string">'/@/'</span>: path.resolve(__dirname, <span class="string">'.'</span>, <span class="string">'src'</span>),</span><br><span class="line">        <span class="string">'@/'</span>: path.resolve(__dirname, <span class="string">'.'</span>, <span class="string">'src'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// css预处理</span></span><br><span class="line">    cssPreprocessOptions: &#123;</span><br><span class="line">        scss: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 会使用 rollup 对 包重新编译，将编译成符合 esm 模块规范的新的包放入 node_modules/.vite_opt_cache</span></span><br><span class="line">    optimizeDeps: &#123;</span><br><span class="line">        include: [</span><br><span class="line">            <span class="string">'echarts'</span>,</span><br><span class="line">            <span class="string">'echarts/map/js/china'</span>,</span><br><span class="line">            <span class="string">'ant-design-vue/es/locale/zh_CN'</span>,</span><br><span class="line">            <span class="string">'@ant-design/icons-vue'</span>,</span><br><span class="line">            <span class="string">'moment/locale/zh-cn'</span>,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// plugins: [PurgeIcons(), ...vitePlugins],</span></span><br><span class="line">    rollupOutputOptions: &#123;&#125;,</span><br><span class="line">    rollupInputOptions: &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="comment">// external: VITE_USE_CDN ? externals : [],</span></span><br><span class="line">        <span class="comment">// plugins: rollupPlugins,</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// module.exports = viteConfig</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">    ...viteConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue3-0的使用"><a href="#Vue3-0的使用" class="headerlink" title="Vue3.0的使用"></a>Vue3.0的使用</h2><p>vite的项目结构与vue.cli没有什么差别，基于之前用2.x写ts的经验，我在<code>src</code>目录下创建了一个<code>shims-vue.d.ts</code>用于声明Vue文件，不然ts是不认识vue结尾的文件的:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*.vue" &#123;</span><br><span class="line">    <span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line">  <span class="comment">// 需要defineComponent的返回类型 这里ReturnType是一个映射类型，通过infer能够推断出函数的返回类型</span></span><br><span class="line">    <span class="keyword">const</span> component: ReturnType&lt;<span class="keyword">typeof</span> defineComponent&gt;;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main文件中：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'/@/router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'/@/store'</span></span><br><span class="line"><span class="keyword">import</span> Antd, &#123; message, notification &#125; <span class="keyword">from</span> <span class="string">'ant-design-vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'ant-design-vue/dist/antd.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">app.use(router)</span><br><span class="line">   .use(store)</span><br><span class="line">   .use(Antd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>现在vue不再暴露Vue实例，需要引入一个createApp函数来挂载页面</p><h3 id="使用demo"><a href="#使用demo" class="headerlink" title="使用demo"></a>使用demo</h3><p>创建一个vue文件，开干</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"home"</span>&gt;</span></span><br><span class="line">        &#123;&#123; data.name &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"count++"</span>&gt;</span></span><br><span class="line">            &#123;&#123; count &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="meta"><span class="meta-keyword">import</span> &#123; </span></span></span><br><span class="line">        defineComponent, </span><br><span class="line">        onMounted, </span><br><span class="line">        reactive, </span><br><span class="line">        ref, </span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span></span><br><span class="line">        setup(props, context) &#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">// 创建一个响应式的对象</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> data = reactive(&#123;</span></span><br><span class="line"><span class="actionscript">                name: <span class="string">'zhou'</span></span></span><br><span class="line">            &#125;), count = ref(0)</span><br><span class="line"></span><br><span class="line"><span class="javascript">            onMounted(<span class="keyword">async</span> ()=&gt; &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// do something</span></span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                data,</span><br><span class="line">              count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我在第一次用的时候有两个疑问:</p><ul><li>这种暴露函数的形式，虽然defineComponent函数已经有了类型验证，但是似乎这样写就用不了装饰器了？</li><li>没有Vue.prototype，全局挂载如何实现？挂载后的类型如何验证</li></ul><p>下面来说说</p><h3 id="如何使用装饰器"><a href="#如何使用装饰器" class="headerlink" title="如何使用装饰器"></a>如何使用装饰器</h3><p>答案很真实，就是不使用装饰器XDDDD….</p><h3 id="如何全局挂载属性"><a href="#如何全局挂载属性" class="headerlink" title="如何全局挂载属性"></a>如何全局挂载属性</h3><p>Vue3中全局挂载需要在config属性下:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">'dayjs'</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"><span class="comment">// 在app下config配置属性中的globalProperties上挂载全局属性</span></span><br><span class="line">app.config.globalProperties.$dayjs = dayjs</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;script lang="ts"&gt;</span></span><br><span class="line">    <span class="keyword">import</span> &#123; </span><br><span class="line">        defineComponent, </span><br><span class="line">        getCurrentInstance, </span><br><span class="line">        onMounted, </span><br><span class="line">        reactive, </span><br><span class="line">        ref, </span><br><span class="line">    &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">        setup(props, context) &#123;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            onMounted(<span class="keyword">async</span> ()=&gt; &#123;</span><br><span class="line">              <span class="comment">// 这也太夸张了</span></span><br><span class="line">              <span class="built_in">console</span>.log(getCurrentInstance().appContext.app.config.globalProperties.$dayjs)</span><br><span class="line"><span class="comment">// 试试下面的Proxy属性呢</span></span><br><span class="line">              <span class="built_in">console</span>.log(getCurrentInstance().Proxy.$dayjs)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// &lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>第一种肯定是闹着玩的，第二种就可行了，不过这个时候还没有类型声明，会报错，ts并不知道$dayjs的存在，我们需要手动写上类型,在<code>main.ts</code>文件中:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'/@/router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'/@/store'</span></span><br><span class="line"><span class="keyword">import</span> Antd, &#123; message, notification &#125; <span class="keyword">from</span> <span class="string">'ant-design-vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'ant-design-vue/dist/antd.css'</span>;</span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">'dayjs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '@vue/runtime-core' &#123;</span><br><span class="line">    <span class="keyword">interface</span> ComponentCustomProperties &#123;</span><br><span class="line">        $dayjs: <span class="keyword">typeof</span> dayjs,</span><br><span class="line">        $message: <span class="keyword">typeof</span> message,</span><br><span class="line">        $notification: <span class="keyword">typeof</span> notification</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line">app.config.globalProperties.$dayjs = dayjs</span><br><span class="line"></span><br><span class="line">app.use(router)</span><br><span class="line">   .use(store)</span><br><span class="line">   .use(Antd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>为什么要写在main.ts文件这个问题我还没找到答案，我本来是把declare放在src目录下的一个d.ts声明文件下的，可他就是不认，最后放到main文件中才生效！</p><p><img src="/BeCoderQ.github.io/2020/10/29/vite-vue3-vue-router4-0-vuex4-0-ts4-0搭建一个简单的项目架子/interface.png" alt="自定义属性"></p><p>重载了<code>ComponentCustomProperties</code>接口，去源码看很贴心的写了例子，诶，在这儿才发现人家例子就是把declare放main文件中的！</p><p>接下来加工一下<code>getCurrentInstance</code>函数，在此之前，做了一点准备工作，在tool-type.d.ts文件中，我写了一个类型工具:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元祖类型转联合类型</span></span><br><span class="line"><span class="keyword">type</span> TupleTypeToUnions&lt;T, K = <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;K&gt; ? T[<span class="built_in">number</span>] : T </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取U中的T类型</span></span><br><span class="line"><span class="keyword">type</span> IncludeKey&lt;T,U&gt; = T <span class="keyword">extends</span> (U <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; ? TupleTypeToUnions&lt;U&gt; : U) ? T : never</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将U中的T类型转为映射出来</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> IncludeType&lt;T, U&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> IncludeKey&lt;keyof T, U&gt;]: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个类型转换后面单独写个博客，实际就是一些简单的类型映射，总之最后可以实现以下效果</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;script&gt;</span></span><br><span class="line"><span class="keyword">type</span> ProxyContext = &#123;</span><br><span class="line">        proxy: NonNullable&lt;IncludeType&lt;ComponentInternalInstance, <span class="string">'proxy'</span>&gt;[<span class="string">'proxy'</span>]&gt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">        setup(props, context) &#123;</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123; proxy: ins &#125;: ProxyContext = &lt;ProxyContext&gt;getCurrentInstance()</span><br><span class="line">            onMounted(<span class="keyword">async</span> ()=&gt; &#123;</span><br><span class="line">              <span class="comment">// 现在可以成功推断</span></span><br><span class="line">                ins.$message.success(<span class="string">'成功'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// &lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>这里最后把<code>getCurrentInstance</code>的<code>proxy</code>属性解构命名为ins，可以看到已经能够推断了。</p><p><img src="/BeCoderQ.github.io/2020/10/29/vite-vue3-vue-router4-0-vuex4-0-ts4-0搭建一个简单的项目架子/assert.png" alt="推断成功"></p><p>可以看到现在全局已经挂载完成了！</p><ul><li>这里使用了<code>IncludeType</code>推断<code>ComponentInternalInstance</code>，第二个值传入proxy我们就拿到了proxy与其类型的键值(类型)对</li><li>然后类似对象与数组的取值，[‘proxy’]拿到proxy的类型</li><li>最后用内置的NonNullable去掉null值(这一步似乎有点多余)</li></ul><h2 id="使用新的Vuex"><a href="#使用新的Vuex" class="headerlink" title="使用新的Vuex"></a>使用新的Vuex</h2><p>Vuex的使用上我采取了不同的方法，因为项目需求，枚举字段会从后端返回，并且枚举字段很多(可能上百个)，那么对于枚举字段，我就放弃了Vuex-decorator的写法，因为这样太费时费力了，这意味着我写一个属性就得写一个Mutation，因此我选择自动生成Mutation。生成的代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">genaratorMutation</span>&lt;<span class="title">T</span>&gt;(<span class="params">state: &#123; [K <span class="keyword">in</span> keyof T]: T[K] &#125;</span>): <span class="title">MutationTree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mutationMap: MutationTree&lt;T&gt; = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(state).forEach(<span class="function">(<span class="params">key: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(mutationMap, &#123;</span><br><span class="line">            [key]: <span class="function">(<span class="params">$state: <span class="keyword">typeof</span> state, value: T[keyof T]</span>) =&gt;</span> &#123;</span><br><span class="line">                $state[key <span class="keyword">as</span> keyof T] = value</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> mutationMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在模块文件内:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> userType &#123;</span><br><span class="line">    <span class="string">"用户"</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="string">"管理员"</span> = <span class="number">2</span>,</span><br><span class="line">    <span class="string">"超级管理员"</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> sexType &#123;</span><br><span class="line">    <span class="string">"男"</span> = <span class="number">1</span></span><br><span class="line">    <span class="string">"女"</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enumState = &#123;</span><br><span class="line">    sexType,</span><br><span class="line">    userType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enumMutations = genaratorMutation&lt;Partial&lt;<span class="keyword">typeof</span> enumState&gt;&gt;(enumState)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    state: enumState,</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line">    mutations: enumMutations,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vite&quot;&gt;&lt;a href=&quot;#vite&quot; class=&quot;headerlink&quot; title=&quot;vite&quot;&gt;&lt;/a&gt;vite&lt;/h2&gt;&lt;p&gt;按照github的文档所说，vite是基于原生的ES Module导入打包，同样是支持分块打包、热重载、摇树优化等
      
    
    </summary>
    
    
      <category term="学习" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="vue3" scheme="http://localhost:4000/tags/vue3/"/>
    
      <category term="typescript" scheme="http://localhost:4000/tags/typescript/"/>
    
      <category term="vite" scheme="http://localhost:4000/tags/vite/"/>
    
  </entry>
  
  <entry>
    <title>基于Vue包装一个链式注销的全局事件总线</title>
    <link href="http://localhost:4000/2020/09/30/%E5%9F%BA%E4%BA%8EVue%E5%8C%85%E8%A3%85%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E6%B3%A8%E9%94%80%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <id>http://localhost:4000/2020/09/30/%E5%9F%BA%E4%BA%8EVue%E5%8C%85%E8%A3%85%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E6%B3%A8%E9%94%80%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</id>
    <published>2020-09-30T05:45:27.000Z</published>
    <updated>2020-09-30T05:59:52.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>公司的某个项目组件封装得不是很好，到处都在用全局事件总线，并且<code>@on</code>注册后还从来都不注销，虽然项目不大不存在爆栈的问题，但是这不是一个好习惯，因此决定写一个工厂函数来让注销事件简单一点。</p><h2 id="目标效果"><a href="#目标效果" class="headerlink" title="目标效果"></a>目标效果</h2><p>最后实现的效果大概是这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$bus.$on(<span class="string">'customize-event'</span>, msg=&gt; &#123;</span><br><span class="line">      <span class="comment">// do sth</span></span><br><span class="line">    &#125;).off(<span class="keyword">this</span>, <span class="string">'customize-event'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在往Vue实例中_events属性中推入事件后，直接在<code>@on</code>后面调用off事件注销事件，当然这个注销不是马上注销，而是在<code>beforeDestory</code>钩子函数触发时注销。另外，我们还要向下兼容原生的事件。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ExtendGlobalEvent,继承自Vue,调用全局总线调用同原生事件总线相同，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendGlobalEvent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @override</span></span><br><span class="line">  <span class="comment">// 注意名字别写重了</span></span><br><span class="line">    _on(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>.$on(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    _emit(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>.$emit(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局事件的工厂函数，为了兼容原生$on的调用方式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">EventGloablFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Event = <span class="keyword">new</span> ExtendGlobalEvent()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        $on(...args) &#123;</span><br><span class="line">            Event._on(...args)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;,</span><br><span class="line">        $emit(...args) &#123;</span><br><span class="line">            Event._emit(...args)</span><br><span class="line">        &#125;,</span><br><span class="line">        $off(...args) &#123;</span><br><span class="line">            Event.$off(...args)</span><br><span class="line">        &#125;,</span><br><span class="line">        off(context, eventName) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context &amp;&amp; context._isVue) &#123;</span><br><span class="line">                context.$once(<span class="string">'hook:beforeDestroy'</span>, () =&gt; &#123;</span><br><span class="line">                    <span class="keyword">this</span>.$off(eventName)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们暴露出去的实际是一个对象，这个对象的key与原生的全局事件的key相同，他们会执行被ExtendGlobalEvent实例化后的Event，而ExtendGlobalEvent内部又是继承自Vue，它触发的也是原生的$emit、$on、$off。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;公司的某个项目组件封装得不是很好，到处都在用全局事件总线，并且&lt;code&gt;@on&lt;/code&gt;注册后还从来都不注销，虽然项目不大不存在爆栈的
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="bus" scheme="http://localhost:4000/tags/bus/"/>
    
      <category term="Vue" scheme="http://localhost:4000/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>最近项目中遇到的一些问题或一些总结</title>
    <link href="http://localhost:4000/2020/09/30/%E6%9C%80%E8%BF%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%88%96%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://localhost:4000/2020/09/30/%E6%9C%80%E8%BF%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%88%96%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-30T02:31:10.000Z</published>
    <updated>2020-09-30T05:28:48.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="uni-app的scroll-view组件触底概率不触发问题"><a href="#uni-app的scroll-view组件触底概率不触发问题" class="headerlink" title="uni-app的scroll-view组件触底概率不触发问题"></a>uni-app的scroll-view组件触底概率不触发问题</h2><p>前段时间用uni-app做移动端遇到一个问题，使用<code>scroll-view</code>标签<code>@scrolltolower</code>事件时，会有一定概率不触发触底事件，至于原因我没有去研究，不过暂时找到一个解决办法:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scroll-view</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:scroll-top</span>=<span class="string">"prevScrollTop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"load-more-list"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">scroll-y</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">@<span class="attr">scrolltolower</span>=<span class="string">"reachBottom"</span></span></span><br><span class="line"><span class="tag">@<span class="attr">scroll</span>=<span class="string">"onScroll"</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-on</span>=<span class="string">"$listeners"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:style</span>=<span class="string">"&#123; height: height || `calc(100vh - $&#123;_cache.statusHeight&#125;px - 44px` &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">:list</span>=<span class="string">"renderList"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">loading-animation</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:no-more</span>=<span class="string">"noMore"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:data</span>=<span class="string">"renderList"</span> </span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我有一个上拉加载更多组件，HTML部分大概是这样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      prevScrollTop: <span class="number">0</span>,</span><br><span class="line">      currentScrollTop: <span class="number">0</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">    _scroll: _.debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.prevScrollTop = <span class="keyword">this</span>.currentScrollTop</span><br><span class="line">    &#125;, <span class="number">700</span>),</span><br><span class="line">    onScroll(&#123; <span class="attr">detail</span>: &#123; scrollTop &#125; &#125;) &#123;</span><br><span class="line">      <span class="keyword">this</span>._scroll()</span><br><span class="line">      <span class="keyword">this</span>.currentScrollTop = scrollTop</span><br><span class="line">    &#125;,</span><br><span class="line">    _onReachBottom: _.debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.noMore) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.pageNum++</span><br><span class="line">      <span class="keyword">this</span>.getData()</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    reachBottom() &#123;</span><br><span class="line">      <span class="keyword">this</span>._onReachBottom()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只贴了关键代码，可以看到我除了绑定了<code>@scrolltolower</code>触底事件，还加了一个滚动事件<code>@scroll</code>、滚动距离属性<code>scroll-top</code>。除此之外还有两个变量，prevScrollTop与currentScrollTop，名字可能不太契合，大概意思就是在滚动后将当前滚动的距离赋值给<code>scroll-view</code>标签。</p><h2 id="await的错误捕获"><a href="#await的错误捕获" class="headerlink" title="await的错误捕获"></a>await的错误捕获</h2><p>最近接手一个别人的写的项目遇到一个问题，请求接口时，当接口正常应答可以正常拿到数据，当接口报错了就拿不到任何东西，打开控制台一看，uncaught (in promise)。于是去看了下封装的请求库，发现了问题，因为封装的很乱，所以我就拿典型的错误举例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">参数</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">request(处理后的参数)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">参数</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">      axios(参数)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;...; resolve(response.data)&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span>=&gt;</span> &#123;...; reject(error)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.req(各种参数)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样咋一看好像没问题，不过有三个比较突出的问题:</p><ul><li>既然封装了 还使用了axios，那么就应该用拦截器，而不是直接用axios来封装</li><li>req函数只是调用了request函数，没有做错误捕捉等处理</li><li>使用async与await来同步化异步操作，但是返回的结果无法区分到底出没出错</li></ul><p>修改:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">参数</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = <span class="keyword">await</span> <span class="keyword">this</span>.request(参数)</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">null</span>, res]</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> [err, res]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">参数</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">      axios(参数)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;...; resolve(response.data)&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span>=&gt;</span> &#123;...; reject(error)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.req(各种参数)</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="comment">// 做接口错误后的相关事宜</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里修改后，用try catch捕获了错误，并且将代码风格改为了error-first，简单明了，让调用后更好区分。</p><h2 id="TypeScript一些总结"><a href="#TypeScript一些总结" class="headerlink" title="TypeScript一些总结"></a>TypeScript一些总结</h2><p>最近使用了nuxt+ts，另外用ts封装了一个代理vuex的库，遇到了一些问题，总结一下</p><h3 id="ts中常用的几种导入方式"><a href="#ts中常用的几种导入方式" class="headerlink" title="ts中常用的几种导入方式"></a>ts中常用的几种导入方式</h3><ul><li><p><code>import something from &#39;something&#39;</code>与 <code>import { something } from &#39;library&#39;</code>同js中一样，最标准的AMD导入，这种方法导入的东西是带有类型校验的，当然，前提是有声明文件。</p></li><li><p><code>import * as $ from &#39;xxx&#39;</code>，这样的导入方式及是将目标文件中所有的<code>export</code>项存入<code>namespace</code>变量$中，调用时均以$.调用，同样有类型校验。</p></li><li><code>import something = require(&#39;something&#39;)</code>，这个调用方式与<code>const something = require(&#39;something&#39;)</code>的区别是前者除了导入模块外，还将它的类型导入了，当你使用ts时，前者导入的<code>something</code>会在使用时进行类型校验，后者则不会，因为ts将后者的类型定义为any。</li></ul><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言并没有强制转换类型，而是让我们做一个选择，一个最简单的例子:</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value.length) <span class="keyword">return</span> value.length</span><br><span class="line">  <span class="keyword">return</span> value.toString().length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里编译会出错，因为number类型并没有length属性，访问联合类型时，这个属性必须时两个类型的交集，也就是说length必须是两者都具有的属性才能编译通过。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((&lt;<span class="built_in">string</span>&gt;value).length) <span class="keyword">return</span> (&lt;<span class="built_in">string</span>&gt;value).length</span><br><span class="line">  <span class="keyword">return</span> value.toString().length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用data-set为伪类动态赋值"><a href="#使用data-set为伪类动态赋值" class="headerlink" title="使用data-set为伪类动态赋值"></a>使用data-set为伪类动态赋值</h2><p>之前做了一个页面，四个小模块，每个模块左上角是一个标题，当时并不想为没有什么复杂样式的标题专门写一个标签，因此想到了伪类。code:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"card violation-count"</span> <span class="attr">:data-title</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">v-for</span>=<span class="string">"meta in typeMeta"</span> <span class="attr">:key</span>=<span class="string">"meta.title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123; meta.title &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; meta.count &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">    title: <span class="string">'动态的标题'</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css部分：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: attr(data-title);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就这么简单。此外，我们还可以利用less、sass预编译器的循环功能来为多个伪类赋值。</p><h2 id="在Vue中注销watch监听"><a href="#在Vue中注销watch监听" class="headerlink" title="在Vue中注销watch监听"></a>在Vue中注销watch监听</h2><p>最近做的这个项目数据源只有三个接口，这三个接口的数据会由一个根组件注入到下面的所有子模块中，并且会轮询访问。下面的子模块watch监听到数据变化后更新视图。然后有一个页面的需求是只需要一次监听，赋值，然后就不再监听，这个时候，我们就需要用的<code>$watch</code>了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">()</span>=&gt;</span> []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">const</span> destoryWatch = <span class="keyword">this</span>.$watch(<span class="string">'list'</span>, (newList, oldList)=&gt; &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      destoryWatch()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照vue官网2.x的API所述，$watch监听后会返回一个取消观察函数，执行它之后监听函数将会被销毁。文档详情:<a href="https://cn.vuejs.org/v2/api/#vm-options" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#vm-options</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;uni-app的scroll-view组件触底概率不触发问题&quot;&gt;&lt;a href=&quot;#uni-app的scroll-view组件触底概率不触发问题&quot; class=&quot;headerlink&quot; title=&quot;uni-app的scroll-view组件触底概率不触发问题&quot;&gt;
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://localhost:4000/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>解析后端按位运算的枚举值</title>
    <link href="http://localhost:4000/2020/09/10/%E8%A7%A3%E6%9E%90%E5%90%8E%E7%AB%AF%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%80%BC/"/>
    <id>http://localhost:4000/2020/09/10/%E8%A7%A3%E6%9E%90%E5%90%8E%E7%AB%AF%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%80%BC/</id>
    <published>2020-09-10T01:04:32.000Z</published>
    <updated>2020-09-30T02:18:00.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="位运算枚举值"><a href="#位运算枚举值" class="headerlink" title="位运算枚举值"></a>位运算枚举值</h2><p>位运算的枚举值大概是下面的样子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dictionary = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">'枚举值one'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'枚举值two'</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="string">'枚举值three'</span>,</span><br><span class="line">  <span class="number">8</span>: <span class="string">'枚举值four'</span>,</span><br><span class="line">  <span class="number">16</span>: <span class="string">'枚举值five'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而很多时候枚举值会有叠加，比如该枚举值是指违规项，那么对应的就会存在同时有多种违规，比如同时违反了第一项和第三项，那么后端就会返回枚举值5(1+4)。</p><h2 id="为什么是1、2、4、8"><a href="#为什么是1、2、4、8" class="headerlink" title="为什么是1、2、4、8"></a>为什么是1、2、4、8</h2><p>首先这些数都是十进制，我们说的左移右移是针对二进制来说的，比如0001，我们左移后会变成0010，此时0010转为10进制就是2了，对于2再左移，就会变成0100对应的十进制就是8，以此类推</p><h2 id="解析位运算"><a href="#解析位运算" class="headerlink" title="解析位运算"></a>解析位运算</h2><p>我们并不需要去排列组合，使用JavaScript提供的左移右移操作符可以非常简洁的完成枚举转换，直接来完整的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dictByBit</span>(<span class="params">dictObj, value, separate = <span class="string">'、'</span>, result = <span class="string">""</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(dictObj) != <span class="string">"[object Object]"</span>)  <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dictLocation = []</span><br><span class="line">    <span class="comment">// 将枚举表中每一种可能的枚举值推入一个数组</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(dictObj).forEach(<span class="function"><span class="params">bit</span>=&gt;</span> &#123;</span><br><span class="line">        dictLocation.push(bit)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(dictObj[value]) &#123;</span><br><span class="line">        <span class="keyword">return</span> (result?(result + separate):<span class="string">''</span>) + dictObj[value]</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">       <span class="comment">// 这里我们假设枚举上限到1024，使用该值累加，直到右移后等于1</span></span><br><span class="line">       <span class="keyword">if</span>(value &gt;&gt; i === <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">let</span> afterMove = value - dictLocation[i]</span><br><span class="line">           <span class="keyword">return</span> dictByBit(dictObj, afterMove, separate, (result?(result + separate):<span class="string">''</span>) + dictObj[dictLocation[i]])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里函数接受四个参数</p><ul><li>dictObj: 枚举表</li><li>value: 后端返回的枚举值</li><li>separate: 分隔符，如枚举值同时是3，那么就是1+2，如、分隔符，字典翻译后会返回枚举值1、枚举值2</li><li>result: 这个参数是递归时函数间传递的，调用时不需要</li></ul><p>看一下上面的函数，最重要的部分就是下面for循环后的右移位，我这里以1024位作为(实际不可能枚举到这么多)右移上限。<strong>现在我们假设后端返回了一个枚举值7</strong>，我们的枚举表还是最上方的那个，现在分析这个函数的原理：</p><ul><li>后端返回了一个枚举值为7的的枚举值，那么就一定是1+2+4，对于位运算的枚举，只会有一种结果</li><li>我们将7这个枚举值右移，当我们<strong>右移到值为1时</strong>，就拿到了这个枚举值由?+?+?相加的<strong>最后一位的索引</strong>，我们以此为条件，递归，从最后一位拿到第一位，最后的结果就是2 1 0，这实际是索引。这也是为什么一开始我们要把枚举表中的值依次推入一个数组的原因，我们通过索引便可以直接拿到对应翻译后的值了。</li></ul><p>为什么要右移呢？很简单，因为后端左移了，我们要还原啊！还是以7为例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">0</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="comment">// 2 </span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">2</span> <span class="comment">// 4 </span></span><br><span class="line"><span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>递归函数每次会解析出一个枚举值，比如上面说的7，是1+2+4，那么就会有两次递归，afterMove变量非常重要，因为它保存了本次倒退的枚举值后<strong>剩下的枚举和</strong>。还是用上面的例子来看</p><ul><li>第一次我们传入枚举值7进去后，执行右移，当i = 2时，右移值是1，此时2就是1+2+4的枚举值4，对应dictionary字典中就是”枚举值three“</li><li>我们用7 - 4 = 3，<strong>(这个4就是bit数组[1,2,4,8,16]中的索引2)</strong>，3就是下一轮的枚举和，以同样的方式，3右移1位等于1，那么执行3-2</li><li>最后一轮我们拿到了值1，1本身就是字典中的值了，所以我们结束递归，拿到了7对应的三个结果，也就是1、2、4</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;位运算枚举值&quot;&gt;&lt;a href=&quot;#位运算枚举值&quot; class=&quot;headerlink&quot; title=&quot;位运算枚举值&quot;&gt;&lt;/a&gt;位运算枚举值&lt;/h2&gt;&lt;p&gt;位运算的枚举值大概是下面的样子:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="位运算" scheme="http://localhost:4000/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="JavaScript" scheme="http://localhost:4000/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>记一次后台权限与路由的重构</title>
    <link href="http://localhost:4000/2020/08/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%90%8E%E5%8F%B0%E6%9D%83%E9%99%90%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E9%87%8D%E6%9E%84/"/>
    <id>http://localhost:4000/2020/08/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%90%8E%E5%8F%B0%E6%9D%83%E9%99%90%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E9%87%8D%E6%9E%84/</id>
    <published>2020-08-31T00:39:55.000Z</published>
    <updated>2020-09-30T02:30:04.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要重构"><a href="#为什么要重构" class="headerlink" title="为什么要重构"></a>为什么要重构</h2><p>老实说重构我一直觉得是一件费力不讨好的事儿，但是这次的后台项目路由那块确实太乱了，复制粘贴以前项目的，非常生硬，这也导致权限的验证非常麻烦，因此趁着还没上线，花了大半天给改完了。</p><h2 id="重构的思路"><a href="#重构的思路" class="headerlink" title="重构的思路"></a>重构的思路</h2><p>这个后台管理是有两级菜单的，如下图</p><p><img src="/BeCoderQ.github.io/2020/08/31/记一次后台权限与路由的重构/power-menu.png" alt="菜单结构"></p><p>可以看到有两级菜单，顶层的菜单控制切换模块，并带动左侧的边栏菜单的变化，这里因为项目结构的历史原因，顶部的一级菜单和左侧的菜单是完全分开且没有关系的。那么我的思路大概有以下几步</p><ul><li>在数据上耦合一级菜单与二级菜单</li><li>因为页面并不是特别多，所以菜单就直接通过暴露出的路由元数据来渲染</li><li>权限配置上，因为后台返回的是id，因此这些id可以直接写在路由配置的meta属性中</li><li>在后端返回权限的配置数据，前端对比当前路由后，通过一个resetRouter函数替换路由(替换的路由是剔除掉无权限页面的)</li></ul><p>大体上就是这几个点，下面看代码详细说</p><h2 id="耦合一二级菜单"><a href="#耦合一二级菜单" class="headerlink" title="耦合一二级菜单"></a>耦合一二级菜单</h2><p>耦合两级菜单非常简单，我的办法是使用webpack的require.context方法，通过文件名作为key耦合两级菜单，并存储在vuex中，先看一下路由结构：</p><p><img src="/BeCoderQ.github.io/2020/08/31/记一次后台权限与路由的重构/router-menu.png" alt="路由结构"></p><p>modules文件下是所有路由的元数据，router-config文件是一些配置路由的功能函数，然后再看一下用于存储菜单数据的vuex数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rootMenus: [</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'首页'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/home'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'遥感监测'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/remote-sensing-map'</span>, <span class="attr">id</span>: <span class="string">'remote'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'分表计电'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/product-run'</span>, <span class="attr">id</span>: <span class="string">'electric'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'扬尘监测'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/monitor-map'</span>, <span class="attr">id</span>: <span class="string">'raise-dust'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'OBD监测'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/obd-map'</span>, <span class="attr">id</span>: <span class="string">'obd'</span>, <span class="attr">subs</span>: [] &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'系统管理'</span>, <span class="attr">path</span>: <span class="string">'/synthesize/car-setting'</span>, <span class="attr">id</span>: <span class="string">'system'</span>, <span class="attr">subs</span>: [] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里id就是对应每个模块的文件名，subs就是二级菜单数组。</p><h3 id="通过require-context完成菜单的合成"><a href="#通过require-context完成菜单的合成" class="headerlink" title="通过require.context完成菜单的合成"></a>通过require.context完成菜单的合成</h3><p>在router-config中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// associateMenu将根据文件名与store中预设的菜单id关联，将顶级菜单与二级菜单结合</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">associateMenu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getState方法是我封装的获取store中state的方法</span></span><br><span class="line">    <span class="keyword">let</span> rootMenus = getState(<span class="string">'cache'</span>, <span class="string">'rootMenus'</span>),</span><br><span class="line">        originRouters = []</span><br><span class="line">    <span class="keyword">const</span> moduleFiles = <span class="built_in">require</span>.context(<span class="string">'./modules'</span>, <span class="literal">true</span>, /\.js$/)</span><br><span class="line">    moduleFiles.keys().map(<span class="function"><span class="keyword">function</span> (<span class="params">modulePath</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(moduleFiles(modulePath).default) &#123;</span><br><span class="line">            originRouters.push(moduleFiles(modulePath).default)</span><br><span class="line">            rootMenus.map(<span class="function"><span class="params">menu</span>=&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// 根据id绑定在一起</span></span><br><span class="line">                <span class="keyword">if</span>(modulePath.includes(menu.id)) &#123;</span><br><span class="line">                    menu.subs = moduleFiles(modulePath).default</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    setState(<span class="string">'cache'</span>, <span class="string">'rootMenus'</span>, rootMenus)</span><br><span class="line">    <span class="comment">// 这里返回一个原始的路由元数据，用于路由的注册</span></span><br><span class="line">    <span class="keyword">return</span> originRouters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在路由的index.js大概是这个样子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; associateMenu &#125; <span class="keyword">from</span> <span class="string">'./router-config'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">const</span> sonMenus = [].concat(...associateMenu())</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'/synthesize'</span>,</span><br><span class="line">        redirect: <span class="string">'/synthesize'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'@/views/frame/Home.vue'</span>),</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">          name: <span class="string">'home'</span>,</span><br><span class="line">          path: <span class="string">'home'</span>,</span><br><span class="line">          component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'@/views/home/index'</span>),</span><br><span class="line">            meta: &#123;</span><br><span class="line">              title: <span class="string">'首页'</span>,</span><br><span class="line">              icon: <span class="string">'el-icon-home'</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">        ...sonMenus</span><br><span class="line">        ]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/'</span>,</span><br><span class="line">redirect: <span class="string">'/login'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">title: <span class="string">'登录'</span>,</span><br><span class="line">path: <span class="string">'/login'</span>,</span><br><span class="line">name: <span class="string">"Login"</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/login/LoginPageNew'</span>),</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'*'</span>,</span><br><span class="line">redirect: <span class="string">'/404'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/404'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/error-page/404'</span>),</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样菜单就做好了，接下来就是权限了</p><h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><p>权限通过vuex中rootMenus中的权限id属性来判断哪些路由会被删除</p><h3 id="动态刷新路由"><a href="#动态刷新路由" class="headerlink" title="动态刷新路由"></a>动态刷新路由</h3><p>首先看一下怎么实现路由的动态刷新:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function">(<span class="params">routes</span>) =&gt;</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">base: process.env.NODE_ENV === <span class="string">'development'</span>?<span class="string">'/'</span>:<span class="string">'/synthesize/'</span>,</span><br><span class="line">routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(routes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限获取后替换路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params">routes</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> newRouter = createRouter(routes)</span><br><span class="line">router.matcher = newRouter.matcher</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里我们通过替换路由的matcher，即匹配规则，实现动态的路由更换，下面根据需要修改上面的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; associateMenu &#125; <span class="keyword">from</span> <span class="string">'./router-config'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">const</span> sonMenus = [].concat(...associateMenu())</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'/synthesize'</span>,</span><br><span class="line">        redirect: <span class="string">'/synthesize'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'@/views/frame/Home.vue'</span>),</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">          name: <span class="string">'home'</span>,</span><br><span class="line">          path: <span class="string">'home'</span>,</span><br><span class="line">          component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'@/views/home/index'</span>),</span><br><span class="line">            meta: &#123;</span><br><span class="line">              title: <span class="string">'首页'</span>,</span><br><span class="line">                icon: <span class="string">'el-icon-home'</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">        ...sonMenus</span><br><span class="line">        ]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/'</span>,</span><br><span class="line">redirect: <span class="string">'/login'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">title: <span class="string">'登录'</span>,</span><br><span class="line">path: <span class="string">'/login'</span>,</span><br><span class="line">name: <span class="string">"Login"</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/login/LoginPageNew'</span>),</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'*'</span>,</span><br><span class="line">redirect: <span class="string">'/404'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/404'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/error-page/404'</span>),</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// createRouter函数接受一个回调函数，将创建一个权限过滤后的路由实例</span></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function">(<span class="params">validate</span>) =&gt;</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">base: process.env.NODE_ENV === <span class="string">'development'</span>?<span class="string">'/'</span>:<span class="string">'/synthesize/'</span>,</span><br><span class="line">routes: <span class="keyword">typeof</span> validate === <span class="string">'function'</span>?validate(routes):routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(routes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限获取后替换路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params">validate</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> newRouter = createRouter(validate)</span><br><span class="line">router.matcher = newRouter.matcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>这里我们修改后的逻辑变成了在调用resetRouter时传入一个验证的回调函数，这个回调函数的参数就是当前所有路由的元数据，在使用时大概是这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> getPower() &#123;</span><br><span class="line">  <span class="keyword">let</span> [err, res] = <span class="keyword">await</span> getPower(&#123; ...params &#125;)</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个就是后台返回的权限树</span></span><br><span class="line">  <span class="keyword">const</span> powerMetas = res.rows</span><br><span class="line">  resetRouter(<span class="function">(<span class="params">routes</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里用routes与powerMetas循环判断id是否存在，不存在则将该路由删除</span></span><br><span class="line">    <span class="keyword">let</span> routesChildren = routes[<span class="number">0</span>].children</span><br><span class="line">    routesChildren.map(<span class="function">(<span class="params">route, index</span>)=&gt;</span> &#123;</span><br><span class="line">      powerMetas.forEach(<span class="function"><span class="params">meta</span>=&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(没有该ID) &#123;</span><br><span class="line">          <span class="comment">// 删除该路由</span></span><br><span class="line">          routesChildren.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 返回一个已经过滤完成的路由</span></span><br><span class="line">    <span class="keyword">return</span> routes</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我通过接口返回的权限树来与当前所有路由进行比对，把权限id不存在的路由删除掉。</p><h3 id="进一步修改"><a href="#进一步修改" class="headerlink" title="进一步修改"></a>进一步修改</h3><p>这里其实并没有做完，因为我们的菜单是根据vuex的rootMenus属性来渲染的，所以我们单纯删除了路由是没有用的，页面上的菜单上还是会有删除的页面，只是点了过后无法访问而已，这样用户体验是很差的。那么，我们要想一个办法让路由的数据与vuex中渲染页面的数据联系起来。</p><h3 id="使用Proxy监听路由的修改"><a href="#使用Proxy监听路由的修改" class="headerlink" title="使用Proxy监听路由的修改"></a>使用Proxy监听路由的修改</h3><p>这里正好可以使用上周博客介绍的Proxy来监听路由，在router-config文件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observeRouter</span>(<span class="params">router</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听代理数组与对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> router === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> router) &#123;</span><br><span class="line">            <span class="comment">// 递归深度代理</span></span><br><span class="line">            <span class="keyword">typeof</span> router[key] === <span class="string">'object'</span> &amp;&amp; (router[key] = observeRouter(router[key]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(router, &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @param &#123;target&#125; 当前对象</span></span><br><span class="line"><span class="comment">         * @param &#123;prop&#125; 设置属性名</span></span><br><span class="line"><span class="comment">         * @param &#123;value&#125; 新的值</span></span><br><span class="line"><span class="comment">         * @param &#123;receiver&#125; 映射时的上下文</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">set</span>(target, prop, value, receiver) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`设置了：<span class="subst">$&#123;prop&#125;</span>属性，修改值：<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="comment">// 以下操作为同步store渲染菜单</span></span><br><span class="line">            <span class="keyword">let</span> newMenus = getState(<span class="string">'cache'</span>, <span class="string">'rootMenus'</span>) || [],</span><br><span class="line">                deleteXy = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="comment">// 这里只处理第二级菜单 顶级菜单在渲染时直接通过v-show隐藏</span></span><br><span class="line">            newMenus.map(<span class="function">(<span class="params">menu, mIdx</span>)=&gt;</span> &#123;</span><br><span class="line">                menu.subs.map(<span class="function">(<span class="params">sub, sIdx</span>)=&gt;</span> &#123;</span><br><span class="line">                  <span class="comment">// receiver是单个路由的配置对象</span></span><br><span class="line">                    <span class="keyword">if</span>(sub.name === receiver.name) &#123;</span><br><span class="line">                        deleteXy = [mIdx, sIdx]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">            newMenus[deleteXy[<span class="number">0</span>]].subs.splice(deleteXy[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 将修改后的数据同步到vuex中</span></span><br><span class="line">            setState(<span class="string">'cache'</span>, <span class="string">'rootMenus'</span>, newMenus)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value, receiver)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意一点，我们通过递归来监听数组对象，当我们删除数组后，Proxy监听会有一个问题，比如我监听的数据是一个包含24个对象的数组，<strong>当我们删除第三个时，这里的监听函数会触发21次，因为第三个的删除导致了数组长度的变化，换句话说，现在这个数组”坍塌”了。</strong>所以，如果我们匹配权限规则时直接去删除路由，会导致我们监听不到具体删除的结果。</p><p>写好了监听函数，那么就在index.js文件中监听路由：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; associateMenu, observeRouter &#125; <span class="keyword">from</span> <span class="string">'./router-config'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="keyword">const</span> sonMenus = [].concat(...associateMenu())</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'/synthesize'</span>,</span><br><span class="line">        redirect: <span class="string">'/synthesize'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'@/views/frame/Home.vue'</span>),</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">          name: <span class="string">'home'</span>,</span><br><span class="line">          path: <span class="string">'home'</span>,</span><br><span class="line">          component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'@/views/home/index'</span>),</span><br><span class="line">            meta: &#123;</span><br><span class="line">              title: <span class="string">'首页'</span>,</span><br><span class="line">                icon: <span class="string">'el-icon-home'</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">        ...sonMenus</span><br><span class="line">        ]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/'</span>,</span><br><span class="line">redirect: <span class="string">'/login'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">title: <span class="string">'登录'</span>,</span><br><span class="line">path: <span class="string">'/login'</span>,</span><br><span class="line">name: <span class="string">"Login"</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/login/LoginPageNew'</span>),</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'*'</span>,</span><br><span class="line">redirect: <span class="string">'/404'</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">'/404'</span>,</span><br><span class="line">component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/base/error-page/404'</span>),</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里代理路由</span></span><br><span class="line"><span class="keyword">let</span> proxyRoutes = observeRouter(routes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// createRouter函数接受一个回调函数，将创建一个权限过滤后的路由实例</span></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function">(<span class="params">validate</span>) =&gt;</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">base: process.env.NODE_ENV === <span class="string">'development'</span>?<span class="string">'/'</span>:<span class="string">'/synthesize/'</span>,</span><br><span class="line">routes: <span class="keyword">typeof</span> validate === <span class="string">'function'</span>?validate(proxyRoutes):proxyRoutes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(proxyRoutes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限获取后替换路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params">validate</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> newRouter = createRouter(validate)</span><br><span class="line">router.matcher = newRouter.matcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>接下来，在刷新路由那里我们就要像这样改一下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> getPower() &#123;</span><br><span class="line">  <span class="keyword">let</span> [err, res] = <span class="keyword">await</span> getPower(&#123; ...params &#125;)</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个就是后台返回的权限树</span></span><br><span class="line">  <span class="keyword">const</span> powerMetas = res.rows</span><br><span class="line">  resetRouter(<span class="function">(<span class="params">routes</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里用routes与powerMetas循环判断id是否存在，不存在则将该路由删除</span></span><br><span class="line">    <span class="keyword">let</span> routesChildren = routes[<span class="number">0</span>].children</span><br><span class="line">    routesChildren.map(<span class="function">(<span class="params">route, index</span>)=&gt;</span> &#123;</span><br><span class="line">      powerMetas.forEach(<span class="function"><span class="params">meta</span>=&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(没有该ID) &#123;</span><br><span class="line">          <span class="comment">// 将该路由的导入文件设置为null</span></span><br><span class="line">          route.component = <span class="literal">null</span></span><br><span class="line">          route.redirect = <span class="string">'/404'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 返回一个已经过滤完成的路由</span></span><br><span class="line">    <span class="keyword">return</span> routes</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把没有权限的路由的component项设置为null，这样页面就时空的了，但是该路由其实还是注册了，用户如果直接输入路径访问并不会跳到404页面，所以后面我们把该路由重定向到了404页面。</p><h2 id="一二级菜单的联动"><a href="#一二级菜单的联动" class="headerlink" title="一二级菜单的联动"></a>一二级菜单的联动</h2><p>前面说了因为一些原因导致一级菜单与二级菜单的文件是分开的，这里我也没有再去改结构，我直接注册了全局事件，通过发布订阅模式实现一级菜单带动二级菜单的效果，另外对于用户直接通过url输入后菜单的变化是通过监听路由等实现的，看看代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// activeIndex是当前激活的一级菜单的索引</span></span><br><span class="line">  activeIndex(index) &#123;</span><br><span class="line">      <span class="comment">// 改变了就直接跳转到对于的菜单</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="keyword">this</span>._cache.rootMenus[index].path)</span><br><span class="line">      <span class="comment">// 触发左侧菜单订阅的root-menu-change事件，将当前菜单的数据传过去</span></span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'root-menu-change'</span>, <span class="keyword">this</span>._cache.rootMenus[index])</span><br><span class="line">&#125;,</span><br><span class="line">  $route: &#123;</span><br><span class="line">      handler(route) &#123;</span><br><span class="line">          <span class="comment">// 顶级菜单耦合路由</span></span><br><span class="line">          <span class="keyword">this</span>._cache.rootMenus &amp;&amp; <span class="keyword">this</span>._cache.rootMenus.forEach(<span class="function">(<span class="params">rMenu, rIdx</span>)=&gt;</span> &#123;</span><br><span class="line">            rMenu.subs.length &amp;&amp; rMenu.subs.forEach(<span class="function"><span class="params">menu</span>=&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(menu.name === route.name) &#123;</span><br><span class="line">                <span class="keyword">this</span>.activeIndex = <span class="string">''</span> + rIdx</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完成！</strong></p><h2 id="one-more-thing"><a href="#one-more-thing" class="headerlink" title="one more thing"></a>one more thing</h2><p>还没完，因为我发现这一套流程在IE上是走不通的，因为Proxy这个API在IE上是不支持的，并且一般的polyfill还搞不定Proxy，我尝试了谷歌开发Proxy-polyfill发现居然没有效果，于是乎又写了一个支持IE的版本:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observeRouterForIE</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="comment">// 递归深度代理</span></span><br><span class="line">            <span class="keyword">typeof</span> target[key] === <span class="string">'object'</span> &amp;&amp; (target[key] = observeRouterForIE(target[key]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(target).forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 赋值避免栈溢出</span></span><br><span class="line">        <span class="keyword">let</span> currentValue = target[key]</span><br><span class="line">        handler[key] = &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>: function() &#123; </span><br><span class="line">                <span class="keyword">return</span> currentValue</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">                currentValue = newVal</span><br><span class="line">                <span class="comment">// 以下操作为同步store渲染菜单</span></span><br><span class="line">                changeMenuByRoutes(target)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperties(target, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，其实就是用defineProperties去劫持数据，这里需要注意一点是像get与set<strong>不要直接操作target[key]</strong>，为什么呢？因为你已经劫持了这个对象，当你return target[key]时又会触发一次getter，这样不就套娃了吗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要重构&quot;&gt;&lt;a href=&quot;#为什么要重构&quot; class=&quot;headerlink&quot; title=&quot;为什么要重构&quot;&gt;&lt;/a&gt;为什么要重构&lt;/h2&gt;&lt;p&gt;老实说重构我一直觉得是一件费力不讨好的事儿，但是这次的后台项目路由那块确实太乱了，复制粘贴以前项目的，非常生
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Proxy" scheme="http://localhost:4000/tags/Proxy/"/>
    
      <category term="Vue" scheme="http://localhost:4000/tags/Vue/"/>
    
      <category term="重构" scheme="http://localhost:4000/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>柯里化函数</title>
    <link href="http://localhost:4000/2020/08/24/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    <id>http://localhost:4000/2020/08/24/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-24T12:10:33.000Z</published>
    <updated>2020-09-01T03:14:39.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h2><p>假设我们有一个求两个数和的函数，那么一般情况下他的调用的是这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sum(a, b)</span><br></pre></td></tr></table></figure><p>我们将这个函数柯里化:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(a)(b)</span><br></pre></td></tr></table></figure><p>柯里化不会调用函数，只是对函数进行转换。</p><h2 id="最简单的柯里化"><a href="#最简单的柯里化" class="headerlink" title="最简单的柯里化"></a>最简单的柯里化</h2><p>就拿两数求和的例子来说:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(a, b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这个很简单，curry函数接受一个回调后返回第一层函数，第一层函数执行后返回第二层，第二层执行后将a,b参数传入回调函数fn</p><h2 id="无限求和柯里化"><a href="#无限求和柯里化" class="headerlink" title="无限求和柯里化"></a>无限求和柯里化</h2><p>接下来完成一个函数，实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.reduce(<span class="function">(<span class="params">p,n</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p+n</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)() <span class="comment">// 6</span></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)() <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>注意，这里柯里化后的函数其实还有个执行的花括号，是没有传参，因此在花括号前面我们拿到的应该是所有参数的合集，最后的花括号代表fn(1,2,3,4,5…)这样的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">p,n</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p+n</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">currySum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这是第二个括号开始的返回函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 在这里判断是否该完结此次柯里化</span></span><br><span class="line">            <span class="keyword">if</span>(!args2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 反之则继续递归</span></span><br><span class="line">            <span class="keyword">return</span> currySum.apply(<span class="keyword">this</span>, [...args, ...args2])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)() <span class="comment">// 6 </span></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)() <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>这里有几个点需要注意:</p><ul><li>通过第二个返回函数中的参数args2来判断是否完结柯里化</li><li>完结后的参数是args而不是args2，args2永远只是最新的一次调用传参</li><li>没有完结柯里化时递归调用外层的返回函数，并且要将上一次的参数合并</li></ul><h3 id="无限求和柯里化扩展–去掉后面的括号"><a href="#无限求和柯里化扩展–去掉后面的括号" class="headerlink" title="无限求和柯里化扩展–去掉后面的括号"></a>无限求和柯里化扩展–去掉后面的括号</h3><p>上面的例子里面最后总是要打一个括号来执行函数，下面优化一下实现currySum(1)(2)(3)直接输出6的效果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">currySum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里声明函数 赋给一个变量</span></span><br><span class="line">        <span class="keyword">let</span> sumFn = <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!args2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> currySum(...args.concat(args2))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点，我们重写了sumFn函数toString方法，让他返回sumFn函数的执行结果</span></span><br><span class="line">        sumFn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sumFn()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumFn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">p,n</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p+n</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> currySum = curry(sum)</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是柯里化&quot;&gt;&lt;a href=&quot;#什么是柯里化&quot; class=&quot;headerlink&quot; title=&quot;什么是柯里化&quot;&gt;&lt;/a&gt;什么是柯里化&lt;/h2&gt;&lt;p&gt;假设我们有一个求两个数和的函数，那么一般情况下他的调用的是这样:&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="柯里化" scheme="http://localhost:4000/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
      <category term="currying" scheme="http://localhost:4000/tags/currying/"/>
    
  </entry>
  
  <entry>
    <title>ES6-Proxy与Reflect</title>
    <link href="http://localhost:4000/2020/08/20/ES6-Proxy%E4%B8%8EReflect/"/>
    <id>http://localhost:4000/2020/08/20/ES6-Proxy%E4%B8%8EReflect/</id>
    <published>2020-08-20T07:02:17.000Z</published>
    <updated>2020-08-28T01:46:19.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy包装对象的方法</p><table><thead><tr><th>内部方法</th><th>Handler方法</th><th>何时触发</th></tr></thead><tbody><tr><td>[[Get]]</td><td>get</td><td>读取属性</td></tr><tr><td>[[Set]]</td><td>set</td><td>写入属性</td></tr><tr><td>[[HasProperty]]</td><td>has</td><td>in操作符(key in obj)</td></tr><tr><td>[[Delete]]</td><td>deleteProperty</td><td>delete操作符</td></tr><tr><td>[[Call]]</td><td>apply</td><td>函数调用上下文绑定</td></tr><tr><td>[[Construct]]</td><td>construct</td><td>new操作符，构造函数</td></tr><tr><td>[[GetPrototypeOf]]</td><td>getPrototypeOf</td><td>Object.getPrototypeOf</td></tr><tr><td>[[SetPrototypeOf]]</td><td>setPrototypeOf</td><td>Object.setPrototypeOf</td></tr><tr><td>[[IsExtensible]]</td><td>isExtensible</td><td>Object.isExtensible(决定对象是否可扩展)</td></tr><tr><td>[[PreventExtensions]]</td><td>preventExtensions</td><td>Object.preventExtensions</td></tr><tr><td>[[DefineOwnProperty]]</td><td>defineProperty</td><td>Object.defineProperty/defineProperties</td></tr><tr><td>[[GetOwnProperty]]</td><td>getOwnPropertyDescriptor</td><td>Object.getOwnPropertyDescriptor,<br>for…in/Object.keys/Object.values/Object.entries</td></tr><tr><td>[[OwnPropertyKeys]]</td><td>ownKeys</td><td>Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object/keys/values/entries</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>这里我们用get、set和deleteProperty作为例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  userName: <span class="string">'Chow'</span>,</span><br><span class="line">  _userId: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`读取属性:<span class="subst">$&#123;prop&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, prop, value) &#123;</span><br><span class="line">      <span class="keyword">if</span>(target[prop].startsWith(<span class="string">'_'</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">'can not change value'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          target[prop] = value</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  deleteProperty(target, prop) &#123;</span><br><span class="line">      <span class="keyword">if</span>(target[prop].startsWith(<span class="string">'_'</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">'can not delete property that start with _'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">delete</span> target[prop]</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在无法删除以下划线开头的key</span></span><br><span class="line"><span class="keyword">const</span> name = user.userName <span class="comment">// 输出 读取属性:userName</span></span><br><span class="line">user._userId = <span class="number">321</span> <span class="comment">// throw error: can not change value</span></span><br><span class="line"><span class="keyword">delete</span> user._userId <span class="comment">// throw error: can not delete property that start with _</span></span><br></pre></td></tr></table></figure><p>当读取值时会打印读取的属性名，当字段以_开头时将无法删除与修改</p><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>在上面的例子中，可以如预期的得到结果，但是如果存在函数，就会发生意外：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    _name: <span class="string">"User"</span>,</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop] <span class="comment">// target = user</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">    __proto__: userProxy,</span><br><span class="line">    _name: <span class="string">"Admin"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(admin.name) <span class="comment">// 输出 "User"</span></span><br></pre></td></tr></table></figure><p>这里我们的本意是让admin继承user对象，访问admin.name时打印出”Admin”，但最后输出的结果却是”User”，分析一下过程：</p><ul><li>user对象中设置了getter，返回私有属性_name</li><li>user被代理，设置了getter拦截器，返回target[prop]，这里的target是user</li><li>创建admin对象并继承代理后的user对象</li><li>调用admin.name，admin中没有name属性，便顺着原型链找到userProxy</li><li>于是调用代理userProxy的name属性，再次触发getter拦截器，这个时候会从原始对象中返回target[prop]，此时的target还是user</li></ul><p>也就是说我们调用admin.name最后执行的还是user.name！</p><h3 id="使用Reflect解决指向问题"><a href="#使用Reflect解决指向问题" class="headerlink" title="使用Reflect解决指向问题"></a>使用Reflect解决指向问题</h3><p>在proxy代理的拦截器中，有一个receiver参数，通过它我们能够取到正确的上下文环境:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    _name: <span class="string">"User"</span>,</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, prop, receiver) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">    __proto__: userProxy,</span><br><span class="line">    _name: <span class="string">"Admin"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(admin.name) <span class="comment">// 输出 "Admin"</span></span><br></pre></td></tr></table></figure><p>这里的receiver就是admin对象了，因此admin.name正确输出了”Admin”</p><h2 id="Proxy的限制"><a href="#Proxy的限制" class="headerlink" title="Proxy的限制"></a>Proxy的限制</h2><p>对于对象数组我们可以直接监听，对于对象数组，我们也可以通过递归遍历来监听：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observeObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听代理数组与对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="comment">// 递归深度代理</span></span><br><span class="line">            <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> &amp;&amp; (obj[key] = observeRouter(obj[key]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = [</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">'zhou'</span>, <span class="attr">job</span>: <span class="string">'programmer'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'li'</span>, <span class="attr">job</span>: <span class="string">'teacher'</span> &#125;                     </span><br><span class="line">]                     </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personProxy = observeObject(person) <span class="comment">// 代理复杂数组</span></span><br></pre></td></tr></table></figure><p>但是一些内建对象，如<strong>Map</strong>、<strong>Set</strong>、<strong>Date</strong>、<strong>Promise</strong>等都是用了<strong>内部插槽(Internal slot)</strong>。</p><h3 id="内建属性的内部插槽"><a href="#内建属性的内部插槽" class="headerlink" title="内建属性的内部插槽"></a>内建属性的内部插槽</h3><p>如<strong>Map</strong>对象，他的内部成员被放在<strong>[[MapData]]</strong>中，诸如<strong>get</strong>内建方法能够不使用<strong>[[Get]]</strong>直接访问到其中的属性，从上面的Proxy表可以看到，get拦截器是通过<strong>[[Get]]</strong>内建方法来拦截getter，因此Proxy无法拦截它们。所以如果我们像下面这样直接代理Map是行不通的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), mapProxy</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'zhou'</span>)</span><br><span class="line">mapProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">mapProxy.get(<span class="string">'name'</span>) <span class="comment">// 报错：Uncaught TypeError: Method Map.prototype.get called on incompatible receiver [object Object]</span></span><br></pre></td></tr></table></figure><p>代理对象没有<strong>[[MapData]]</strong>插槽，调用mapProxy.get后，内建方法会调用<strong>Map.prototype.get去访问this.[[MapData]]</strong>，但此时this是proxy，proxy中并没有该插槽，因此报错。</p><h3 id="解决部分内建对象无法代理"><a href="#解决部分内建对象无法代理" class="headerlink" title="解决部分内建对象无法代理"></a>解决部分内建对象无法代理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), mapProxy</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'name'</span>, <span class="string">'zhou'</span>)</span><br><span class="line">mapProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop, receiver) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Reflect</span>.get(target, prop, receiver)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'function'</span>?value.bind(target):value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mapProxy.get(<span class="string">'name'</span>) <span class="comment">// 输出：zhou</span></span><br></pre></td></tr></table></figure><p>现在我们把this绑定到了Map对象上，代理的Map正常工作了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Proxy&quot;&gt;&lt;a href=&quot;#Proxy&quot; class=&quot;headerlink&quot; title=&quot;Proxy&quot;&gt;&lt;/a&gt;Proxy&lt;/h2&gt;&lt;p&gt;Proxy包装对象的方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内部方法&lt;/th&gt;
&lt;th&gt;Ha
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Proxy" scheme="http://localhost:4000/tags/Proxy/"/>
    
      <category term="Reflect" scheme="http://localhost:4000/tags/Reflect/"/>
    
  </entry>
  
  <entry>
    <title>Typescript再体验---一些开发中的杂谈</title>
    <link href="http://localhost:4000/2020/08/10/Typescript%E5%86%8D%E4%BD%93%E9%AA%8C-%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%9D%82%E8%B0%88/"/>
    <id>http://localhost:4000/2020/08/10/Typescript%E5%86%8D%E4%BD%93%E9%AA%8C-%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%9D%82%E8%B0%88/</id>
    <published>2020-08-10T12:13:37.000Z</published>
    <updated>2020-08-10T12:49:47.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="keyof映射"><a href="#keyof映射" class="headerlink" title="keyof映射"></a>keyof映射</h2><p>keyof这个关键字在ts中很有用，可以看一下官方的Readonly Partial type：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Readonly将interface或type中的所有属性转为只读项</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: ReadOnly&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'chow'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">22</span> <span class="comment">// 编译报错 因为age是只读属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial将interface或type中的所有属性转为非必选项</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以只传入一个属性甚至不传</span></span><br><span class="line"><span class="keyword">const</span> person: Partial&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">'chow'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个例子，一个非常严谨的字典读取函数:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValue(&#123; name: <span class="string">'chow'</span> &#125;, <span class="string">'name'</span>) <span class="comment">// chow</span></span><br></pre></td></tr></table></figure><p>同样是使用了泛型 keyof</p><h2 id="使用装饰器封装防抖函数"><a href="#使用装饰器封装防抖函数" class="headerlink" title="使用装饰器封装防抖函数"></a>使用装饰器封装防抖函数</h2><p>最近我开发自己的博客有一个上拉加载的功能，我使用了防抖包装，但后面一个输入框又需要防抖，于是我打算用装饰器封装，达到一下效果</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    components: &#123; LoadingWaves &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Article <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">    <span class="keyword">private</span> loading: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> noMore: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> pageNum: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 只需传入延迟时间</span></span><br><span class="line">    <span class="meta">@debounce</span>(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">public</span> loadMore() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.noMore) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">this</span>.pageNum++</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">this</span>.getArticle()</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">delay: <span class="built_in">number</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer: <span class="built_in">number</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 一定要先将本次执行的函数拷贝到变量中</span></span><br><span class="line">        <span class="keyword">const</span> aimFunction = descriptor.value</span><br><span class="line">        descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> args: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">            <span class="keyword">if</span>(timer) clearTimeout(timer)</span><br><span class="line">          <span class="comment">// 第一个是上下文环境，拷贝后续参数</span></span><br><span class="line">            args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">                aimFunction.apply(<span class="keyword">this</span>, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要明确，ts中函数装饰器会拿到三个参数:</p><ul><li>target，装饰函数所在类的构造函数</li><li>key，该函数的名称，即Function.name</li><li>descriptor，即Object.defineProperty() 的第三个参数 descrideptor</li></ul><p>这里为了接受自定义参数，我们用了闭包，返回了一个函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;keyof映射&quot;&gt;&lt;a href=&quot;#keyof映射&quot; class=&quot;headerlink&quot; title=&quot;keyof映射&quot;&gt;&lt;/a&gt;keyof映射&lt;/h2&gt;&lt;p&gt;keyof这个关键字在ts中很有用，可以看一下官方的Readonly Partial type：&lt;/
      
    
    </summary>
    
    
      <category term="经验" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="Typescript" scheme="http://localhost:4000/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>uni-app中利用webview标签使用原生js高德地图</title>
    <link href="http://localhost:4000/2020/07/17/uni-app%E4%B8%AD%E5%88%A9%E7%94%A8webview%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    <id>http://localhost:4000/2020/07/17/uni-app%E4%B8%AD%E5%88%A9%E7%94%A8webview%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/</id>
    <published>2020-07-17T01:54:16.000Z</published>
    <updated>2020-07-17T04:19:43.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用原生的js高德地图"><a href="#为什么要使用原生的js高德地图" class="headerlink" title="为什么要使用原生的js高德地图"></a>为什么要使用原生的js高德地图</h2><p>首先说一下原因，虽然uni-app自带的map也是高德地图，但是这地图确实太鸡肋了，很多功能都没有，自定义的程度也很低，并且犹豫是底层的，因此无法简单的通过z-index设置显示层级。而高德官方的js地图就非常友好了，并且功能齐全，自定义程度高。</p><h2 id="为什么要使用webview"><a href="#为什么要使用webview" class="headerlink" title="为什么要使用webview"></a>为什么要使用webview</h2><p>因为在uni-app中，打包后的手机环境是没有docment对象或是window对象等一些列我们常用的api，没有document对象我们就无法将高德地图的api以script标签的形式引入，这样我们就拿不到AMap的实例了。而使用webview控件，我们可以引入自己的html文件，我们在这个html文件里用script标签引入高德地图便可：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#map-container</span> &#123;</span></span><br><span class="line">width: 100vw;</span><br><span class="line">height: 100vh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://webapi.amap.com/maps?v=1.4.15&amp;key=********&amp;plugin=Map3D,AMap.DistrictLayer,AMap.Scale,AMap.ToolBar"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/webview.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/map.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"map-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要使用原生的js高德地图&quot;&gt;&lt;a href=&quot;#为什么要使用原生的js高德地图&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用原生的js高德地图&quot;&gt;&lt;/a&gt;为什么要使用原生的js高德地图&lt;/h2&gt;&lt;p&gt;首先说一下原因，虽然uni-app自
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="uni-app" scheme="http://localhost:4000/tags/uni-app/"/>
    
      <category term="高德地图" scheme="http://localhost:4000/tags/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>flutter页面重绘问题解决方案</title>
    <link href="http://localhost:4000/2020/07/11/flutter%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://localhost:4000/2020/07/11/flutter%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-07-11T05:54:10.000Z</published>
    <updated>2020-07-11T05:57:10.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IndexedStack"><a href="#IndexedStack" class="headerlink" title="IndexedStack"></a>IndexedStack</h2><p>IndexedStack组件继承自Stack，两个参数</p><ul><li>Index: 当前显示的组件列表中的的第几个</li><li>children: 渲染页面的组件列表</li></ul><p>使用:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">   <span class="built_in">int</span> currentIndex;</span><br><span class="line">   <span class="built_in">List</span>&lt;Widget&gt; pages = [Pages1(), Pages2(), Pages3()];</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   Widget build(BuildContext context) &#123;</span><br><span class="line">   <span class="keyword">return</span> Scaffold(</span><br><span class="line">     appBar: AppBar(</span><br><span class="line">       title: Text(<span class="string">'demo'</span>),</span><br><span class="line">     ),</span><br><span class="line">     bottomNavigationBar: BottomNavigationBar(</span><br><span class="line">       items: items, currentIndex: currentIndex, onTap: onTap),</span><br><span class="line">     body: IndexedStack(</span><br><span class="line">       index: currentIndex,</span><br><span class="line">       children: pages</span><br><span class="line">     )</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在方法配置最简单，但是一进入程序就会直接将pages列表中引用的所有组件都初始化，这样一个是性能消耗问题，另外如果某个页面是有进入动画的，那么在初始化时动画也会被执行，之后再点击去就没有动画了。</p><h2 id="Offstage"><a href="#Offstage" class="headerlink" title="Offstage"></a>Offstage</h2><p>此方法实际是配置隐藏组件，也是两个参数:</p><ul><li><p>Offstage: 设置组件<strong>隐藏</strong>的条件</p></li><li><p>child: 组件</p></li></ul><p>使用：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabBar</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _TabBarState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TabBarState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TabBar</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 在此定义当前tab的索引</span></span><br><span class="line">  <span class="built_in">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">"wave"</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primaryColor: Colors.white</span><br><span class="line">      ),</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: PreferredSize(</span><br><span class="line">          child: (AppBar(title: Text(<span class="string">"标题"</span>), leading: Icon(Icons.list, color: Colors.black), centerTitle: <span class="keyword">true</span>)),</span><br><span class="line">          preferredSize: Size.fromHeight(<span class="number">50</span>)</span><br><span class="line">        ),</span><br><span class="line">        body: Stack(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Offstage(</span><br><span class="line">              offstage: currentIndex != <span class="number">0</span>,</span><br><span class="line">              child: FollowPage(),</span><br><span class="line">            ),</span><br><span class="line">            Offstage(</span><br><span class="line">              offstage: currentIndex != <span class="number">1</span>,</span><br><span class="line">              child: NextPage(),</span><br><span class="line">            ),</span><br><span class="line">            Offstage(</span><br><span class="line">              offstage: currentIndex != <span class="number">2</span>,</span><br><span class="line">              child: MinePage(),</span><br><span class="line">            )</span><br><span class="line">          ]</span><br><span class="line">        ),</span><br><span class="line">        ...</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Offstage组件问题和IndexedStack一样，初始就会将所有空间都渲染了，只是会根据规则隐藏部分。对于有动画的部分使用此空间会导致动画无效。</p><h2 id="AutomaticKeepAliveClientMixin"><a href="#AutomaticKeepAliveClientMixin" class="headerlink" title="AutomaticKeepAliveClientMixin"></a>AutomaticKeepAliveClientMixin</h2><p>AutomaticKeepAliveClientMixin是一个Mixin混入类，使用它能够实现上面两个方法无法完成的效果:</p><ul><li>缓存页面，但不会一开始就把所有页面都渲染。</li><li>只有第一次进入页面时才会渲染页面，触发initState等钩子函数。</li></ul><p>也就是说使用混入类AutomaticKeepAliveClientMixin达成的效果就像我们使用Vue中的页面缓存技术一样，接下来看一下使用方法:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'components/wb-list.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FollowPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; FollowPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FollowPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FollowPage</span>&gt; <span class="title">with</span> <span class="title">AutomaticKeepAliveClientMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在外层定义滚动controller 以便在此控制页面返回顶部</span></span><br><span class="line">  ScrollController _scrollController = ScrollController();</span><br><span class="line"><span class="keyword">final</span> GlobalKey&lt;WBListState&gt; _wbListKey = <span class="keyword">new</span> GlobalKey&lt;WBListState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写AutomaticKeepAliveClientMixin的wantKeepAlive的getter，此属性默认是false</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> wantKeepAlive =&gt; <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 在重写的build方法内一定要注意调用父类的build方法！</span></span><br><span class="line">    <span class="keyword">super</span>.build(context);</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Flexible(</span><br><span class="line">          child: WBList(</span><br><span class="line">            fetchData: wbList,</span><br><span class="line">            scrollController: _scrollController,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下使用AutomaticKeepAliveClientMixin需要注意几点：</p><ul><li><p>重写wanKeepAlive的getter，并返回true</p></li><li><p>在build函数内调用父类的build方法。</p></li><li><p>需要注意，如果你使用类似BottomNavigationBar这种使用底栏进行页面切换，并且切换的页面使用import导入，那么AutomaticKeepAliveClientMixin不能写在BottomNavigationBar所在的父页面！务必进入每个导入的页面为他们书写以上代码。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IndexedStack&quot;&gt;&lt;a href=&quot;#IndexedStack&quot; class=&quot;headerlink&quot; title=&quot;IndexedStack&quot;&gt;&lt;/a&gt;IndexedStack&lt;/h2&gt;&lt;p&gt;IndexedStack组件继承自Stack，两个参数&lt;/p
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="flutter" scheme="http://localhost:4000/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>vue开发中的实用技巧</title>
    <link href="http://localhost:4000/2020/06/22/vue%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://localhost:4000/2020/06/22/vue%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2020-06-22T11:51:23.000Z</published>
    <updated>2020-07-04T03:01:46.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-cli中区分开发、生产环境"><a href="#Vue-cli中区分开发、生产环境" class="headerlink" title="Vue.cli中区分开发、生产环境"></a>Vue.cli中区分开发、生产环境</h2><p>对于在vue脚手架中区分开环境，我一直用的下面的方法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">baseUrl: process.env.NODE_ENV === <span class="string">'development'</span>? xxx.com : yyy.com</span><br></pre></td></tr></table></figure><p>这个方法没毛病，能正常运行，不过还有一种更好的方式，我们可以在项目的根目录创建两个文件:</p><p><img src="/BeCoderQ.github.io/2020/06/22/vue开发中的实用技巧/struct.png" alt="结构"></p><p>.env.production文件与.env.development文件分别是生产环境与开发环境对应的文件，在我们run dev时后者会生效，run build时前者会生效，然后我们利用这点可以轻松的实现类似下面的操作:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在两个文件中我们都设置一个地址变量 当然地址的路径会根据环境而不同</span></span><br><span class="line">VUE_APP_BASE_API = <span class="string">"http://xxx.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来在axios的配置文件中</span></span><br><span class="line">...</span><br><span class="line">baseUrl: process.env.VUE_APP_BASE_API</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样就完成了生产环境与开发环境的区分。</p><h2 id="巧妙利用ref钩子"><a href="#巧妙利用ref钩子" class="headerlink" title="巧妙利用ref钩子"></a>巧妙利用ref钩子</h2><p>在实际业务中，会遇到一些复杂的页面，这些页面我们会把组件抽离出来，那么就会存在参数传递，事件触发等问题，对于上述问题，合理利用ref钩子可以少写不少代码，下面看例子。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"$refs['deal-violation'].onDeal(row)"</span>&gt;</span></span><br><span class="line">          立即处理</span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">electric-deal-violation</span> <span class="attr">ref</span>=<span class="string">"deal-violation"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在子组件内部</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">      onDeal(data) &#123;</span><br><span class="line">          <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的好处是我们让父子通信后子组件的逻辑能在自己内部完成，降低了与父组件的耦合度。需要注意的是，这样的操作并不是所有情况都适用：</p><ul><li><p>如果父组件与子组件有较多的数据来源，那么还是适用props传参，因为这样能一目了然哪些数据会影响子组件。</p></li><li><p>嵌套超过一层的组件不宜使用该方法。</p></li></ul><h2 id="使用-attrs属性二次封装组件"><a href="#使用-attrs属性二次封装组件" class="headerlink" title="使用$attrs属性二次封装组件"></a>使用$attrs属性二次封装组件</h2><p>$attrs这个属性内部是父组件向子组件传递的参数，当然，不包含在子组件内通过props属性注册的。一般我们在嵌套组件内会使用$attrs属性。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里我们二次封装一个elementui的表格+分页组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"pagination"</span> </span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">                <span class="attr">layout</span>=<span class="string">"total, prev, pager, next"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">:total</span>=<span class="string">"total"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">:page-size</span>=<span class="string">"pageSize"</span></span></span><br><span class="line"><span class="tag">                @<span class="attr">current-change</span>=<span class="string">"pageChange"</span></span></span><br><span class="line"><span class="tag">                @<span class="attr">prev-click</span>=<span class="string">"pageChange"</span></span></span><br><span class="line"><span class="tag">                @<span class="attr">next-click</span>=<span class="string">"pageChange"</span></span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们只接收分页的属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 这里只接收了sonTitle属性</span></span><br><span class="line">  props: &#123;</span><br><span class="line">      total: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        pageSize: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们在el-table标签上使用了$attrs属性，这样我们在外部调用这个组件的时候，就能够像直接使用el-table一样传递各种诸如data等属性，除了声明的total与pageSize属性，其他都会被放当$attrs里传递给el-table。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue-cli中区分开发、生产环境&quot;&gt;&lt;a href=&quot;#Vue-cli中区分开发、生产环境&quot; class=&quot;headerlink&quot; title=&quot;Vue.cli中区分开发、生产环境&quot;&gt;&lt;/a&gt;Vue.cli中区分开发、生产环境&lt;/h2&gt;&lt;p&gt;对于在vue脚手架中
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue.cli4" scheme="http://localhost:4000/tags/vue-cli4/"/>
    
      <category term="vue" scheme="http://localhost:4000/tags/vue/"/>
    
  </entry>
  
</feed>

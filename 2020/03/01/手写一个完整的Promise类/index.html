<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="周琦茗在 Github 上的个人博客">
    <meta name="keyword" content="周琦茗">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://gitee.com/zyyzg/blog/images/favicon.ico">
    <link rel="alternate" type="application/atom+xml" title="ChowMe" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        手写一个完整的Promise类｜Chow&#39;s blog
        
    </title>

    <link rel="canonical" href="http://localhost:4000/BeCoderQ.github.io/2020/03/01/手写一个完整的Promise类/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/BeCoderQ.github.io/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/BeCoderQ.github.io/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/BeCoderQ.github.io/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/BeCoderQ.github.io/">
                <span class="brand-logo">
                    ChowMe
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/BeCoderQ.github.io/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/BeCoderQ.github.io/categories/">categories</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/BeCoderQ.github.io/tags/">tags</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="https://gitee.com/zyyzg/blog/images/mountain.jpg">


<style>
    
    header.intro-header {
        background-image: url('https://gitee.com/zyyzg/blog/images/mountain.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>手写一个完整的Promise类</h1>
                    
                    <span class="meta">
                         作者 Chow
                        <span>
                          日期 2020-03-01
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/BeCoderQ.github.io/tags/#Promise"
                           title="Promise">Promise</a>
                        
                        <a class="tag" href="/BeCoderQ.github.io/tags/#异步"
                           title="异步">异步</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            手写一个完整的Promise类
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h2 id="Promise规则"><a href="#Promise规则" class="headerlink" title="Promise规则"></a>Promise规则</h2><p>在实现Promise之前，先看一下Promise的规则，也就是我们要实现的目标。没有太专业的英文术语，都是我自己总结的白话：</p>
<ul>
<li><p>Promise有三个状态，分别为pendding(准备),fufilled(成功),rejected(失败)。这三个状态只能是由pendding-&gt;fufilled或者是pendding-&gt;rejected,状态变更后不可改。实际使用上的效果就是resolve后不能再reject,反之亦然。</p>
</li>
<li><p>Promise是异步执行的，我们要保证当resolve或reject在任务队列末尾时，我们要保证then中的回调函数能够成功执行。</p>
</li>
<li><p>then可以链式调用，并且当then有返回值时，下一个then要能够拿到返回值。也就是说我们会用上递归。</p>
</li>
<li><p>就算不往then中传递某个甚至直接不传递回调参数，链式调用也可以实现，因此在then中我们要对传递的回调函数做相应处理。</p>
</li>
<li><p>对于执行中的错误我们可以使用try-catch来捕获，然后进行处理。</p>
</li>
<li><p>在then中我们的返回值可以还是一个Promise对象，这个时候我们内部拿到这个Promise对象后要进行处理。</p>
</li>
<li><p>异步的核心-任务队列的实现: 发布订阅者模式。</p>
</li>
<li><p>Promise的几个静态方法(我暂时只做了resolve与reject)的实现。</p>
</li>
</ul>
<h2 id="基础骨架"><a href="#基础骨架" class="headerlink" title="基础骨架"></a>基础骨架</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="comment">// 决议值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="comment">// 状态不可变更</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个基础骨架下，我们能实现最基础的功能:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'成功'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>但一旦异步就拉胯了:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 无输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>这也是为什么我们要使用发布-订阅者模式</strong></p>
<h3 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h3><p>看一下最简单的示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventRegister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList = []</span><br><span class="line">    &#125;</span><br><span class="line">    on(key, fn) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.taskList)</span><br><span class="line">        <span class="keyword">this</span>.taskList.push(&#123;</span><br><span class="line">            [key]: fn</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    emit(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fn[key]) fn[key]()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> EventRegister()</span><br><span class="line">my.on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'执行了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	my.emit(<span class="string">'test'</span>) <span class="comment">// 1秒后输出 执行了</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="异步版"><a href="#异步版" class="headerlink" title="异步版"></a>异步版</h2><p>接下来看改进的异步版<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 成功与失败的任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.successList = []</span><br><span class="line">        <span class="keyword">this</span>.failList = []</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="comment">// 决议时再执行队列中的任务，实际上队列里的任务只会有一个，因为每次都是一个新的promise实例</span></span><br><span class="line">            <span class="keyword">this</span>.successList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onFulfilled(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">            <span class="keyword">this</span>.failList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onRejected(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    因为是异步 因此执行到这里的时候还没有resolve改变value与状态，所以将then中的回调函数存入</span></span><br><span class="line"><span class="comment">                    成功事件队列，调用的时机为resolve执行时，resolve时将value传入</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    onFulfilled(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 失败队列</span></span><br><span class="line">            <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    onRejected(reason)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以异步调用了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>接下来就是实现链式调用了</strong></p>
<h2 id="加入链式调用"><a href="#加入链式调用" class="headerlink" title="加入链式调用"></a>加入链式调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...这里相同就略了</span></span><br><span class="line"></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 实现链式调用的重点: 再次返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">                            <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                            resolve(thenReturnValue)</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                            <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">                            onRejected(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                            resolve(thenReturnValue)</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                            onRejected(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                        resolve(thenReturnValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                        onRejected(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                        resolve(thenReturnValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                        onRejected(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式调用的关键是<strong>返回一个Promise对象</strong>，除此之外，我们还要在传递给下一个then时获取上一个then的返回值，之后，我们就可以使用resolve决议给下一个then了</p>
<h3 id="优化链式调用内的重复函数"><a href="#优化链式调用内的重复函数" class="headerlink" title="优化链式调用内的重复函数"></a>优化链式调用内的重复函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        resolve(thenReturnValue)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样代码量就能减少一大截</p>
<h2 id="then的穿透与返回值是Promise时的处理"><a href="#then的穿透与返回值是Promise时的处理" class="headerlink" title="then的穿透与返回值是Promise时的处理"></a>then的穿透与返回值是Promise时的处理</h2><p>标准的Promise可以实现以下功能：</p>
<ul>
<li>then的穿透：不传任何回调函数下一个then也能拿到决议值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'succuess'</span>)</span><br><span class="line">&#125;).then()</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>then的返回值可以是一个新的Promise对象，并且返回了一个新的Promise对象后面的then可以根据这个Promise的决议状态从成功或失败回调中拿到值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'succuess'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="string">'fail'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 无输出值</span></span><br><span class="line">&#125;,rej=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(rej) <span class="comment">// 输出 fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="实现then的穿透"><a href="#实现then的穿透" class="headerlink" title="实现then的穿透"></a>实现then的穿透</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...这里相同就略了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否传入了回调函数 若没有传入 考虑到穿透特性，这里要让其返回当前的value以传递到下一个then中</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 实现链式调用的重点: 再次返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 这部分代码略了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里判断如果没有传入函数我们就自己创建一个，并且注意一定要将返回值设置为this.value，这样才能在我们的checkAndConvert函数内拿到值。</p>
<h3 id="处理返回值是Promise对象的情况"><a href="#处理返回值是Promise对象的情况" class="headerlink" title="处理返回值是Promise对象的情况"></a>处理返回值是Promise对象的情况</h3><p>前面我们封装了处理函数，所以这里直接在这个函数内处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// todo 这里后面还要做处理</span></span><br><span class="line">            resolve(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就把所有返回值的情况处理好了</p>
<h2 id="catch与静态方法resolve-reject"><a href="#catch与静态方法resolve-reject" class="headerlink" title="catch与静态方法resolve/reject"></a>catch与静态方法resolve/reject</h2><p>首先搞明白：</p>
<ul>
<li>catch实际上就是只有失败回调的then方法</li>
<li>resolve与reject静态方法实际就是一个调用了失败决议的新的Promise对象</li>
</ul>
<p>再看看标准Promise的catch行为：</p>
<p>无失败回调时，可以穿透拿到失败决议值，并且catch之后还可以调用then。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>)</span><br><span class="line">&#125;).then()</span><br><span class="line">.then()</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 输出 fail</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'继续'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 继续</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>但是当有失败回调时，catch将不会执行<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>)</span><br><span class="line">&#125;).then(<span class="literal">null</span>, rej=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rej) <span class="comment">// 输出fail</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 无响应</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="catch方法的实现"><a href="#catch方法的实现" class="headerlink" title="catch方法的实现"></a>catch方法的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 这个变量用来判断使用者是否传入了onRejected回调函数，根据这个变量我们可以判断是否调用catch的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> gate = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            gate = <span class="literal">true</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, value, <span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, reason, <span class="literal">false</span>, gate)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">true</span>)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">false</span>, gate)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于checkAndConvert函数:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分别是then的成功失败回调，promise的成功失败决议，决议的参数，失败决议还是成功决议的判断标志，失败决议且没有传递失败回调的标志</span></span><br><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag, rejectFlag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里要注意</span></span><br><span class="line">            <span class="keyword">if</span>(!rejectFlag) resolve(thenReturnValue)</span><br><span class="line">            <span class="keyword">else</span> reject(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在传递个下一个then时，<strong>只有一种情况会调用reject拒绝</strong>：promise决议为拒绝后且用户没有往then函数内传递拒绝参数(也就是第二个回调)，这个时候我们使用reject决议，这样就可以让catch函数顺利执行了，并且这完全符合promise的catch行为: 当then中有第二个回调函数接受上一步抛出的错误后，catch内的回调函数将不会执行反之则会执行。</p>
<h3 id="静态方法resolve与reject"><a href="#静态方法resolve与reject" class="headerlink" title="静态方法resolve与reject"></a>静态方法resolve与reject</h3><p>在实现了上面的代码的基础下，这两个方法实际是最简单的:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际就是返回一个新的Promise对象，再调用对应的决议函数。</p>
<h2 id="大功告成，完整代码"><a href="#大功告成，完整代码" class="headerlink" title="大功告成，完整代码"></a>大功告成，完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag, rejectFlag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                在传递个下一个then时，只有一种情况会调用reject拒绝：promise决议为拒绝后且用户没有往then函数内传递</span></span><br><span class="line"><span class="comment">                拒绝参数(也就是第二个回调)，这个时候我们使用reject决议，这样就可以让catch函数顺利执行了，并且这完全</span></span><br><span class="line"><span class="comment">                符合promise的catch行为: 当then中有第二个回调函数接受上一步抛出的错误后，catch内的回调函数将不会执行</span></span><br><span class="line"><span class="comment">                反之则会执行。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(!rejectFlag) resolve(thenReturnValue)</span><br><span class="line">            <span class="keyword">else</span> reject(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.successList = []</span><br><span class="line">        <span class="keyword">this</span>.failList = []</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="keyword">this</span>.successList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onFulfilled(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">            <span class="keyword">this</span>.failList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onRejected(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 这个变量用来判断使用者是否传入了onRejected回调函数，根据这个变量我们可以判断是否调用catch的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> gate = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 判断是否传入了回调函数 若没有传入 考虑到穿透特性，这里要让其返回当前的value以传递到下一个then中</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            gate = <span class="literal">true</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现链式调用</span></span><br><span class="line">        <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    <span class="comment">/* </span></span><br><span class="line"><span class="comment">                        因为是异步 因此执行到这里的时候还没有resolve改变value与状态，所以将then中的回调函数存入</span></span><br><span class="line"><span class="comment">                        成功事件队列，调用的时机为resolve执行时，resolve时将value传入</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, value, <span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, reason, <span class="literal">false</span>, gate)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">true</span>)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">false</span>, gate)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><del>经过测试，本次手写的Promise能够完全达到与标准Promise相同的效果。</del><br>肯定不能媲美标准的Promise库，不过确实能按预想的实现Promise的所有基本功能，是不是A+规范我还没去研究。</p>
<p>这次手写整个Promise，我花了两天多的时间，第一天中午开始我跟着Youtube上面的大佬写代码，到下午我跟着写完了，然后我自己动手写catch的时候就懵了，对于递归的this指向我一开始没有搞清楚，导致走了很多弯路。之后两天我耐下心打断点，一次一次运行调试，最后终于把整个流程搞透了。期间数次怀疑人生，不过最后还是搞明白了。期间认识到了不足，但也学到了新东西。这就是学习的过程吧？</p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/BeCoderQ.github.io/2020/03/07/puppeteer爬虫工具的使用与踩坑/" data-toggle="tooltip" data-placement="top"
                           title="puppeteer爬虫工具的使用与踩坑">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/BeCoderQ.github.io/2020/02/21/二次封装axios/" data-toggle="tooltip" data-placement="top"
                           title="二次封装axios">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise规则"><span class="toc-text">Promise规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础骨架"><span class="toc-text">基础骨架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发布订阅者模式"><span class="toc-text">发布订阅者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步版"><span class="toc-text">异步版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加入链式调用"><span class="toc-text">加入链式调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化链式调用内的重复函数"><span class="toc-text">优化链式调用内的重复函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#then的穿透与返回值是Promise时的处理"><span class="toc-text">then的穿透与返回值是Promise时的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现then的穿透"><span class="toc-text">实现then的穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理返回值是Promise对象的情况"><span class="toc-text">处理返回值是Promise对象的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#catch与静态方法resolve-reject"><span class="toc-text">catch与静态方法resolve/reject</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#catch方法的实现"><span class="toc-text">catch方法的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法resolve与reject"><span class="toc-text">静态方法resolve与reject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大功告成，完整代码"><span class="toc-text">大功告成，完整代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/BeCoderQ.github.io/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/BeCoderQ.github.io/tags/#Promise"
                           title="Promise">Promise</a>
                        
                        <a class="tag" href="/BeCoderQ.github.io/tags/#异步"
                           title="异步">异步</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/zyyzg">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/zhouqi">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/St7Paul-">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/becoderq">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; ChowMe 2022
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/BeCoderQ.github.io/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/BeCoderQ.github.io/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/BeCoderQ.github.io/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://localhost:4000/BeCoderQ.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->

<script>
    var _baId = 'ac1ba4c0c5c675cde36fb506beabca37';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="https://gitee.com/zyyzg/blog/images/eat.gif">
</body>

</html>

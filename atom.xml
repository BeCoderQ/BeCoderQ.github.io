<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>ChowMe</title>
  <icon>https://www.gravatar.com/avatar/a73d30b0d26382bb941766ce55d0904e</icon>
  <subtitle>Hello,World</subtitle>
  <link href="/BeCoderQ.github.io/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2020-05-31T11:57:07.590Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>Chow</name>
    <email>zhouqm814@sina.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue.cli4版本下跨域代理配置与数据mock</title>
    <link href="http://localhost:4000/2020/05/27/vue-cli4%E7%89%88%E6%9C%AC%E4%B8%8B%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%95%B0%E6%8D%AEmock/"/>
    <id>http://localhost:4000/2020/05/27/vue-cli4%E7%89%88%E6%9C%AC%E4%B8%8B%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%95%B0%E6%8D%AEmock/</id>
    <published>2020-05-27T08:09:01.000Z</published>
    <updated>2020-05-31T11:57:07.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="proxy代理配置"><a href="#proxy代理配置" class="headerlink" title="proxy代理配置"></a>proxy代理配置</h2><p>最近搭了一个项目的架子，接口请求库用的axios，第一个测试接口就给扔了CORS，于是打开vue.config.js文件配置代理服务:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js中</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">port: port,</span><br><span class="line">    open: <span class="literal">false</span>, <span class="comment">// 是否在run起来后自动打开浏览器</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 开启热重载</span></span><br><span class="line">    overlay: &#123;</span><br><span class="line">         warnings: <span class="literal">false</span>,</span><br><span class="line">         errors: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/proxy'</span>: &#123; <span class="comment">// 匹配的地址</span></span><br><span class="line">        target: <span class="string">'真实的请求地址, 如https://real-request-address.com/api...'</span>,</span><br><span class="line">          changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 路径重写，这里就给个空的，因为我配置的方式会让/proxy直接放到请求路径里，所以那并不是真实路径。因此这里重写为空。</span></span><br><span class="line">            pathRewrite: &#123;<span class="string">'^/proxy'</span>: <span class="string">''</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>我是用的是axios，自己根据需求二次封装了，配置项大概在如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 基础url前缀</span></span><br><span class="line">    baseURL: <span class="string">'/proxy'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好后就能直接使用了，需要注意，这里baseUrl设置为vue.config.js中代理所匹配的路径即可。请求发送后，我们看到的请求路径就是本地路径，但实际已经被代理了，能够正常发送并接受返回值了。</p><h2 id="利用脚手架自带的express实现前后端分离"><a href="#利用脚手架自带的express实现前后端分离" class="headerlink" title="利用脚手架自带的express实现前后端分离"></a>利用脚手架自带的express实现前后端分离</h2><p>我的vue.cli4自带了express，同样是在vue.config.js文件中，我们可以通过拦截请求，并使用express实现前端后端分离。首先看一下我的请求文件结构:</p><p><img src="/BeCoderQ.github.io/2020/05/27/vue-cli4版本下跨域代理配置与数据mock/construct.png" alt="请求元数据结构"></p><h3 id="api文件中"><a href="#api文件中" class="headerlink" title="api文件中"></a>api文件中</h3><p>在api里的modules文件下有所有按模块分好的请求地址文件，每个文件内是这样的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apis = &#123;</span><br><span class="line">    <span class="string">"login"</span>: &#123; <span class="attr">url</span>: <span class="string">"/ad/user/auth"</span>, <span class="attr">noToken</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="comment">// 这里的mock后面会解释</span></span><br><span class="line">  <span class="string">"list"</span>: &#123; <span class="attr">url</span>: <span class="string">"/ad/user/list"</span>, <span class="attr">mock</span>: &#123;</span><br><span class="line">      code: <span class="number">0</span>,</span><br><span class="line">      data: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'zhou'</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'ming'</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default apis </span></span><br><span class="line"><span class="built_in">module</span>.exports = apis</span><br></pre></td></tr></table></figure><p>这里不用export导出而用common.js的导出规则是因为还需要在node环境的文件里取到这些元数据。</p><p>下面的index.js文件会将所有接口文件的文件名与文件内的接口地址耦合:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> apiMap = &#123;&#125;</span><br><span class="line"><span class="comment">// 这个fileName用于存储modules下所有文件的文件名</span></span><br><span class="line"><span class="keyword">let</span> fileName = []</span><br><span class="line"><span class="comment">/* 利用webpack的require.context加载modules下所有的接口文件 */</span></span><br><span class="line"><span class="keyword">var</span> moduleFiles = <span class="built_in">require</span>.context(<span class="string">'./modules'</span>, <span class="literal">true</span>, /\.js$/)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取模块下的api配置对象</span></span><br><span class="line"><span class="comment"> * @param moduleName 模块文件名</span></span><br><span class="line"><span class="comment"> * @param apiName 文件下api模块名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">moduleFiles.keys().map(<span class="function"><span class="keyword">function</span>(<span class="params">modulePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleName = modulePath.substr(modulePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, modulePath.length - <span class="number">5</span>)</span><br><span class="line">    fileName.push(moduleName)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里因为modules下的文件都是以module.exports导出，所以要用require的方式拿到导出值</span></span><br><span class="line">fileName.forEach(<span class="function"><span class="params">name</span>=&gt;</span> &#123;</span><br><span class="line">    apiMap[name] = <span class="built_in">require</span>(<span class="string">`./modules/<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里导处的结果将为我封装的axios所用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apiMap</span><br></pre></td></tr></table></figure><p>这样封装的结果就是让我的axios可以以如下的方式调用:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$api.user.login(&#123; <span class="string">'这里传递post参数'</span> &#125;, 这里传递query参数).then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">  成功请求并按照了规定的返回code</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span> &#123;</span><br><span class="line">  请求返回有任何错误或在拦截器中有任何异常</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么，我请求的环境就交代清楚了，接下来就是核心部分了</p><h3 id="在vue-config中拿到元数据并拦截请求"><a href="#在vue-config中拿到元数据并拦截请求" class="headerlink" title="在vue.config中拿到元数据并拦截请求"></a>在vue.config中拿到元数据并拦截请求</h3><p>这一步就是为什么在api的modules文件下，我的所有请求数据都以module.exports方式导出的原因了，因为vu e.config.js文件是纯node环境下运行，像require.context这种api是用不了的！好了直接看代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在最外层，我们要拿到所有接口的数据</span></span><br><span class="line"><span class="keyword">let</span> apiModules = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里要读取modules下的api文件名</span></span><br><span class="line">    <span class="keyword">let</span> files = fs.readdirSync(resolve(<span class="string">'/src/api/modules'</span>))</span><br><span class="line">    <span class="comment">// 拿到所有文件名后放入变量中</span></span><br><span class="line">    files.forEach(<span class="function"><span class="params">fName</span>=&gt;</span> &#123;</span><br><span class="line">      apiModules.push(<span class="built_in">require</span>(resolve(<span class="string">`/src/api/modules/<span class="subst">$&#123;fName&#125;</span>`</span>)))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是读取文件要用同步读取，否则后面express部分代码执行时可能文件还没读取完。</p><p>接下来在configureWebpack属性下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">            before(app) &#123;</span><br><span class="line">              <span class="comment">// 这是我导入的配置文件，这个文件内配置是否需要mock数据</span></span><br><span class="line">                <span class="keyword">if</span>(!defaultSettings.enableMock) <span class="keyword">return</span></span><br><span class="line">              <span class="comment">// 这就是前面拿到的文件名数组</span></span><br><span class="line">                apiModules.forEach(<span class="function"><span class="params">modules</span>=&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">Object</span>.keys(modules).forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(modules[key].mock) &#123;</span><br><span class="line">                            app.post(<span class="string">`/proxy<span class="subst">$&#123;modules[key].url&#125;</span>`</span>, (req, res)=&gt; &#123;</span><br><span class="line">                              <span class="comment">// 这儿我们就拿到在api文件内写的mock假数据啦！</span></span><br><span class="line">                                res.json(modules[key].mock)</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>好了，这样我们就设置完了，在请求后，接口会返回我们在api的modules文件内各个接口中配置的mock属性下的数据，并且与mock.js不同，是能够直接在network里面真实存在的一次请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;proxy代理配置&quot;&gt;&lt;a href=&quot;#proxy代理配置&quot; class=&quot;headerlink&quot; title=&quot;proxy代理配置&quot;&gt;&lt;/a&gt;proxy代理配置&lt;/h2&gt;&lt;p&gt;最近搭了一个项目的架子，接口请求库用的axios，第一个测试接口就给扔了CORS，于
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue.cli4" scheme="http://localhost:4000/tags/vue-cli4/"/>
    
      <category term="跨域" scheme="http://localhost:4000/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>electron打包后文件路径问题(解决子进程文件报错)</title>
    <link href="http://localhost:4000/2020/05/23/electron%E6%89%93%E5%8C%85%E5%90%8E%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
    <id>http://localhost:4000/2020/05/23/electron%E6%89%93%E5%8C%85%E5%90%8E%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/</id>
    <published>2020-05-23T05:33:24.000Z</published>
    <updated>2020-05-23T06:13:56.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近手上有个项目是基于electron（electron-vue）开发的平台监测系统，有一部分数据量非常大，并且是实时更新数据滚动显示，但后台的同学很鸡贼的没有过滤去重就把超多的数据仍给我了，因此数据处理就交给前端了。为了不影响页面的流畅性，我把计算去重等操作放到了子进程中(child_process.fork)。但打包后发现抛出了channel closed的报错（这里的error输出是我手动抓取的）：</p><p><img src="/BeCoderQ.github.io/2020/05/23/electron打包后文件路径问题-解决子进程文件报错/error.png" alt="抓到的报错"></p><p>这个报错我在stackoverflow上看有说版本问题，有说send数据不对。但debug了半天，最后发现实际是打包后子进程文件的路径出了问题。</p><h2 id="在package-json中修改配置"><a href="#在package-json中修改配置" class="headerlink" title="在package.json中修改配置"></a>在package.json中修改配置</h2><p>找到了出错的原因，下一步就好做了，打包后路径有问题，那么我们就在package.json文件中的build属性下，加入下面的配置:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"build"</span>: &#123;</span><br><span class="line">  ...otherConfig,</span><br><span class="line">    <span class="string">"asarUnpack"</span>: [</span><br><span class="line"><span class="string">"**/src/renderer/utils/**/*"</span></span><br><span class="line">],</span><br><span class="line">    <span class="string">"extraResources"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"from"</span>: <span class="string">"src/renderer/utils/worker.js"</span>,</span><br><span class="line">          <span class="string">"to"</span>: <span class="string">"app.asar.unpacked/source/worker.js"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照文档上的说法，<strong><a href="https://github.com/atom/asar" target="_blank" rel="noopener">asar</a> 是一种将多个文件合并成一个文件的类 tar 风格的归档格式。Electron 可以无需解压，即从其中读取任意文件内容。</strong></p><p>那么这里就是配置unpack（不打包）的文件，我的子进程文件放在了utils里，因此这里我配置了utils的路径。</p><p>第二个参数extraResources（直译额外的资源），下面from-to也很明显是要在打包后从哪个路径到哪个路径，实际就是我们自己的具体某个文件需要在打包后存放到哪个路径下。</p><h2 id="主进程文件中"><a href="#主进程文件中" class="headerlink" title="主进程文件中"></a>主进程文件中</h2><p>这里我们设置好了打包后的路径，接下来就在调用子进程的主进程文件内做好开发环境与生产环境的判定就好了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入子进程</span></span><br><span class="line"><span class="keyword">const</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"><span class="comment">// 引入path</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">// 判定当前环境的变量</span></span><br><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV &amp;&amp; process.env.NODE_ENV == <span class="string">'development'</span></span><br><span class="line"><span class="comment">// 子进程的真实路径 注意后面生产环节的路径要与package.json中配置的相同</span></span><br><span class="line"><span class="keyword">let</span> _path = isDev?path.join(__dirname, <span class="string">'worker.js'</span>):path.join(process.resourcesPath, <span class="string">'app.asar.unpacked/source/worker.js'</span>)</span><br><span class="line"><span class="keyword">const</span> worker = childProcess.fork(_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> onMessage = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 以下为我的业务函数 </span></span><br><span class="line">    caculateMsg(clientMsg, serverMsg, callback) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;主进程启动'</span>, _path)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            worker.send(&#123;clientMsg, serverMsg&#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;主进程发送出数据'</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="comment">// 这里回调遵守error-first的设计逻辑</span></span><br><span class="line">            callback(err, <span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!onMessage)</span><br><span class="line">            onMessage = worker.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;子进程的信息:'</span>, msg)</span><br><span class="line">                callback(<span class="literal">null</span>, msg)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近手上有个项目是基于electron（electron-vue）开发的平台监测系统，有一部分数据量非常大，并且是实时更新数
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="electron" scheme="http://localhost:4000/tags/electron/"/>
    
      <category term="webpack" scheme="http://localhost:4000/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>ES6迭代器与生成器</title>
    <link href="http://localhost:4000/2020/05/16/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://localhost:4000/2020/05/16/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2020-05-16T14:18:38.000Z</published>
    <updated>2020-05-23T05:35:44.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h2><p>迭代器是一种特殊的对象,特的结构如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">value</span>: <span class="string">'xxx'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure></p><p>value是下一个将要返回的值，done表示当前迭代是否完成，迭代器内部会保存一个指针，指向当前集合中值的位置，通过调用next()方法返回下一个值，当done为false后，每一次的next()返回的value都会为undefined。</p><h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a>生成器(Generator)</h2><p>生成器函数返回的是一个迭代器，外部通过next方法调用下一个yield。要创建一个生成器函数，可以有以下三种写法</p><ul><li><p>不带空格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">myGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不带空格</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    *myGenerator() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.myGenerator().next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：生成器函数的yield关键字与return类似，不能穿透</strong><br>不能穿透是什么意思呢，看下面的例子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">myGenerator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="params">i</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = myGenerator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">g.next() <span class="comment">// 抛出错误 Uncaught SyntaxError: Unexpected identifier</span></span><br></pre></td></tr></table></figure></p><p>这也就是说yield不能再嵌套函数内使用，所以这里换成普通的for循环就能正常运行了。</p><h3 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span> <span class="comment">// 无视传值</span></span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span> <span class="comment">// 4 + 2</span></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span> <span class="comment">// 7 + 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = myGenerator()</span><br><span class="line">it.next(<span class="number">2</span>) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">4</span>) <span class="comment">// &#123;value: 6, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">7</span>) <span class="comment">// &#123;value: 10, done: false&#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>在生成器函数中yield本身不具有返回值，通过往next中传递参数使其有了返回值，但注意第一个next的参数会被忽略掉，因为next函数本身就是调用的上一次yield值。</p><h3 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h3><p>实际就是将多个迭代器合成一个调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">numberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">stringIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'one'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'two'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'three'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">allIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> *numberIterator()</span><br><span class="line">  <span class="keyword">yield</span> *stringIterator()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'finish'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用就通过allIterator函数</span></span><br><span class="line"><span class="keyword">let</span> all = allIterator()</span><br><span class="line">all.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: 'one', done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: 'two', done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: 'finish', done: false&#125;</span></span><br><span class="line">all.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h2 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for-of循环"></a>for-of循环</h2><p>ES6中加入了for-of循环，对于可迭代对象，使用for-of能遍历出他们的值(value),为什么必须是可迭代的对象呢，因为for-of内部会使用Symbol.iterator属性来迭代，内部其实就如同上面的生成器函数一样，使用next()方法来迭代。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> obj.arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// 依次输出 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样使用for-of是可行的，但是如果我们直接将自建对象obj拿来用for-of，就会抛出异常:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(val <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// Uncaught TypeError: obj is not iterable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>报错说obj是不可迭代的。</p><h3 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h3><p>前面我们说了，for-of内部使用了Symbol.iterator来迭代对象，那么如果我们自己写一个迭代函数，就能够让自建函数使用for-of了：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    property: <span class="string">'属性'</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="comment">// 使用for-in遍历obj，把值yield出去</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">this</span>[key]</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(val <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// 依次输出 [1,2,3]   属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用过这个迭代器函数，实现了自建属性的for-of。实际上，在JavaScript中已经<strong>内置了三种迭代器</strong>，分别是<strong>Object.keys()，Object.values()，Object.entries()</strong>，分别对应了键-值-键值，它们都会以数组的形式输出对应的迭代器内容。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>我们可以使用Symbol.iterator这个自带的函数来判断一个对象是否可迭代:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canIterate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用生成器完成异步任务"><a href="#使用生成器完成异步任务" class="headerlink" title="使用生成器完成异步任务"></a>使用生成器完成异步任务</h2><p>生成器最大的用武之地肯定就是在异步了，下面是一个最简单的实例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">task</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> execuTask(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">yield</span> execuTask(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">yield</span> execuTask(<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = task()</span><br><span class="line">t.next()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execuTask</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'延迟:'</span>, delay)</span><br><span class="line">        result.push(delay)</span><br><span class="line">        <span class="keyword">if</span>(result.length&lt;<span class="number">3</span>) &#123;</span><br><span class="line">            t.next()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, delay)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中的execuTask函数通过传入的延迟时间模拟异步操作，利用生成器在下一个next函数调用前函数会处于中断状态的特性，实现类似于Promise对象then方法的异步调用。执行结果是分别间隔1秒、3秒、6秒输出内容。</p><p><img src="/BeCoderQ.github.io/2020/05/16/迭代器与生成器/yb.png" alt="输出内容"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;迭代器-Iterator&quot;&gt;&lt;a href=&quot;#迭代器-Iterator&quot; class=&quot;headerlink&quot; title=&quot;迭代器(Iterator)&quot;&gt;&lt;/a&gt;迭代器(Iterator)&lt;/h2&gt;&lt;p&gt;迭代器是一种特殊的对象,特的结构如下&lt;br&gt;&lt;figur
      
    
    </summary>
    
    
      <category term="学习" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://localhost:4000/tags/ES6/"/>
    
      <category term="Iterator" scheme="http://localhost:4000/tags/Iterator/"/>
    
      <category term="Generator" scheme="http://localhost:4000/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>canvas实现手写签名并保存为图片</title>
    <link href="http://localhost:4000/2020/04/25/canvas%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E7%AD%BE%E5%90%8D%E5%B9%B6%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/"/>
    <id>http://localhost:4000/2020/04/25/canvas%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E7%AD%BE%E5%90%8D%E5%B9%B6%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87/</id>
    <published>2020-04-25T05:50:24.000Z</published>
    <updated>2020-04-25T07:14:28.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>最近做的一个表单页最后需要勾选同意选项，然后弹出一个手写签名的弹出层，在用户签名保存后将用户画出来的线条保存为base64图片通过接口上传。对此需求，canvas简直再适合不过了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现上比较简单，主要是使用线条相关绘画的api，也就是moveTo，lineTo。这里我提供pc端的绘画，手机端也是一样的，仅需要修改绑定的事件。</p><ul><li>构造函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SignCanvas</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装为一个类，接受目标元素以及各类配置项</span></span><br><span class="line">    <span class="keyword">constructor</span>(selector, options = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(selector);</span><br><span class="line">        <span class="keyword">this</span>.canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">        <span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.canvas);</span><br><span class="line">        <span class="keyword">this</span>.ctx = <span class="keyword">this</span>.canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">        <span class="keyword">this</span>.canvas.width = <span class="keyword">this</span>.el.clientWidth * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.canvas.height = <span class="keyword">this</span>.el.clientHeight * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.ctx.fillStyle = options.bg || <span class="string">"#ffffff"</span>;</span><br><span class="line">        <span class="comment">// 填充矩形</span></span><br><span class="line">        <span class="keyword">this</span>.ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.canvas.width, <span class="keyword">this</span>.canvas.width);</span><br><span class="line">        <span class="keyword">this</span>.ctx.strokeStyle = options.color || <span class="string">"#000000"</span>;</span><br><span class="line">        <span class="keyword">this</span>.ctx.lineWidth = options.lw || <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.ctx.lineCap = <span class="string">"round"</span>;</span><br><span class="line">        <span class="comment">// 这个变量用于判断当前鼠标是否按下 因为我们的操作逻辑是按下鼠标拖动才可以绘画</span></span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 主要的事件函数</span></span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">        <span class="keyword">this</span>.end()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里现把主要的配置写好了，我们可以设置canvas的线条颜色，填充颜色等。</p><ul><li>功能函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    start() &#123;</span><br><span class="line">        <span class="keyword">this</span>.canvas.onmousedown = <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.stop = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">this</span>.ctx.beginPath();</span><br><span class="line">            <span class="keyword">this</span>.ctx.moveTo(</span><br><span class="line">                e.layerX,</span><br><span class="line">                e.layerY</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">this</span>.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    draw() &#123;</span><br><span class="line">        <span class="keyword">this</span>.canvas.onmousemove = <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.stop) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">this</span>.ctx.lineTo(</span><br><span class="line">                e.layerX,</span><br><span class="line">                e.layerY</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">this</span>.ctx.stroke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 松开鼠标结束绘画</span></span><br><span class="line">    end() &#123;</span><br><span class="line">        <span class="keyword">this</span>.canvas.onmouseup = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.stop = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除画布</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx.clearRect(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="keyword">this</span>.canvas.width,</span><br><span class="line">            <span class="keyword">this</span>.canvas.height</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存通过canvas的内置方法转为base64的图片</span></span><br><span class="line">    save() &#123;</span><br><span class="line">        <span class="keyword">let</span> imgBase64 = <span class="keyword">this</span>.canvas.toDataURL();</span><br><span class="line">        <span class="keyword">return</span> imgBase64;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>因为比较简单，所有功能函数就一并写出来了，这里面，start作为一个初始化的函数，这里对于pc端主要要注意需要一个stop作为是否松开鼠标的判断，另外就是要注意this的指向问题，这里也是全部使用了箭头函数。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这里以vue+element-ui中使用为例子<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line">                清除</span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"save"</span>&gt;</span></span><br><span class="line">                保存</span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SignCanvas <span class="keyword">from</span> <span class="string">'./SignCanvas'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        drawLine: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="keyword">this</span>.drawLine = <span class="keyword">new</span> SignCanvas(<span class="string">'#canvas'</span>, &#123;</span><br><span class="line">            color: <span class="string">'yellow'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 清除画布</span></span><br><span class="line">        clear() &#123;</span><br><span class="line">            <span class="keyword">this</span>.drawLine.clear()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 保存图片 函数将返回base64的编码</span></span><br><span class="line">        save() &#123;</span><br><span class="line">            <span class="keyword">let</span> base64 = <span class="keyword">this</span>.drawLine.save()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2020/04/25/canvas实现手写签名并保存为图片/canvas-sign.png" alt="完成效果"><br>调用非常简单，这样就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;最近做的一个表单页最后需要勾选同意选项，然后弹出一个手写签名的弹出层，在用户签名保存后将用户画出来的线条保存为base64图片通过接口上传。
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="canvas" scheme="http://localhost:4000/tags/canvas/"/>
    
      <category term="手写签名" scheme="http://localhost:4000/tags/%E6%89%8B%E5%86%99%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>解决uni-app编译后自定义指令中绑定事件无效问题</title>
    <link href="http://localhost:4000/2020/04/11/%E8%A7%A3%E5%86%B3uni-app%E7%BC%96%E8%AF%91%E5%90%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://localhost:4000/2020/04/11/%E8%A7%A3%E5%86%B3uni-app%E7%BC%96%E8%AF%91%E5%90%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-11T07:15:14.000Z</published>
    <updated>2020-04-11T07:41:38.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>自定义指令在vue中我使用得不多，但最近遇到一个业务场景非常适合，需求是在用户点击某些页面跳转按钮但是没有登录的时，拦截跳转，弹出登录popup组件。看到这个需求我第一时间就想到了使用全局指令，并且因为全局指令诸如bind、inserted等钩子函数内能获取到目标元素实例与传递的参数，这样就非常好解决了。</p><h2 id="遇到坑"><a href="#遇到坑" class="headerlink" title="遇到坑"></a>遇到坑</h2><p>我在H5环境下，一切如预期运行良好，下面看看代码<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"a"</span> <span class="attr">v-checklogin</span>=<span class="string">"&#123; _this: this, url: '../me/forHelp/index' &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"/static/images/icon/forHelp.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>点单<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在项目的入口main文件中:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'checklogin'</span>, &#123;</span><br><span class="line">    bind (el, &#123;<span class="attr">value</span>: &#123;_this, url&#125;&#125;) &#123;</span><br><span class="line">        <span class="comment">// 参数分别为当前元素实例，调用指令的上下文环境，以及如果登录后要跳转的页面的url</span></span><br><span class="line">        el.onclick = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 根据token是否存在来判断是否需要弹出</span></span><br><span class="line">            <span class="keyword">if</span> (getState(<span class="string">'api'</span>,<span class="string">'token'</span>)) &#123;</span><br><span class="line">                uni.navigateTo(&#123;</span><br><span class="line">                    url: url</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_this.show = <span class="literal">true</span> <span class="comment">// show控制弹出层是否弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>做完这些在H5运行良好，但第二天我尝试了编译在手机上运行后就拉垮了，怎么点都没反应，并且扔了一堆红字给我：</p><ul><li>Property or method “toJSON” is not defined on the instance but referenced during render.</li><li>TypeError: JSON.stringify cannot serialize cyclic structures.</li></ul><h2 id="出坑之路"><a href="#出坑之路" class="headerlink" title="出坑之路"></a>出坑之路</h2><p>这上面的代码在编译后有比较严重的问题，下面依次来说一下</p><h3 id="编译后的上下文传递问题"><a href="#编译后的上下文传递问题" class="headerlink" title="编译后的上下文传递问题"></a>编译后的上下文传递问题</h3><p>上面的代码我在v-checklogin的参数中直接传递了this，这在H5环境没有问题，但是编译后会报错，其实都是因为编译后序列化this会是一个死循环，所以这里我做了一下处理:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 通过函数返回值的方式传递</span></span><br><span class="line">        context() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"a"</span> <span class="attr">v-checklogin</span>=<span class="string">"&#123; context, url: '../me/forHelp/index' &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"/static/images/icon/forHelp.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>点单<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这样第一个问题就解决了</strong></p><h3 id="编译后点击事件失效"><a href="#编译后点击事件失效" class="headerlink" title="编译后点击事件失效"></a>编译后点击事件失效</h3><p>这个就很坑爹了，我找了半天，最后debug发现是uni-app编译后重写了VNode,也就是说编译后的el是一个’虚假的’元素，我们无法通过他直接绑定事件！对此我有点懵逼，在研究了一下后，我发现这个el对象是可以在events中看到直接在元素上@click绑定的事件的！那么，我们要做的就是<strong>劫持这个函数</strong>！</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"a"</span> <span class="attr">v-checklogin</span>=<span class="string">"&#123; context, url: '../me/forHelp/index' &#125;"</span> @<span class="attr">click</span>=<span class="string">"()=&gt;&#123;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"/static/images/icon/forHelp.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>点单<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>首先我们绑定一个事件，直接给个空的匿名函数就行了</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'checklogin'</span>, &#123;</span><br><span class="line">    bind (el, &#123;<span class="attr">value</span>: &#123;context, url&#125;&#125;) &#123;</span><br><span class="line"><span class="comment">//#ifdef APP-PLUS</span></span><br><span class="line"><span class="comment">// 编译后重写了VNode 事件在一个循环队列中，这里劫持自定义指令的元素，重写click事件</span></span><br><span class="line">el.events.click = [<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (getState(<span class="string">'api'</span>,<span class="string">'token'</span>)) &#123;</span><br><span class="line">    uni.navigateTo(&#123;</span><br><span class="line">        url: url</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">context().show = <span class="literal">false</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">context().show = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发环境下</span></span><br><span class="line"><span class="comment">//#ifdef H5</span></span><br><span class="line">        el.onclick = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState(<span class="string">'api'</span>,<span class="string">'token'</span>)) &#123;</span><br><span class="line">                uni.navigateTo(&#123;</span><br><span class="line">                    url: url</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">context().show = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>考虑到开发调试，我还是把直接绑定的方法写在里面，当然要判断下当前环境，这样问题就完美解决了，现在无论在APP端还是H5端都能完美运行了！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h2&gt;&lt;p&gt;自定义指令在vue中我使用得不多，但最近遇到一个业务场景非常适合，需求是在用户点击某些页面跳转按钮但是没有登录的时，拦截跳转
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="uni-app" scheme="http://localhost:4000/tags/uni-app/"/>
    
      <category term="directive" scheme="http://localhost:4000/tags/directive/"/>
    
  </entry>
  
  <entry>
    <title>在js中使用canvas压缩图片</title>
    <link href="http://localhost:4000/2020/04/07/%E5%9C%A8js%E4%B8%AD%E4%BD%BF%E7%94%A8canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
    <id>http://localhost:4000/2020/04/07/%E5%9C%A8js%E4%B8%AD%E4%BD%BF%E7%94%A8canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</id>
    <published>2020-04-07T06:45:13.000Z</published>
    <updated>2020-04-11T07:16:33.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js中简单实用的图片压缩"><a href="#js中简单实用的图片压缩" class="headerlink" title="js中简单实用的图片压缩"></a>js中简单实用的图片压缩</h2><p>最近在业务中遇到一个问题，因为现在手机的像素越来越高了，拍出来的相片大小动辄就是4、5M，用户那边反应上传图片很慢，因此我便加入了一个压缩的功能。</p><h3 id="talk-is-cheap-show-me-the-code"><a href="#talk-is-cheap-show-me-the-code" class="headerlink" title="talk is cheap, show me the code"></a>talk is cheap, show me the code</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base64转为blob流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64UrlToBlob</span> (<span class="params">urlData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = urlData.split(<span class="string">','</span>),</span><br><span class="line">        mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>], <span class="comment">// 去掉url的头，并转化为byte</span></span><br><span class="line">        bstr = atob(arr[<span class="number">1</span>]), <span class="comment">// 处理异常,将ascii码小于0的转换为大于0</span></span><br><span class="line">        n = bstr.length,</span><br><span class="line">        u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n)</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">      u8arr[n] = bstr.charCodeAt(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转blob</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'转码完成'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123;<span class="attr">type</span>: mime&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// canvas压缩 参数为文件，配置项，以及图片的最大限制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasDataURL</span> (<span class="params">file, obj, maxSize = <span class="number">512</span> * <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">            <span class="comment">// 这里其实只是粗略算一下压缩比，不同图片大小不同</span></span><br><span class="line">            <span class="keyword">let</span> cutCount = <span class="built_in">Math</span>.ceil(file.size / maxSize)</span><br><span class="line">            img.src = file.fullPath</span><br><span class="line">            img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> that = <span class="keyword">this</span> <span class="comment">// 指到img</span></span><br><span class="line">                <span class="keyword">let</span> quality = <span class="number">0.5</span> <span class="comment">// 默认图片质量为0.5</span></span><br><span class="line">                <span class="comment">// 默认按比例压缩</span></span><br><span class="line">                <span class="keyword">let</span> w = that.width,</span><br><span class="line">                    h = that.height,</span><br><span class="line">                w = w / cutCount</span><br><span class="line">                h = h / cutCount</span><br><span class="line">                <span class="comment">// 生成canvas</span></span><br><span class="line">                <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">                <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">                <span class="comment">// 创建属性节点</span></span><br><span class="line">                <span class="keyword">let</span> anw = <span class="built_in">document</span>.createAttribute(<span class="string">'width'</span>)</span><br><span class="line">                anw.nodeValue = w</span><br><span class="line">                <span class="keyword">let</span> anh = <span class="built_in">document</span>.createAttribute(<span class="string">'height'</span>)</span><br><span class="line">                anh.nodeValue = h</span><br><span class="line">                canvas.setAttributeNode(anw)</span><br><span class="line">                canvas.setAttributeNode(anh)</span><br><span class="line">                ctx.drawImage(that, <span class="number">0</span>, <span class="number">0</span>, w, h)</span><br><span class="line">                <span class="comment">// 图像质量</span></span><br><span class="line">                <span class="keyword">if</span> (obj.quality &amp;&amp; obj.quality &gt;= <span class="number">1</span> &amp;&amp; obj.quality &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    quality = obj.quality</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// quality值越小，所绘制出的图像越模糊</span></span><br><span class="line">                <span class="keyword">let</span> base64 = canvas.toDataURL(<span class="string">'image/*'</span>, quality)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'canvas压缩完毕'</span>)</span><br><span class="line">                <span class="comment">// 回调函数返回base64的值 可以直接调用接口上传base64编码值，也可以实用上面的base64转blob之后再发送</span></span><br><span class="line">                resolve(base64)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'canvas处理出错:'</span> ,err)</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js中简单实用的图片压缩&quot;&gt;&lt;a href=&quot;#js中简单实用的图片压缩&quot; class=&quot;headerlink&quot; title=&quot;js中简单实用的图片压缩&quot;&gt;&lt;/a&gt;js中简单实用的图片压缩&lt;/h2&gt;&lt;p&gt;最近在业务中遇到一个问题，因为现在手机的像素越来越高了，拍出
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="canvas" scheme="http://localhost:4000/tags/canvas/"/>
    
      <category term="图片压缩" scheme="http://localhost:4000/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>~ | &amp; ^操作符与二进制基础：原码反码补码</title>
    <link href="http://localhost:4000/2020/03/18/%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://localhost:4000/2020/03/18/%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-18T10:18:36.000Z</published>
    <updated>2020-04-11T06:43:53.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>我们都知道计算机只认识0和1，因此所有复杂的计算都是建立在0和1上面，换句话说，再复杂的代码，最后都会转换为0和1。对于操作符，理解了底层运算原理后，就一目了然了</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码实际上是为了表示数字的正负出现的，它的最高位0与1分别代表正与负，下面以32为计算机中的数字5举例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// -5</span></span><br></pre></td></tr></table></figure></p><p>这样解决了正负问题，但是两数相加，很容易发现，结果并不为0，最明显的是最高位正负相加后永远是1，即负数，于是就有了<strong>反码</strong></p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>对于正数，反码没有任何变化，而负数就是对原码取反，当然，除了最高位，还是以上面的-5为例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// -5 原码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> <span class="comment">// -5 反码</span></span><br></pre></td></tr></table></figure></p><p>把-5的反码和5的反码相加：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 5 反码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> <span class="comment">// -5 反码</span></span><br></pre></td></tr></table></figure></p><p>这样相加，结果就是<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">// -0</span></span><br></pre></td></tr></table></figure></p><p>结果实际就是0的反码，即为-0，这样还是有问题，这是一个带符号的负0。因此补码就出现了。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>同样，对于正数，补码还是没变，对于负数，补码就是在反码的基础上在结尾+1<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span> <span class="comment">// -5 反码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> <span class="comment">// -5 补码</span></span><br></pre></td></tr></table></figure></p><p>最后-5的补码和5的补码相加<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 5 补码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> <span class="comment">// -5 补码</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="comment">// 结尾</span></span><br></pre></td></tr></table></figure></p><p>结尾的1就像多米诺一样，然前面的二进制数全部进位，最后结果就是0啦。这也是为什么计算机使用补码来存储数据。</p><h2 id="JavaScript中的操作符"><a href="#JavaScript中的操作符" class="headerlink" title="JavaScript中的操作符"></a>JavaScript中的操作符</h2><p>其实理解了上面32位原、反、补码后，js中位元算符的原理就非常好理解了</p><h3 id="按位与-amp-、按位或"><a href="#按位与-amp-、按位或" class="headerlink" title="按位与(&amp;)、按位或(|)"></a>按位与(&amp;)、按位或(|)</h3><p>对两边操作数的补码进行相与(相或)运算，还是拿5与-5来举例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 5 补码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> <span class="comment">// -5 补码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行相与运算</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span> <span class="comment">// 结果为1</span></span><br><span class="line"><span class="comment">// 进行相或运算</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></p><h3 id="按位异或-、按位非-～"><a href="#按位异或-、按位非-～" class="headerlink" title="按位异或(^)、按位非(～)"></a>按位异或(^)、按位非(～)</h3><p>原理相同 按位异或与或不同的是只能有一个1才为1，按位非就是反转操作数的比特位，即0变1，1变0，实际上只需要在补码末尾+1即可<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> <span class="comment">// 5 补码</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span> <span class="comment">// -5 补码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行异或运算</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111110</span> <span class="comment">// -2 </span></span><br><span class="line"><span class="comment">// 对5进行非运算 ～5</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111110</span> <span class="comment">// 末尾+1 -6</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二进制&quot;&gt;&lt;a href=&quot;#二进制&quot; class=&quot;headerlink&quot; title=&quot;二进制&quot;&gt;&lt;/a&gt;二进制&lt;/h2&gt;&lt;p&gt;我们都知道计算机只认识0和1，因此所有复杂的计算都是建立在0和1上面，换句话说，再复杂的代码，最后都会转换为0和1。对于操作符，理解
      
    
    </summary>
    
    
      <category term="操作符" scheme="http://localhost:4000/categories/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
    
      <category term="操作符" scheme="http://localhost:4000/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="计算机基础" scheme="http://localhost:4000/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="二进制" scheme="http://localhost:4000/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>puppeteer爬虫工具的使用与踩坑</title>
    <link href="http://localhost:4000/2020/03/07/puppeteer%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B8%A9%E5%9D%91/"/>
    <id>http://localhost:4000/2020/03/07/puppeteer%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%B8%A9%E5%9D%91/</id>
    <published>2020-03-07T07:53:20.000Z</published>
    <updated>2020-03-07T07:57:51.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于puppeteer"><a href="#关于puppeteer" class="headerlink" title="关于puppeteer"></a>关于puppeteer</h2><p>还记得前年我想要完成一个网页脚本，但局限于只知道console里输代码，页面如果一条转就拉胯了。后来知道了chrome插件，才写出了一个能够模拟真人的脚本。而puppeteer就可以实现chrome插件的效果，并且还支持可视化的操作(当然一般只有调试时才打开)，非常方便。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.click(元素)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'完成了'</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">    <span class="comment">// 监听console 并输出在terminal</span></span><br><span class="line">    page.on(<span class="string">'console'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>首先当然是<strong>npm install puppetter</strong>了，然后我们引入进来</li><li>需要一个browser对象控制浏览器的打开关闭</li><li>需要一个page对象负责当前窗口的一系列操作</li><li>如同EventEmiter用on可以对console监控</li></ul><p>这里要注意一点，<strong>如果点击按钮后会跳转页面的话，我们要做一个延时处理</strong>，当然像上面这样写死一个时间是不合理的，下面我会单独说一下。</p><h2 id="点击后页面跳转的处理"><a href="#点击后页面跳转的处理" class="headerlink" title="点击后页面跳转的处理"></a>点击后页面跳转的处理</h2><p>下面看一个简单的demo<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="comment">// 假设点击这个元素后页面跳转了</span></span><br><span class="line">    <span class="keyword">await</span> page.click(元素)</span><br><span class="line">    <span class="comment">// 官方文档写的页面跳转等待api 默认30秒等待时间</span></span><br><span class="line">    <span class="keyword">await</span> page.waitForNavigation()</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'完成了'</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">    page.on(<span class="string">'console'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>这里我们假设点击跳转后马上截图，这么看是没毛病的，但实际运行你会发现终端会给你抛一个错出来大概是<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">TimeoutError: Navigation Timeout</span><br></pre></td></tr></table></figure></p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>我在StackOverflow上看到有人说是时间设置短了，但实际上并非如此，因为我如下所示，设置timeout：0,也就是永远等待，虽然没报错了，但也一直卡那儿了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并非时间的问题</span></span><br><span class="line"><span class="keyword">await</span> page.waitForNavigation(&#123;</span><br><span class="line">    timeout: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>会不会是页面跳转太快导致到了新页面waitForNavigation函数才执行呢？那么我就换了一个思路，我自己来判断页面有没有跳转吧！</p><h3 id="解决跳转问题"><a href="#解决跳转问题" class="headerlink" title="解决跳转问题"></a>解决跳转问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForEscape</span>(<span class="params">page, selector, delay</span>) </span>&#123;</span><br><span class="line">    page.$(selector).then( <span class="keyword">async</span> ($el)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>($el) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'enter clicked'</span>)</span><br><span class="line">            <span class="keyword">await</span> page.click(selector)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'-----no selector loop'</span>)</span><br><span class="line">            <span class="keyword">await</span> page.waitFor(delay)</span><br><span class="line">            waitForEscape(page, selector, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless: <span class="literal">true</span>,</span><br><span class="line">        ignoreDefaultArgs: [<span class="string">"--enable-automation"</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    cookies.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        page.setCookie(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="comment">// 假设点击这个元素后页面跳转了</span></span><br><span class="line">    <span class="keyword">await</span> page.click(元素)</span><br><span class="line">    <span class="comment">// 传入当前实例，递归直到页面跳转</span></span><br><span class="line">    waitForEscape(page, <span class="string">'selector'</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'完成了'</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">    <span class="comment">// 监听console 并输出在terminal</span></span><br><span class="line">    page.on(<span class="string">'console'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这样问题就解决了，我们通过自己写的一个函数递归，参数为当前页面实例，目标元素选择器，延迟时间。跳出条件是当前page对象的页面下有我们跳转后的目标页面的某个元素，内部通过传入的delay参数使用waitFor函数设置延迟。</p><h3 id="阴沟翻船"><a href="#阴沟翻船" class="headerlink" title="阴沟翻船"></a>阴沟翻船</h3><p>最后其实还遇到个小问题，我需要写一个定时抢口罩的脚本，口罩是晚上八点开抢，于是我就像下面这么写了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">await</span> page.waitFor(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>,<span class="number">03</span>,<span class="number">07</span>,<span class="number">20</span>,<span class="number">00</span>,<span class="number">00</span>).getTime() - <span class="built_in">Date</span>.now())</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>乍一看好像没问题，等待目标时间减去当前时间，然后执行任务，但是算出来的毫秒数不对，我一是还没反应过来，知道我把毫秒转成天，发现多了30天。。。。好吧，我忘了要减去一个月了！！！</p><p>所以推荐这种写法:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">await</span> page.waitFor(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020/03/07/ 20:00:00'</span>).getTime() - <span class="built_in">Date</span>.now())</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这样就没问题了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于puppeteer&quot;&gt;&lt;a href=&quot;#关于puppeteer&quot; class=&quot;headerlink&quot; title=&quot;关于puppeteer&quot;&gt;&lt;/a&gt;关于puppeteer&lt;/h2&gt;&lt;p&gt;还记得前年我想要完成一个网页脚本，但局限于只知道console里输代
      
    
    </summary>
    
    
      <category term="爬虫" scheme="http://localhost:4000/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="puppeteer" scheme="http://localhost:4000/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>手写一个完整的Promise类</title>
    <link href="http://localhost:4000/2020/03/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Promise%E7%B1%BB/"/>
    <id>http://localhost:4000/2020/03/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Promise%E7%B1%BB/</id>
    <published>2020-03-01T08:50:40.000Z</published>
    <updated>2020-03-05T09:13:33.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise规则"><a href="#Promise规则" class="headerlink" title="Promise规则"></a>Promise规则</h2><p>在实现Promise之前，先看一下Promise的规则，也就是我们要实现的目标。没有太专业的英文术语，都是我自己总结的白话：</p><ul><li><p>Promise有三个状态，分别为pendding(准备),fufilled(成功),rejected(失败)。这三个状态只能是由pendding-&gt;fufilled或者是pendding-&gt;rejected,状态变更后不可改。实际使用上的效果就是resolve后不能再reject,反之亦然。</p></li><li><p>Promise是异步执行的，我们要保证当resolve或reject在任务队列末尾时，我们要保证then中的回调函数能够成功执行。</p></li><li><p>then可以链式调用，并且当then有返回值时，下一个then要能够拿到返回值。也就是说我们会用上递归。</p></li><li><p>就算不往then中传递某个甚至直接不传递回调参数，链式调用也可以实现，因此在then中我们要对传递的回调函数做相应处理。</p></li><li><p>对于执行中的错误我们可以使用try-catch来捕获，然后进行处理。</p></li><li><p>在then中我们的返回值可以还是一个Promise对象，这个时候我们内部拿到这个Promise对象后要进行处理。</p></li><li><p>异步的核心-任务队列的实现: 发布订阅者模式。</p></li><li><p>Promise的几个静态方法(我暂时只做了resolve与reject)的实现。</p></li></ul><h2 id="基础骨架"><a href="#基础骨架" class="headerlink" title="基础骨架"></a>基础骨架</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="comment">// 决议值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="comment">// 状态不可变更</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个基础骨架下，我们能实现最基础的功能:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'成功'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>但一旦异步就拉胯了:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 无输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>这也是为什么我们要使用发布-订阅者模式</strong></p><h3 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h3><p>看一下最简单的示例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventRegister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList = []</span><br><span class="line">    &#125;</span><br><span class="line">    on(key, fn) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.taskList)</span><br><span class="line">        <span class="keyword">this</span>.taskList.push(&#123;</span><br><span class="line">            [key]: fn</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    emit(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fn[key]) fn[key]()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> EventRegister()</span><br><span class="line">my.on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">my.emit(<span class="string">'test'</span>) <span class="comment">// 1秒后输出 执行了</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><h2 id="异步版"><a href="#异步版" class="headerlink" title="异步版"></a>异步版</h2><p>接下来看改进的异步版<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 成功与失败的任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.successList = []</span><br><span class="line">        <span class="keyword">this</span>.failList = []</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="comment">// 决议时再执行队列中的任务，实际上队列里的任务只会有一个，因为每次都是一个新的promise实例</span></span><br><span class="line">            <span class="keyword">this</span>.successList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onFulfilled(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">            <span class="keyword">this</span>.failList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onRejected(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    因为是异步 因此执行到这里的时候还没有resolve改变value与状态，所以将then中的回调函数存入</span></span><br><span class="line"><span class="comment">                    成功事件队列，调用的时机为resolve执行时，resolve时将value传入</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    onFulfilled(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 失败队列</span></span><br><span class="line">            <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                    onRejected(reason)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以异步调用了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>接下来就是实现链式调用了</strong></p><h2 id="加入链式调用"><a href="#加入链式调用" class="headerlink" title="加入链式调用"></a>加入链式调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...这里相同就略了</span></span><br><span class="line"></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 实现链式调用的重点: 再次返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">                            <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                            resolve(thenReturnValue)</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                            <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">                            onRejected(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                            resolve(thenReturnValue)</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                            onRejected(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                        resolve(thenReturnValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                        onRejected(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> thenReturnValue = onFulfilled(value)</span><br><span class="line">                        resolve(thenReturnValue)</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                        onRejected(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链式调用的关键是<strong>返回一个Promise对象</strong>，除此之外，我们还要在传递给下一个then时获取上一个then的返回值，之后，我们就可以使用resolve决议给下一个then了</p><h3 id="优化链式调用内的重复函数"><a href="#优化链式调用内的重复函数" class="headerlink" title="优化链式调用内的重复函数"></a>优化链式调用内的重复函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        resolve(thenReturnValue)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码量就能减少一大截</p><h2 id="then的穿透与返回值是Promise时的处理"><a href="#then的穿透与返回值是Promise时的处理" class="headerlink" title="then的穿透与返回值是Promise时的处理"></a>then的穿透与返回值是Promise时的处理</h2><p>标准的Promise可以实现以下功能：</p><ul><li>then的穿透：不传任何回调函数下一个then也能拿到决议值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'succuess'</span>)</span><br><span class="line">&#125;).then()</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>then的返回值可以是一个新的Promise对象，并且返回了一个新的Promise对象后面的then可以根据这个Promise的决议状态从成功或失败回调中拿到值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'succuess'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="string">'fail'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 无输出值</span></span><br><span class="line">&#125;,rej=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(rej) <span class="comment">// 输出 fail</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现then的穿透"><a href="#实现then的穿透" class="headerlink" title="实现then的穿透"></a>实现then的穿透</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...这里相同就略了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否传入了回调函数 若没有传入 考虑到穿透特性，这里要让其返回当前的value以传递到下一个then中</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 实现链式调用的重点: 再次返回一个Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 这部分代码略了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断如果没有传入函数我们就自己创建一个，并且注意一定要将返回值设置为this.value，这样才能在我们的checkAndConvert函数内拿到值。</p><h3 id="处理返回值是Promise对象的情况"><a href="#处理返回值是Promise对象的情况" class="headerlink" title="处理返回值是Promise对象的情况"></a>处理返回值是Promise对象的情况</h3><p>前面我们封装了处理函数，所以这里直接在这个函数内处理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// todo 这里后面还要做处理</span></span><br><span class="line">            resolve(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就把所有返回值的情况处理好了</p><h2 id="catch与静态方法resolve-reject"><a href="#catch与静态方法resolve-reject" class="headerlink" title="catch与静态方法resolve/reject"></a>catch与静态方法resolve/reject</h2><p>首先搞明白：</p><ul><li>catch实际上就是只有失败回调的then方法</li><li>resolve与reject静态方法实际就是一个调用了失败决议的新的Promise对象</li></ul><p>再看看标准Promise的catch行为：</p><p>无失败回调时，可以穿透拿到失败决议值，并且catch之后还可以调用then。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>)</span><br><span class="line">&#125;).then()</span><br><span class="line">.then()</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 输出 fail</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'继续'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 输出 继续</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>但是当有失败回调时，catch将不会执行<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">'fail'</span>)</span><br><span class="line">&#125;).then(<span class="literal">null</span>, rej=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rej) <span class="comment">// 输出fail</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 无响应</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="catch方法的实现"><a href="#catch方法的实现" class="headerlink" title="catch方法的实现"></a>catch方法的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 这个变量用来判断使用者是否传入了onRejected回调函数，根据这个变量我们可以判断是否调用catch的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> gate = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            gate = <span class="literal">true</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, value, <span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, reason, <span class="literal">false</span>, gate)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">true</span>)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">false</span>, gate)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于checkAndConvert函数:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分别是then的成功失败回调，promise的成功失败决议，决议的参数，失败决议还是成功决议的判断标志，失败决议且没有传递失败回调的标志</span></span><br><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag, rejectFlag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里要注意</span></span><br><span class="line">            <span class="keyword">if</span>(!rejectFlag) resolve(thenReturnValue)</span><br><span class="line">            <span class="keyword">else</span> reject(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在传递个下一个then时，<strong>只有一种情况会调用reject拒绝</strong>：promise决议为拒绝后且用户没有往then函数内传递拒绝参数(也就是第二个回调)，这个时候我们使用reject决议，这样就可以让catch函数顺利执行了，并且这完全符合promise的catch行为: 当then中有第二个回调函数接受上一步抛出的错误后，catch内的回调函数将不会执行反之则会执行。</p><h3 id="静态方法resolve与reject"><a href="#静态方法resolve与reject" class="headerlink" title="静态方法resolve与reject"></a>静态方法resolve与reject</h3><p>在实现了上面的代码的基础下，这两个方法实际是最简单的:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际就是返回一个新的Promise对象，再调用对应的决议函数。</p><h2 id="大功告成，完整代码"><a href="#大功告成，完整代码" class="headerlink" title="大功告成，完整代码"></a>大功告成，完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkAndConvert = <span class="function">(<span class="params">onFulfilled, onRejected, resolve, reject, value, flag, rejectFlag</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取then成功回调的返回值</span></span><br><span class="line">        <span class="keyword">let</span> thenReturnValue = flag?onFulfilled(value):onRejected(value)</span><br><span class="line">        <span class="comment">// 如果返回值是一个promise对象 那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(thenReturnValue <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            thenReturnValue.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,rej=&gt;&#123;</span><br><span class="line">                reject(rej)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                在传递个下一个then时，只有一种情况会调用reject拒绝：promise决议为拒绝后且用户没有往then函数内传递</span></span><br><span class="line"><span class="comment">                拒绝参数(也就是第二个回调)，这个时候我们使用reject决议，这样就可以让catch函数顺利执行了，并且这完全</span></span><br><span class="line"><span class="comment">                符合promise的catch行为: 当then中有第二个回调函数接受上一步抛出的错误后，catch内的回调函数将不会执行</span></span><br><span class="line"><span class="comment">                反之则会执行。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(!rejectFlag) resolve(thenReturnValue)</span><br><span class="line">            <span class="keyword">else</span> reject(thenReturnValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理放到该then函数的第二个回调中</span></span><br><span class="line">        onRejected(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> pendding = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">static</span> fulfilled = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="keyword">static</span> rejected = <span class="string">'rejected'</span></span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.successList = []</span><br><span class="line">        <span class="keyword">this</span>.failList = []</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.fulfilled</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">            <span class="keyword">this</span>.successList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onFulfilled(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = MyPromise.rejected</span><br><span class="line">            <span class="keyword">this</span>.value = reason</span><br><span class="line">            <span class="keyword">this</span>.failList.forEach(<span class="function"><span class="params">func</span>=&gt;</span>&#123;</span><br><span class="line">                func.onRejected(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 这个变量用来判断使用者是否传入了onRejected回调函数，根据这个变量我们可以判断是否调用catch的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> gate = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 判断是否传入了回调函数 若没有传入 考虑到穿透特性，这里要让其返回当前的value以传递到下一个then中</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            onFulfilled = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            gate = <span class="literal">true</span></span><br><span class="line">            onRejected = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">this</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现链式调用</span></span><br><span class="line">        <span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 以下根据状态判断resolve是同步还是异步执行 第二个以后的then的回调都会在队列中</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.pendding) &#123;</span><br><span class="line">                <span class="keyword">this</span>.successList.push(&#123;</span><br><span class="line">                    <span class="comment">/* </span></span><br><span class="line"><span class="comment">                        因为是异步 因此执行到这里的时候还没有resolve改变value与状态，所以将then中的回调函数存入</span></span><br><span class="line"><span class="comment">                        成功事件队列，调用的时机为resolve执行时，resolve时将value传入</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, value, <span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 失败队列</span></span><br><span class="line">                <span class="keyword">this</span>.failList.push(&#123;</span><br><span class="line">                    onRejected: <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                        checkAndConvert(onFulfilled, onRejected, resolve, reject, reason, <span class="literal">false</span>, gate)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非异步resolve/reject也就是执行开始就改变了状态</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.fulfilled) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 因为此时状态已经改变了，所以可以直接拿到value值</span></span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">true</span>)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === MyPromise.rejected) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    checkAndConvert(onFulfilled, onRejected, resolve, reject, <span class="keyword">this</span>.value, <span class="literal">false</span>, gate)</span><br><span class="line">                &#125;,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><del>经过测试，本次手写的Promise能够完全达到与标准Promise相同的效果。</del><br>肯定不能媲美标准的Promise库，不过确实能按预想的实现Promise的所有基本功能，是不是A+规范我还没去研究。</p><p>这次手写整个Promise，我花了两天多的时间，第一天中午开始我跟着Youtube上面的大佬写代码，到下午我跟着写完了，然后我自己动手写catch的时候就懵了，对于递归的this指向我一开始没有搞清楚，导致走了很多弯路。之后两天我耐下心打断点，一次一次运行调试，最后终于把整个流程搞透了。期间数次怀疑人生，不过最后还是搞明白了。期间认识到了不足，但也学到了新东西。这就是学习的过程吧？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Promise规则&quot;&gt;&lt;a href=&quot;#Promise规则&quot; class=&quot;headerlink&quot; title=&quot;Promise规则&quot;&gt;&lt;/a&gt;Promise规则&lt;/h2&gt;&lt;p&gt;在实现Promise之前，先看一下Promise的规则，也就是我们要实现的目标。没有
      
    
    </summary>
    
    
      <category term="进阶" scheme="http://localhost:4000/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Promise" scheme="http://localhost:4000/tags/Promise/"/>
    
      <category term="异步" scheme="http://localhost:4000/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>二次封装axios</title>
    <link href="http://localhost:4000/2020/02/21/%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85axios/"/>
    <id>http://localhost:4000/2020/02/21/%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85axios/</id>
    <published>2020-02-21T07:12:19.000Z</published>
    <updated>2020-03-05T08:52:06.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>这里参考了网上一些大神的封装方法，然后结合了下自己的需求，总的分了两个文件<br><img src="/BeCoderQ.github.io/2020/02/21/二次封装axios/construct.png" alt="construct"></p><ul><li>api文件，将项目中所有的接口api按模块分类存储在module文件。其下的index文件会将所有模块及其下的api接口以字典形式对应起来</li><li>service文件为axios封装的核心，config为配置项文件，request文件为实际封装文件，interface文件将api文件暴露出的字典转为axios函数并将其封装插件</li></ul><h2 id="api文件"><a href="#api文件" class="headerlink" title="api文件"></a>api文件</h2><p>这个文件内有所有的api接口</p><h3 id="index文件"><a href="#index文件" class="headerlink" title="index文件"></a>index文件</h3><p>这个文件会把module下根据接口分类的字典按照文件名-api名的格式暴露出去<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将api文件下的接口模块全部导入 并转换成&#123; 模块文件名: &#123; api接口名: &#123;url...&#125; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> apiMap = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加载modules下所有的接口文件 */</span></span><br><span class="line"><span class="keyword">var</span> moduleFiles = <span class="built_in">require</span>.context(<span class="string">'./module'</span>, <span class="literal">true</span>, /\.js$/)</span><br><span class="line">moduleFiles.keys().map(<span class="function"><span class="keyword">function</span>(<span class="params">modulePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleName = modulePath.substr(modulePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, modulePath.length - <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">var</span> apis = moduleFiles(modulePath).default <span class="comment">// export default的数据</span></span><br><span class="line">    apiMap[moduleName] = apis</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取模块下的api配置对象</span></span><br><span class="line"><span class="comment"> * @param moduleName 模块文件名</span></span><br><span class="line"><span class="comment"> * @param apiName 文件下api模块名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apiMap</span><br></pre></td></tr></table></figure></p><h3 id="module文件"><a href="#module文件" class="headerlink" title="module文件"></a>module文件</h3><p>这个文件下为各个接口，如下图<br><img src="/BeCoderQ.github.io/2020/02/21/二次封装axios/module.png" alt="module"><br>这里还可以自定义请求的method等</p><h2 id="service文件"><a href="#service文件" class="headerlink" title="service文件"></a>service文件</h2><p>然后是核心的service文件。</p><h3 id="config文件"><a href="#config文件" class="headerlink" title="config文件"></a>config文件</h3><p>配置项独立出来放到了一个文件里<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 基础url前缀</span></span><br><span class="line">    baseURL: <span class="string">'http://xxx.com/'</span>,</span><br><span class="line">    <span class="comment">// 请求头信息</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>:<span class="string">'application/json;charset=UTF-8'</span>,</span><br><span class="line">      <span class="string">'token'</span>: localStorage.getItem(<span class="string">'token'</span>) || <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    timeout: <span class="number">10000</span>,</span><br><span class="line">    <span class="comment">// 携带凭证</span></span><br><span class="line">    withCredentials: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 返回数据类型</span></span><br><span class="line">    responseType: <span class="string">'json'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴露出的config等会儿直接放到axios实例中</p><h3 id="request文件"><a href="#request文件" class="headerlink" title="request文件"></a>request文件</h3><p>axios核心的二次封装文件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">// 先导入axios</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'./config.js'</span> <span class="comment">// 导入配置项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">$request</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">            ...config</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// request 拦截器，请求发送前的操作</span></span><br><span class="line">    instance.interceptors.request.use(</span><br><span class="line">        config =&gt; &#123;</span><br><span class="line">            <span class="comment">// Tip: 1</span></span><br><span class="line">            <span class="comment">// 请求开始的时候可以结合 vuex 开启全屏的 loading 动画</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Tip: 2 </span></span><br><span class="line">            <span class="comment">// token也可以在这里带上 , 结合 vuex 或者 localStorage</span></span><br><span class="line">            <span class="comment">// if (store.getters.token) &#123;</span></span><br><span class="line">            <span class="comment">//     config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     // token失效跳转指定页面或是重新请求 </span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Tip: 3</span></span><br><span class="line">            <span class="comment">// 根据请求方法，序列化传来的参数，根据后端需求是否序列化</span></span><br><span class="line">            <span class="comment">// if (config.method.toLocaleLowerCase() === 'post' </span></span><br><span class="line">            <span class="comment">//     || config.method.toLocaleLowerCase() === 'put' </span></span><br><span class="line">            <span class="comment">//     || config.method.toLocaleLowerCase() === 'delete') &#123;</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">//     config.data = qs.stringify(config.data)</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">            <span class="comment">// 请求错误时(接口错误、超时等)</span></span><br><span class="line">            <span class="comment">// Tip: 4</span></span><br><span class="line">            <span class="comment">// 关闭loadding</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//  1.判断请求超时</span></span><br><span class="line">            <span class="keyword">if</span> (error.code === <span class="string">'ECONNABORTED'</span> &amp;&amp; error.message.indexOf(<span class="string">'timeout'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'根据你设置的timeout/真的请求超时 判断请求现在超时了，你可以在这里加入超时的处理方案'</span>)</span><br><span class="line">                <span class="comment">// return service.request(originalRequest);//例如再重复请求一次</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  2.需要重定向到错误页面</span></span><br><span class="line">            <span class="keyword">const</span> errorInfo = error.response</span><br><span class="line">            <span class="built_in">console</span>.log(errorInfo)</span><br><span class="line">            <span class="keyword">if</span> (errorInfo) &#123;</span><br><span class="line">                <span class="comment">// error =errorInfo.data//页面那边catch的时候就能拿到详细的错误信息,看最下边的Promise.reject</span></span><br><span class="line">                <span class="keyword">const</span> errorStatus = errorInfo.status; <span class="comment">// 404 403 500 ... 等</span></span><br><span class="line">                router.push(&#123;</span><br><span class="line">                    path: <span class="string">`/error/<span class="subst">$&#123;errorStatus&#125;</span>`</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error) <span class="comment">// 在调用的那边可以拿到(catch)你想返回的错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 响应拦截器 then catch 之前</span></span><br><span class="line">    instance.interceptors.response.use(</span><br><span class="line">        response =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> data;</span><br><span class="line">            <span class="keyword">if</span> (response &amp;&amp; (response.status === <span class="number">200</span> || response.status === <span class="number">304</span>)) &#123;</span><br><span class="line">                <span class="comment">// IE9时response.data是undefined，因此需要使用response.request.responseText(Stringify后的字符串)</span></span><br><span class="line">                <span class="keyword">if</span>(response.data == <span class="literal">undefined</span>)&#123;</span><br><span class="line">                    data = response.request.responseText</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = response.data</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据返回的code值来做不同的处理（和后端约定）</span></span><br><span class="line">                <span class="keyword">switch</span> (data.rc) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'与后端约定返回的不同rc码'</span>:</span><br><span class="line">                        <span class="keyword">return</span> data;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> &#123;</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        rc: <span class="number">-2</span>,</span><br><span class="line">                        des: <span class="string">'异常响应状态码'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err &amp;&amp; err.response) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                    err.message = <span class="string">'请求错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">                    err.message = <span class="string">'未授权，请登录'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">                    err.message = <span class="string">'拒绝访问'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">                    err.message = <span class="string">`请求地址出错: <span class="subst">$&#123;err.response.config.url&#125;</span>`</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">                    err.message = <span class="string">'请求超时'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">                    err.message = <span class="string">'服务器内部错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">                    err.message = <span class="string">'服务未实现'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">                    err.message = <span class="string">'网关错误'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">                    err.message = <span class="string">'服务不可用'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">                    err.message = <span class="string">'网关超时'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">                    err.message = <span class="string">'HTTP版本不受支持'</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.error(err)</span><br><span class="line">            Message.error(<span class="string">`ERROR: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err) <span class="comment">// 返回接口返回的错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//请求处理</span></span><br><span class="line">    instance(options)</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="interface文件"><a href="#interface文件" class="headerlink" title="interface文件"></a>interface文件</h3><p>这个文件会对api暴露出的对象的统一处理<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $req <span class="keyword">from</span> <span class="string">'./request'</span> <span class="comment">// 导入处理后的axios</span></span><br><span class="line"><span class="keyword">import</span> apiMap <span class="keyword">from</span> <span class="string">'../api/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将api文件下的接口模块全部导入 并转换成&#123; 模块文件名: &#123; api接口名: func(参数1, 参数2) &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> $apis = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> mName <span class="keyword">in</span> apiMap) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> aName <span class="keyword">in</span> apiMap[mName]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!$api[mName]) $api[mName] = &#123;&#125;</span><br><span class="line">        <span class="comment">// payload queryString参数</span></span><br><span class="line">        $api[mName][aName] = <span class="function"><span class="keyword">function</span>(<span class="params">data, params</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $req(&#123;</span><br><span class="line">                url: apiMap[mName][aName].url,</span><br><span class="line">                method: apiMap[mName][aName].method || <span class="string">'post'</span>,</span><br><span class="line">                data,</span><br><span class="line">                params</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装成插件</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="params">Vue</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (install.installed) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    install.installed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Vue.prototype, &#123;</span><br><span class="line">        <span class="comment">// 此处挂载在 Vue 原型的 $api </span></span><br><span class="line">        $api: &#123;</span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> $apis</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> install</span><br></pre></td></tr></table></figure></p><p>最后在项目的入口文件中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./service/interface'</span></span><br><span class="line">Vue.use(api)</span><br></pre></td></tr></table></figure></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用上就很简单啦:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$api.user.login(&#123;</span><br><span class="line">        username: <span class="string">'啊啊啊'</span>,</span><br><span class="line">        password: <span class="string">'123456a'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 请求成功后续操作</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 请求错误的操作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;p&gt;这里参考了网上一些大神的封装方法，然后结合了下自己的需求，总的分了两个文件&lt;br&gt;&lt;img src=&quot;/BeCoderQ.github.io
      
    
    </summary>
    
    
      <category term="经验" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="axios" scheme="http://localhost:4000/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本(半)自动化部署项目,以及踩到的坑</title>
    <link href="http://localhost:4000/2020/01/13/shell%E8%84%9A%E6%9C%AC-%E5%8D%8A-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE-%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://localhost:4000/2020/01/13/shell%E8%84%9A%E6%9C%AC-%E5%8D%8A-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE-%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91/</id>
    <published>2020-01-13T07:39:32.000Z</published>
    <updated>2020-01-13T08:32:30.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用shell脚本"><a href="#为什么要使用shell脚本" class="headerlink" title="为什么要使用shell脚本"></a>为什么要使用shell脚本</h2><p>手上有个半年前开发的项目，这个项目一套代码需要打包到七八个不同的服务器上，虽说是一套代码，但实际上要打包好几次，最开始我用最笨的办法，打包一次发一个服务器，当然这样效率是最低的，已很容易犯错，比如把A区的发到了B区的服务器上。之后我尝试打包后再改请求地址，同样的，效率也很低。附上一张之前配置的请求地址结构。<br><img src="/BeCoderQ.github.io/2020/01/13/shell脚本-半-自动化部署项目-以及踩到的坑/shell-url.png" alt="url"></p><p>也就是说每次切换一个地方就会注释掉其他的url，然后再记住当前打包的地区，再部署到对应服务器，非常痛苦，且容易出错。正巧最近一接触了shell，于是便打算使用shell脚本帮我完成部署。</p><h2 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h2><p>对于api文件内的URL结构我没有更改，仍然使用之前的结构，最初我在后面加上了”-端口”，想着方便后免脚本匹配到端口，然后使用管道执行字符串命令。但后面遇到一个坑，卡了半天。于是我新建了一个txt文本，将scp部署命令都写在里面:<br><img src="/BeCoderQ.github.io/2020/01/13/shell脚本-半-自动化部署项目-以及踩到的坑/shell-addr.png" alt="url"><br>账号@后的IP地址将与项目中api文件内的地址进行匹配，这样最恼火的一个问题就解决了。</p><h2 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h2><p>使用字符串切割(类似JavaScript中的split):</p><ul><li>${VALUE%.*}或${VALUE%%.*}：删除VALUE字符串中以分隔符“.”匹配的左边字符，保留右边字符。</li><li>${VALUE#*.}或${VALUE##*.}：删除VALUE字符串中以分隔符“.”匹配的右边字符，保留左边字符。<br>单%(#)与双%(#)区别是前者截取最短长度 后者截取最长长度<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">    pattern=<span class="string">"// var"</span></span><br><span class="line">    head -n <span class="number">8</span> ./src/utils/api.js | <span class="keyword">while</span> read line <span class="comment">// 遍历api文件内的前八行</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [[ $line =~ $pattern ]] <span class="comment">// 匹配每行以"// var开头的"</span></span><br><span class="line">        then</span><br><span class="line">            echo <span class="string">"******"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fival=$&#123;line#*<span class="comment">//&#125;</span></span><br><span class="line">            less ./<span class="keyword">public</span>/scp-address.txt | <span class="keyword">while</span> read tline</span><br><span class="line">            <span class="keyword">do</span> </span><br><span class="line">                <span class="keyword">if</span> [[ $tline =~ $&#123;fival%:*&#125; ]]</span><br><span class="line">                <span class="comment">// 或 if [[ $tline == *$&#123;fival%:*&#125;* ]]</span></span><br><span class="line">                then </span><br><span class="line">                    npm run build</span><br><span class="line">                    scp=$&#123;tline#*:&#125;</span><br><span class="line">                    $scp</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    echo <span class="string">"&amp;&amp;&amp;&amp;&amp;&amp;"</span></span><br><span class="line">                fi </span><br><span class="line">            done           </span><br><span class="line">            echo <span class="string">"*******************服务器$&#123;fival%:*&#125;打包上传完成*******************"</span></span><br><span class="line">        fi    </span><br><span class="line">    done</span><br></pre></td></tr></table></figure></li></ul><p>我们可以以别名alias或直接输入路径:./bridge.sh来执行这个shell脚本，会自动打包，然后部署到对应服务器，而打包不同的地区现在只需要在api中更改对应的url值即可。当然，现在每次执行脚本后还会要求你输入密码，如果想免密部署可以配置密钥或者使用expect脚本。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在部署这个脚本的过程遇到一个很奇葩的问题，前面说过，我在api中以”-端口”的形式让shell来匹配端口，我将这个端口的值存入了变量port中，并希望通过管道让拼接完成的字符串命令直接执行:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">port=循环匹配的端口</span><br><span class="line">...</span><br><span class="line">echo $port #这里可以正常输出内容</span><br><span class="line">`scp -r -P $port ./dist/\* ssh fbjd@$&#123;fival%:*&#125;:/home/fbjd/html | sh`</span><br><span class="line">echo <span class="string">"scp -r -P $port ./dist/* ssh fbjd@$&#123;fival%:*&#125;:/home/fbjd/html"</span></span><br></pre></td></tr></table></figure></p><p>但是输出后我发现输出的内容完全不对<br><img src="/BeCoderQ.github.io/2020/01/13/shell脚本-半-自动化部署项目-以及踩到的坑/shell-problem.png" alt="problem"><br>怎么$port以及前面的东西都不见了？百思不得其解。<br>于是我又改成输出port的长度<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">echo <span class="string">"scp -r -P $&#123;#port&#125; ./dist/* ssh fbjd@$&#123;fival%:*&#125;:/home/fbjd/html"</span></span><br><span class="line"><span class="meta"># scp -r -P 3 ./dist/\* ssh fbjd@$192.168.2.1:/home/fbjd/html</span></span><br></pre></td></tr></table></figure></p><p>改成长度输出了，但长度对不上？最后找了半天，才发现是获取的变量”不干净”，有换行符什么的，因为现在回头看截取的那部分正好是js文件内一行的最后几个字符<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">echo "scp -r -P $port ./dist/* ssh fbjd@$&#123;fival%:*&#125;:/home/fbjd/html" |tr -d '\n\r\v'</span><br></pre></td></tr></table></figure></p><p>改成这样，正常输出了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要使用shell脚本&quot;&gt;&lt;a href=&quot;#为什么要使用shell脚本&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用shell脚本&quot;&gt;&lt;/a&gt;为什么要使用shell脚本&lt;/h2&gt;&lt;p&gt;手上有个半年前开发的项目，这个项目一套代码需要打包到
      
    
    </summary>
    
    
      <category term="记录" scheme="http://localhost:4000/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="shell脚本" scheme="http://localhost:4000/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Es6中Map对象基础</title>
    <link href="http://localhost:4000/2020/01/07/Es6%E4%B8%ADMap%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://localhost:4000/2020/01/07/Es6%E4%B8%ADMap%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2020-01-07T11:12:12.000Z</published>
    <updated>2020-01-08T07:57:08.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map对象与Object"><a href="#Map对象与Object" class="headerlink" title="Map对象与Object"></a>Map对象与Object</h2><p>对于Map与普通的Object相比，主要有两点不同:</p><ul><li>Map对象的虽然也是键值对的形式，但是其健(key)可以是任何形式,从String到Function,甚至是undefined,null,而Object的键(key)只能是String或Symbol</li><li>Map中的键值对是有序的，而Object中是无序的，通过枚举遍历出的顺序是不可靠的</li><li>Map对象可以通过size操作获取长度，Object需要自行计算</li><li>Map对象可以使用forEach直接迭代</li><li>Map在一些频发的增删改下对比Object会有些性能优势</li></ul><h2 id="Map对象原型方法"><a href="#Map对象原型方法" class="headerlink" title="Map对象原型方法"></a>Map对象原型方法</h2><h3 id="Map-prototype-clear"><a href="#Map-prototype-clear" class="headerlink" title="Map.prototype.clear()"></a>Map.prototype.clear()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除Map对象的所有键/值对</span></span><br><span class="line">Map.prototype.clear()</span><br><span class="line"></span><br><span class="line">var myMap = <span class="keyword">new</span> Map();</span><br><span class="line">var objKey = &#123;&#125;;</span><br><span class="line">myMap.set('stringKey', 'this is stringKey');</span><br><span class="line">myMap.set(objKey, 'this is objKey');</span><br><span class="line">myMap.clear()</span><br><span class="line">console.<span class="built_in">log</span>(myMap) <span class="comment">// 输出: Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Map-prototype-delete"><a href="#Map-prototype-delete" class="headerlink" title="Map.prototype.delete()"></a>Map.prototype.delete()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。随后调用 Map.prototype.has(key) 将返回 false</span></span><br><span class="line">Map.prototype.<span class="keyword">delete</span>(key)</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(myMap.<span class="keyword">delete</span>(objKey)) <span class="comment">// 删除了对应键值 返回true</span></span><br></pre></td></tr></table></figure><h3 id="Map-prototype-entries"><a href="#Map-prototype-entries" class="headerlink" title="Map.prototype.entries()"></a>Map.prototype.entries()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</span></span><br><span class="line">Map.prototype.entries()</span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2020/01/07/Es6中Map对象基础/Map.entries.png" alt="entries"></p><h3 id="Map-prototype-forEach"><a href="#Map-prototype-forEach" class="headerlink" title="Map.prototype.forEach()"></a>Map.prototype.forEach()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按插入顺序，为 Map对象里的每一键值对调用一次callback函数, 回调依此是值，键，Map实例</span></span><br><span class="line">Map.prototype.forEach(callback(value, key, thisMap))</span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2020/01/07/Es6中Map对象基础/Map.forEach.png" alt="forEach"></p><h3 id="Map-prototype-get"><a href="#Map-prototype-get" class="headerlink" title="Map.prototype.get()"></a>Map.prototype.get()</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回键对应的值，如果不存在，则返回undefined</span></span><br><span class="line">Map.prototype.get(key)</span><br><span class="line"></span><br><span class="line">console.log(myMap.get('stringKey')) // 输出 this is stringKey</span><br></pre></td></tr></table></figure><h3 id="Map-prototype-has"><a href="#Map-prototype-has" class="headerlink" title="Map.prototype.has()"></a>Map.prototype.has()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示Map实例是否包含键对应的值</span></span><br><span class="line">Map.prototype.has(key)</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(myMap.has(undefined)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Map-prototype-keys"><a href="#Map-prototype-keys" class="headerlink" title="Map.prototype.keys()"></a>Map.prototype.keys()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键</span></span><br><span class="line">Map.prototype.keys()</span><br><span class="line"><span class="comment">// 我们使用展开展</span></span><br><span class="line">console.<span class="built_in">log</span>([...myMap.keys()])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展一下, 这里我们也可以将数组转为Map对象:</span></span><br><span class="line">let myArray = [['key1', 'value1'],['key2', 'value2']]</span><br><span class="line">let arrayToMap = <span class="keyword">new</span> Map(myArray) <span class="comment">// 转化为了Map对象</span></span><br></pre></td></tr></table></figure><p><img src="/BeCoderQ.github.io/2020/01/07/Es6中Map对象基础/Map.keys.png" alt="keys"></p><h3 id="Map-prototype-set"><a href="#Map-prototype-set" class="headerlink" title="Map.prototype.set()"></a>Map.prototype.set()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置Map对象中键的值。返回该Map对象</span></span><br><span class="line">Map.prototype.<span class="built_in">set</span>(key, value)</span><br></pre></td></tr></table></figure><h3 id="Map-prototype-values"><a href="#Map-prototype-values" class="headerlink" title="Map.prototype.values()"></a>Map.prototype.values()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 对应和keys()方法类似</span></span><br><span class="line">Map.prototype.values()</span><br></pre></td></tr></table></figure><h3 id="Map-prototype-iterator"><a href="#Map-prototype-iterator" class="headerlink" title="Map.prototype@@iterator"></a>Map.prototype<a href>@@iterator</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组</span></span><br><span class="line">Map.prototype[@@iterator]()</span><br></pre></td></tr></table></figure><h2 id="Map的for-of有序遍历"><a href="#Map的for-of有序遍历" class="headerlink" title="Map的for of有序遍历"></a>Map的for of有序遍历</h2><p>除了forEach,还可以使用for of来遍历Map对象:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let myMap = <span class="keyword">new</span> Map();</span><br><span class="line">myMap.<span class="built_in">set</span>(<span class="number">0</span>, <span class="string">"zero"</span>);</span><br><span class="line">myMap.<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会显示两个log。一个是"0 = zero"另一个是"1 = one"</span></span><br><span class="line"><span class="keyword">for</span> (let [key, value] of myMap) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 "0" 另一个是 "1"</span></span><br><span class="line"><span class="keyword">for</span> (let key of myMap.keys()) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 "zero" 另一个是 "one"</span></span><br><span class="line"><span class="keyword">for</span> (let value of myMap.values()) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 "0 = zero" 另一个是 "1 = one"</span></span><br><span class="line"><span class="keyword">for</span> (let [key, value] of myMap.entries()) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一个小小的实践"><a href="#一个小小的实践" class="headerlink" title="一个小小的实践"></a>一个小小的实践</h2><p>在枚举时，我们可以使用Map，一定程度上可以实现typescript中的枚举类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stateFilter(val) &#123;</span><br><span class="line">    <span class="keyword">const</span> dictionary = &#123;</span><br><span class="line">0: '设备正常',</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> statMap = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="keyword">for</span>(let key in dictionary) &#123;</span><br><span class="line">statMap.<span class="built_in">set</span>(key, dictionary[key])</span><br><span class="line">statMap.<span class="built_in">set</span>(dictionary[key], key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> statMap.get(String(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>12月31号写的 今天才发上来，越来越懒了，一定要坚持写博客啊！！！！！！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Map对象与Object&quot;&gt;&lt;a href=&quot;#Map对象与Object&quot; class=&quot;headerlink&quot; title=&quot;Map对象与Object&quot;&gt;&lt;/a&gt;Map对象与Object&lt;/h2&gt;&lt;p&gt;对于Map与普通的Object相比，主要有两点不同:&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="学习" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Map对象" scheme="http://localhost:4000/tags/Map%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>vuex的封装以及其在项目中的使用场景</title>
    <link href="http://localhost:4000/2019/11/25/vuex%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://localhost:4000/2019/11/25/vuex%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2019-11-25T11:55:13.000Z</published>
    <updated>2020-01-07T11:16:17.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex的半自动化注册"><a href="#Vuex的半自动化注册" class="headerlink" title="Vuex的半自动化注册"></a>Vuex的半自动化注册</h2><p>以前我的vuex的store文件里总是会写一大坨代码，看着实在不够’优雅’！我们其实可以利用require.context来实现vuex的半自动化注册。<br>先看下我vuex的结构</p><h3 id="Vuex的结构"><a href="#Vuex的结构" class="headerlink" title="Vuex的结构"></a>Vuex的结构</h3><p><img src="/BeCoderQ.github.io/2019/11/25/vuex的封装以及其在项目中的使用场景/store.png" alt="store.png"><br>module文件下是我按照模块划分的各个js文件 存储了如枚举值 用户信息 请求url的信息，他们会如下暴露出去<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    menulist: [],</span><br><span class="line">    companyInfo: &#123;&#125;,</span><br><span class="line">    companyNo: null,</span><br><span class="line">    toLogined:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用require-context"><a href="#使用require-context" class="headerlink" title="使用require.context"></a>使用require.context</h3><p>接下来是关键，在StoreFactory文件内，有以下代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个对象 用来暴露出去</span></span><br><span class="line">var storeMap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">var moduleFiles = require.context('./module', true, /\.js$/)</span><br><span class="line">moduleFiles.keys().<span class="built_in">map</span>(function(modulePath) &#123;</span><br><span class="line">    var moduleName = modulePath.substr(modulePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, modulePath.length - <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 获取到每个模块内的对象 .default就是文件内export default曝露出的对象</span></span><br><span class="line">    var stores = moduleFiles(modulePath).<span class="keyword">default</span></span><br><span class="line">    <span class="comment">// 声明一个中转对象</span></span><br><span class="line">    var store = &#123;namespaced:<span class="literal">true</span>, state:&#123;&#125;,mutations:&#123;&#125;&#125;</span><br><span class="line">    <span class="comment">// 使用for in遍历之每个模块内的对象。vuex的mutation修改，state存储</span></span><br><span class="line">    <span class="keyword">for</span>(let i in stores)&#123;</span><br><span class="line">        store.state[i]=stores[i]</span><br><span class="line">        <span class="comment">// 这里我设置set+属性名首字母大写 实际就是驼峰</span></span><br><span class="line">        store.mutations[`<span class="built_in">set</span>$&#123;i[<span class="number">0</span>].toUpperCase()&#125;$&#123;i.substr(<span class="number">1</span>)&#125;`]=function(states, params) &#123;</span><br><span class="line">    states[i] = params</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    storeMap[moduleName] = store</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// storeMap将存储所有对象暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> storeMap</span><br></pre></td></tr></table></figure></p><p>我们这里用webpackContext的keys方法能够得到符合条件的文件地址的数组,map方法便利我们拿到字符串，处理掉多余的符号，我们便得到了对应的文件名<br><img src="/BeCoderQ.github.io/2019/11/25/vuex的封装以及其在项目中的使用场景/keys.png" alt="moduleFiles.keys()数组"><br>得到文件名后我们将他传入moduleFiles方法中，我们可以打印出来，会发现这个对象里的default字段下已经有了我们之前暴露出去的变量对象：<br><img src="/BeCoderQ.github.io/2019/11/25/vuex的封装以及其在项目中的使用场景/default.png" alt="moduleFiles(modulePath)"><br>没错～我们就这么轻而易举的拿到了module文件下各个模块的变量！接下来要做的就是以vuex的形式处理每个模块</p><h3 id="封装store的取值与改值"><a href="#封装store的取值与改值" class="headerlink" title="封装store的取值与改值"></a>封装store的取值与改值</h3><p>先上代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">import &#123;Store&#125; from 'vuex'</span><br><span class="line"><span class="keyword">import</span> Vuex from <span class="string">"vuex"</span></span><br><span class="line"><span class="keyword">import</span> Vue from <span class="string">"vue"</span></span><br><span class="line"><span class="comment">// 导入上面那堆代码暴露出的对象</span></span><br><span class="line">import allStore from './StoreFactory'</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">var store</span><br><span class="line"><span class="keyword">if</span> (!store) &#123;</span><br><span class="line">    store = <span class="keyword">new</span> Store(&#123;</span><br><span class="line">        modules: &#123;</span><br><span class="line">            ...allStore</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的封装取值与赋值函数</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> function <span class="title">getState</span><span class="params">(moduleName, value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!store)</span><br><span class="line">        <span class="keyword">return</span> null</span><br><span class="line">    <span class="keyword">return</span> moduleName ? store.state[moduleName][value] : store.state[value]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> function setState(moduleName, field,value)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!store)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    store.commit(`$&#123;moduleName?`$&#123;moduleName&#125;/`:''&#125;set$&#123;field[0].toLocaleUpperCase()&#125;$&#123;field.substr(1)&#125;`,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></p><p>封装的代码很简单，赋值就是按照刚才设置的set字段撸就完事儿。</p><h2 id="Vuex项目中常用场景"><a href="#Vuex项目中常用场景" class="headerlink" title="Vuex项目中常用场景"></a>Vuex项目中常用场景</h2><p>实际上Vuex出了存储用户信息 token等参数外，我认为在缓存数据时更能体现价值。假设有个页面有一个表单，当用户填写表单后再次点进去，会显示刚才填写过的内容，也就是说回显，这个时候我们可以按照一下步骤来缓存与取数据。</p><ul><li><p>首先我们的表单页面的mounted或者其他合适的钩子函数内，我们先判断</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(存在某个store字段) &#123;</span><br><span class="line">    表单回显数据 = 对应store字段</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    发起ajax请求获取最新的表单数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在每次编辑或删除这个表单数据时，同样在操作成功的回调函数内，我们要将对应修改或删除的数据更新到store内</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ajax请求.then(res=&gt;&#123;</span><br><span class="line">    ...其他操作</span><br><span class="line">    setState(模块文件, 文件内字段, 修改值) <span class="comment">// 让store里的内容实时保持最新</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>这样一来不仅降低了服务器的负担，也能让回显速度大幅提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex的半自动化注册&quot;&gt;&lt;a href=&quot;#Vuex的半自动化注册&quot; class=&quot;headerlink&quot; title=&quot;Vuex的半自动化注册&quot;&gt;&lt;/a&gt;Vuex的半自动化注册&lt;/h2&gt;&lt;p&gt;以前我的vuex的store文件里总是会写一大坨代码，看着实在不够’
      
    
    </summary>
    
    
      <category term="经验" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="Vuex" scheme="http://localhost:4000/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>vue.cli脚手架项目中require.context的使用</title>
    <link href="http://localhost:4000/2019/09/15/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E4%B8%ADrequire-context%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://localhost:4000/2019/09/15/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E4%B8%ADrequire-context%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-09-15T04:44:28.000Z</published>
    <updated>2019-11-25T12:57:20.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>在使用vue做项目开发时，我们经常会用到vue全家桶，vue-router,vuex等，对于这两个工具，就拿路由来说，我们每新开一个vue文件,就要在router里注册组件才能使用,vuex也是类似如此，这个时候，我们使用这个node的api就可以实现自动注册，也就是常说的前端自动化工程。</p><h2 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h2><p>对于这个api我也只是有一点初步的了解，是因为看了公司一位前辈搭建的工程的代码才发现的。该方法接受三个参数:</p><ul><li>第一个是你需要遍历的文件目录</li><li>第二个是是否遍历其下所有子级路径的布尔变量</li><li>第三个是匹配文件名的正则表达式</li></ul><p>下面以vuex的自动注册为例子<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在store目录下的index.js文件</span></span><br><span class="line"><span class="comment">// 首先导入相关依赖</span></span><br><span class="line">import Vue from 'vue'</span><br><span class="line">import Vuex from 'vuex'</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">// allStates存储共享变量</span></span><br><span class="line">var allStates = &#123;&#125;</span><br><span class="line"><span class="comment">// 自动生成mutation存储到这个对象中</span></span><br><span class="line">var mutations = &#123;&#125;</span><br><span class="line">var computedCache = []</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加载modules下所有的状态码文件*/</span></span><br><span class="line">var moduleFiles = require.context('./modules', true, /\.js$/)</span><br><span class="line"><span class="comment">// map遍历文件路径数组</span></span><br><span class="line">moduleFiles.keys().<span class="built_in">map</span>(function(modulePath) &#123;</span><br><span class="line">  <span class="comment">// 获取到文件内的内容，并以键值对的形式存入allStates,这里我modules下的default文件格式规定成n为键名，value为值</span></span><br><span class="line">  var vars = moduleFiles(modulePath).<span class="keyword">default</span></span><br><span class="line">  vars.<span class="built_in">map</span>(function(v) &#123;</span><br><span class="line">    <span class="comment">// v.n即取出键名,v.value取出值</span></span><br><span class="line">    allStates[v.n] = v.value</span><br><span class="line">    <span class="comment">// mutation我们拼接字符串设置为统一的set+键名</span></span><br><span class="line">    mutations[`<span class="built_in">set</span>$&#123;v.n.substr(<span class="number">0</span>, <span class="number">1</span>).toUpperCase()&#125;$&#123;v.n.substr(<span class="number">1</span>)&#125;`] = function(state, value) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state[v.n] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// computed的数组推入新键名 </span></span><br><span class="line">    computedCache.push(v.n)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// computed数组存入session方便另一个文件取出</span></span><br><span class="line">sessionStorage.setItem('computedStateCache',computedCache.join(","))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将自动生成的vuex数据放进store实例里</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: allStates,</span><br><span class="line">  mutations</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></p><ul><li><p>接下来在另一个mapComputed文件内</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var computeds = &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> function mapComputed() &#123;</span><br><span class="line">  <span class="comment">// 将刚才存入session的键名取出遍历，并根据键名返回对应值</span></span><br><span class="line">  var states = sessionStorage.getItem('computedStateCache').split(',')</span><br><span class="line">  states.<span class="built_in">map</span>(function(state) &#123;</span><br><span class="line">    computeds[state] = function() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state[state]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> computeds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样，在我们要使用的文件内，我们就可以在computed计算属性内像下面这样使用了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  computed:&#123;</span><br><span class="line">      <span class="comment">// es6写法</span></span><br><span class="line">      ...mapComputed(),</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样我们就相当于把store里的变量放入data内，实现了属性共享。在使用的时候，我们只需要在store内自己创建的modules文件下的default.js中按自己规定的格式写入变量即可，一般我把页面的一些枚举值放在里面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用背景&quot;&gt;&lt;a href=&quot;#使用背景&quot; class=&quot;headerlink&quot; title=&quot;使用背景&quot;&gt;&lt;/a&gt;使用背景&lt;/h2&gt;&lt;p&gt;在使用vue做项目开发时，我们经常会用到vue全家桶，vue-router,vuex等，对于这两个工具，就拿路由来说，我们每
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="webpack" scheme="http://localhost:4000/tags/webpack/"/>
    
      <category term="node" scheme="http://localhost:4000/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>DOM元素渲染的几种优化方式</title>
    <link href="http://localhost:4000/2019/08/31/DOM%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://localhost:4000/2019/08/31/DOM%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</id>
    <published>2019-08-31T04:02:38.000Z</published>
    <updated>2019-08-31T05:27:19.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM渲染性能问题"><a href="#DOM渲染性能问题" class="headerlink" title="DOM渲染性能问题"></a>DOM渲染性能问题</h2><p>我在几个月前做的项目地图部分使用了大量的dom渲染，这导致地图在渲染的时候会有很明显的卡顿效果，当然对于地图这块，海量点的渲染是尽量不要或者说压根就别用dom元素去渲染，因为每次拖动地图都会导致每个dom元素的重新渲染。但有时候在某些不可抗力影响下又不得不用dom元素去做大量渲染，这时候我们就要考虑如何优化性能了。</p><h2 id="我所知的几个优化方法"><a href="#我所知的几个优化方法" class="headerlink" title="我所知的几个优化方法"></a>我所知的几个优化方法</h2><p>在公司一位有多年前端开发经验的前辈那里我学到了几点优化的方案：</p><ul><li>使用requestAnimationFrame<br>在那之前，我一直是使用setTimeout、setInterval来编写动画或是进行dom渲染，后两者只是在设定的时间后将相应任务添加到任务队列中，而任务队列中如果还有前面的任务尚未执行完毕，那么后添加的任务就必须等待，所以说给它们设定的时间并不准确。requestAnimationFrame的间隔是16.7ms(1000ms/60帧),另外在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这就意味着更少的的cpu，gpu和内存使用量，最直观的还是动画变得更流畅了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x = <span class="number">0</span>;</span><br><span class="line">    var div = document.getElementById(<span class="string">"div"</span>)</span><br><span class="line">    function animation() &#123;</span><br><span class="line">        requestAnimationFrame(function () &#123;</span><br><span class="line">            div.style.left = ++x + <span class="string">"px"</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">250</span>) animation();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">animation();</span><br></pre></td></tr></table></figure></li></ul><p>上面是一个最简单的应用，内层一个递归调用requestAnimationFrame</p><ul><li>document.Fragment<br>DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为 DocumentFragment 不是真实DOM树的一部分，它的变化不会触发 DOM 树的（重新渲染) ，且不会导致性能等问题。这是MDN的文档说明。实际我理解就是避免单次一个一个的插入dom元素，尽量的批量插入元素<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">"一"</span>,<span class="string">"个"</span>,<span class="string">"数"</span>,<span class="string">"组"</span>];</span><br><span class="line">arr.forEach( item=&gt;&#123;</span><br><span class="line">    var p = document.createElement(<span class="string">"p"</span>);</span><br><span class="line">    p.innerText = item;</span><br><span class="line">    document.body.appendChild(p);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>这样遍历数组每次都是挨个插入，性能较低<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">"一"</span>,<span class="string">"个"</span>,<span class="string">"数"</span>,<span class="string">"组"</span>];</span><br><span class="line">var fakeFather = document.createDocumentFragment()</span><br><span class="line">arr.forEach( item=&gt;&#123;</span><br><span class="line">    var p = document.createElement(<span class="string">"p"</span>);</span><br><span class="line">    p.innerText = item;</span><br><span class="line">    fakeFather.appendChild(p);</span><br><span class="line">&#125;)</span><br><span class="line">document.body.appendChild(fakeFather);</span><br></pre></td></tr></table></figure></p><p>document.Fragment不存在于文档流中，暂时作为一个’包’，我们将每个元素先存放在这个包中，最后打包一起插入文档流。</p><ul><li>递归分批次渲染<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">batchRenderLotsPoints(eachList)&#123;</span><br><span class="line">    <span class="comment">// 这里setTimeout主要是怕前一个还没渲染好，因为没有对应的回调函数</span></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    <span class="comment">// splice截取前10个</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.renderLotsPoints(eachList.splice(<span class="number">0</span>,<span class="number">10</span>)))</span><br><span class="line"><span class="keyword">this</span>.batchRenderLotsPoints(eachList)</span><br><span class="line">&#125;,<span class="number">200</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">renderLotsPoints(eachList) &#123;</span><br><span class="line"><span class="keyword">if</span>(!eachList||!eachList.length)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">      let arr = [];</span><br><span class="line">      let colorMarker = <span class="string">"#76DA91"</span>;</span><br><span class="line">      <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; eachList.length; i++) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>.batchRenderLotsPoints(eachList);</span><br></pre></td></tr></table></figure></li></ul><p>这里我用递归渲染，页面上效果就是很有节奏感的渲染除了节点，非常流畅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM渲染性能问题&quot;&gt;&lt;a href=&quot;#DOM渲染性能问题&quot; class=&quot;headerlink&quot; title=&quot;DOM渲染性能问题&quot;&gt;&lt;/a&gt;DOM渲染性能问题&lt;/h2&gt;&lt;p&gt;我在几个月前做的项目地图部分使用了大量的dom渲染，这导致地图在渲染的时候会有很明显
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="递归" scheme="http://localhost:4000/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>记录一下最近vue项目开发中遇到的问题与解决过程</title>
    <link href="http://localhost:4000/2019/07/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <id>http://localhost:4000/2019/07/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</id>
    <published>2019-07-31T11:06:29.000Z</published>
    <updated>2019-08-31T05:45:04.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存后的路由页面参数保存问题"><a href="#缓存后的路由页面参数保存问题" class="headerlink" title="缓存后的路由页面参数保存问题"></a>缓存后的路由页面参数保存问题</h2><p>前不久遇到个问题，在页面A单击按钮后会通过params路由传参将一个对象传给下一个路由页面B，然后进入B又有一个按钮，点击后会跳到页面C。然后我就遇到一个问题，在从B到C后，再从C返回到B，就会报错了，因为B页面接受路由参数的部分是写在activated钩子函数内的。因为在使用路由缓存后created与mounted等钩子函数都只在第一次页面载入时生效,也就是说这里必须放到activated里，那么就会出现上面的问题，C页面返回到B，是不传参的，也就是说B拿不到A之前传的参数，解决办法是使用deactivated钩子函数，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        anotherInfo: <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">activated()&#123;</span><br><span class="line">    <span class="keyword">this</span>.info = <span class="keyword">this</span>.$route.params.obj == undefined ? <span class="keyword">this</span>.anotherInfo : <span class="keyword">this</span>.$route.params.obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// deactivated是缓存页面离开的钩子函数</span></span><br><span class="line">deactivated()&#123;</span><br><span class="line">    <span class="keyword">this</span>.anotherInfo = <span class="keyword">this</span>.info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>这里我用另一个变量在离开页面时保存了第一次进入B路由时的info，在activated钩子函数内，使用三元表达式判断是否有A页面传来的参数？没有则是从其他页面跳转过来的，那么就让info等于之前离开时保存的变量antherInfo</li><li>deactivated函数很实用，另外在这个钩子函数内打印url 结果是跳转后的页面。</li></ul><h2 id="filter内无法获取到data中的属性"><a href="#filter内无法获取到data中的属性" class="headerlink" title="filter内无法获取到data中的属性"></a>filter内无法获取到data中的属性</h2><p>项目中在使用v-for渲染页面时有一个变量需要过滤值，但是这个值要根据data中的一个变量来过滤，这个时候作为一个小白，我果断使用了filter然后写了this.那个变量,然后就报错了，抛出ReferenceError,即引用错误，后来打印了一下this,居然是undefined，反正不是指向vue实例的。这个时候我查了一下，网上大神建议用computed计算属性，但是我这儿v-for渲染的不好处理呀。</p><ul><li>最后实在插值符里用了三元表达式判断。。。</li></ul><h2 id="vuex状态管理内变量在页面刷新后消失"><a href="#vuex状态管理内变量在页面刷新后消失" class="headerlink" title="vuex状态管理内变量在页面刷新后消失"></a>vuex状态管理内变量在页面刷新后消失</h2><p>接手的别人的项目用了vuex,然后这边老板要求价格下拉刷新。结果当然是一刷新就报错，因为整个app都依赖vuex里的变量。</p><ul><li>解决方法其实很简单，将vuex里的东西存入session里就行了<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    <span class="comment">// 判断session中是否有值</span></span><br><span class="line">    <span class="keyword">if</span> (sessionStorage.getItem(<span class="string">"store"</span>) ) &#123;</span><br><span class="line">        <span class="comment">// 深拷贝session中的值</span></span><br><span class="line">        <span class="keyword">this</span>.$store.replaceState(Object.assign(&#123;&#125;, <span class="keyword">this</span>.$store.state,JSON.parse(sessionStorage.getItem(<span class="string">"store"</span>))))</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在页面刷新前将vuex里的信息保存到sessionStorage里</span></span><br><span class="line">    window.addEventListener(<span class="string">"beforeunload"</span>,()=&gt;&#123;</span><br><span class="line">        sessionStorage.setItem(<span class="string">"store"</span>,JSON.stringify(<span class="keyword">this</span>.$store.state))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用ES6中Set类型给数组去重"><a href="#使用ES6中Set类型给数组去重" class="headerlink" title="使用ES6中Set类型给数组去重"></a>使用ES6中Set类型给数组去重</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>];</span><br><span class="line">arr = <span class="keyword">new</span> Set(arr) <span class="comment">// [1,2,3,4,6]</span></span><br><span class="line">console.<span class="built_in">log</span>(arr instanceof Array) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Set类型可以给单纯的数组去重，但是对于复杂的对象数组是无法实现去重的，另外对于去重后的数组，实际上我们还需要数组的from方法来将其完全转化为数组类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>];</span><br><span class="line">arr = Array.from(<span class="keyword">new</span> Set(arr)) <span class="comment">// [1,2,3,4,6]</span></span><br><span class="line">console.<span class="built_in">log</span>(arr instanceof Array) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>这里就可以将arr转化为数组类型了。</p><h2 id="关于对象数组排序"><a href="#关于对象数组排序" class="headerlink" title="关于对象数组排序"></a>关于对象数组排序</h2><p>有时候遇到需求需要我们前端来讲返回的json数组排序，并且排序的情况可能会改变比如 下面的对象数组<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var json = [</span><br><span class="line">    &#123;name: <span class="string">"Zhou"</span>,age: <span class="number">22</span>,late: <span class="string">"0次"</span>&#125;,</span><br><span class="line">    &#123;name: <span class="string">"Qi"</span>,age: <span class="number">20</span>,late:<span class="string">"5次"</span>&#125;,</span><br><span class="line">    &#123;name: <span class="string">"Ming"</span>,age: <span class="number">23</span>,late: <span class="string">"3次"</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>类似如此，我们需要按特定属性排序将数据依次渲染到页面，这时候我们可以使用Array的sort方法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">sortProperty</span><span class="params">(property)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function(a,b)&#123;</span><br><span class="line">        <span class="keyword">return</span> parseInt(a[property]) - parseInt(b[property]) <span class="comment">//这里用parseInt强制转化为数字，因为项目内需求只考虑数字大小排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">json.sort( sortProperty('late') ) // 传入排序的属性</span><br><span class="line"><span class="comment">// 输出[&#123;name: "Zhou",age: 22,late: "0次"&#125;,&#123;name: "Ming",age: 23,late: "3次"&#125;,&#123;name: "Qi",age: 20,late:"5次"&#125;]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存后的路由页面参数保存问题&quot;&gt;&lt;a href=&quot;#缓存后的路由页面参数保存问题&quot; class=&quot;headerlink&quot; title=&quot;缓存后的路由页面参数保存问题&quot;&gt;&lt;/a&gt;缓存后的路由页面参数保存问题&lt;/h2&gt;&lt;p&gt;前不久遇到个问题，在页面A单击按钮后会通过p
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://localhost:4000/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>prototype、_proto_与[[prototype]]记录</title>
    <link href="http://localhost:4000/2019/07/15/prototype%E3%80%81-proto-%E4%B8%8E-prototype-%E8%AE%B0%E5%BD%95/"/>
    <id>http://localhost:4000/2019/07/15/prototype%E3%80%81-proto-%E4%B8%8E-prototype-%E8%AE%B0%E5%BD%95/</id>
    <published>2019-07-15T11:49:53.000Z</published>
    <updated>2019-07-15T11:49:53.915Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>解决高德地图3D模式下渲染marker卡顿问题</title>
    <link href="http://localhost:4000/2019/07/11/%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE3D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B8%B2%E6%9F%93marker%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://localhost:4000/2019/07/11/%E8%A7%A3%E5%86%B3%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE3D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B8%B2%E6%9F%93marker%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/</id>
    <published>2019-07-11T11:55:35.000Z</published>
    <updated>2019-07-11T12:16:39.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲扯"><a href="#闲扯" class="headerlink" title="闲扯"></a>闲扯</h2><p>这一个月我都在和高德地图打交道，遇到了很多问题，因为没人带，都是靠自己解决，走了不少弯路。高德地图其实很强大，你能想到的几乎上面都有。</p><h2 id="3D地图"><a href="#3D地图" class="headerlink" title="3D地图"></a>3D地图</h2><p>其实项目并没有3D地图的需求，但是无奈老板提了个需求是要地图可以慢慢缩放，也就是我们说的无级缩放，再说专业点就是缩放等级zoom可以是浮点数。web端高德地图在2D模式下是不支持无级缩放的，那么在手机上就算你只缩放了一丢丢，地图也会按照加减1的zoom来放大缩小。<br>但是我又遇到个问题，3D模式下我在地图上的marker们都点不动了，经过我测试发现并不是点击事件失效，而是压根就触发不了，就像表面有个遮罩层挡住了一样，z-index设置多高都没用。最后搞了一天我还是没找到原因，不过我想起来自己用的是vue-amap,我果断换回了原生的amap，居然就解决了。。。</p><h3 id="渲染速度"><a href="#渲染速度" class="headerlink" title="渲染速度"></a>渲染速度</h3><p>那么，来说正题，我解决了上述两个问题，接下来又发现了新问题：我的marker渲染速度太慢了！！我的地图是才加载进去有9个marker,这9个类似点聚合的点，点击后会让地图放大，然后展示那9个行政区下面的几百上千家企业的marker点。marker实际上就是一个div,那么dom渲染，上千个，<strong>并且随着每次拖动div都会相对移动，而且地图还是在3D模式下</strong>，卡顿也就不奇怪了。那么我就如下分析了一下</p><ul><li>dom渲染卡顿，那么我不用dom。</li><li>拖动会重新绘制div的位置，那么我不让他重汇。<br>能实现这两点的那就只有canvas了，高德地图里也就是海量点。</li></ul><p>但是还有个问题，我的项目要求每个点旁边要有文字展示，海量点是没有的，那么高德地图有没有绘制文字的canvas方法呢？答案当然是有的。</p><h3 id="LabelsLayer图层与LabelMarker标记层"><a href="#LabelsLayer图层与LabelMarker标记层" class="headerlink" title="LabelsLayer图层与LabelMarker标记层"></a>LabelsLayer图层与LabelMarker标记层</h3><p>直接看代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">this.amap = new AMap.Map('cont', &#123;</span><br><span class="line">    resizeEnable: <span class="literal">true</span>,</span><br><span class="line">    rotateEnable:<span class="literal">false</span>,</span><br><span class="line">    pitchEnable:<span class="literal">true</span>,</span><br><span class="line">    zoom: <span class="number">9.5</span>,</span><br><span class="line">    pitch:<span class="number">0</span>,</span><br><span class="line">    viewMode:'3D',//开启3D视图,默认为关闭</span><br><span class="line">    buildingAnimation:<span class="literal">true</span>,<span class="comment">//楼块出现是否带动画</span></span><br><span class="line">    zooms:[<span class="number">9</span>,<span class="number">19</span>],</span><br><span class="line">    center:[<span class="number">116.45848</span>, <span class="number">38.87328</span>],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.layer = <span class="keyword">new</span> AMap.LabelsLayer(&#123;</span><br><span class="line">    zooms: [<span class="number">3</span>, <span class="number">20</span>],</span><br><span class="line">    zIndex: <span class="number">99999999999999999</span>,</span><br><span class="line">    visible: <span class="literal">true</span>,</span><br><span class="line">    collision: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 开启标注避让，默认为开启，v1.4.15 新增属性</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加入图层</span></span><br><span class="line"><span class="keyword">this</span>.amap.add(<span class="keyword">this</span>.layer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是canvas文字</span></span><br><span class="line">var text = <span class="keyword">new</span> AMap.LabelMarker(&#123;</span><br><span class="line">        position: [longitude, latitude],</span><br><span class="line">        zooms: [<span class="number">3</span>,<span class="number">20</span>],</span><br><span class="line">        extData: eachList,</span><br><span class="line">        text: &#123;</span><br><span class="line">            content: companyName,</span><br><span class="line">            style: &#123;</span><br><span class="line">                backgroundColor: <span class="string">"white"</span></span><br><span class="line">            &#125;,</span><br><span class="line">        offset: [<span class="number">0</span>,<span class="number">-33</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">this</span>.layer.add(text)</span><br></pre></td></tr></table></figure></p><p>实际上LabelsMarker也是可以绘制icon图标的，但是不知为何我用on函数绑定点击事件总是有一大半的点点了没反应，因此我还是使用了海量点(massMarker)</p><p>这样，在3D地图下较大量点的渲染就变得very smooth了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲扯&quot;&gt;&lt;a href=&quot;#闲扯&quot; class=&quot;headerlink&quot; title=&quot;闲扯&quot;&gt;&lt;/a&gt;闲扯&lt;/h2&gt;&lt;p&gt;这一个月我都在和高德地图打交道，遇到了很多问题，因为没人带，都是靠自己解决，走了不少弯路。高德地图其实很强大，你能想到的几乎上面都有。&lt;/p
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="高德地图" scheme="http://localhost:4000/tags/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>对于Symbol.iterator的理解</title>
    <link href="http://localhost:4000/2019/07/08/%E5%AF%B9%E4%BA%8ESymbol-iterator%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://localhost:4000/2019/07/08/%E5%AF%B9%E4%BA%8ESymbol-iterator%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2019-07-08T11:46:38.000Z</published>
    <updated>2019-07-08T12:25:10.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是iterator"><a href="#什么是iterator" class="headerlink" title="什么是iterator"></a>什么是iterator</h2><p>iterator就是迭代器的意思，在ES6里面，第一次看到的时候很懵逼，这是干什么的？那么还是直接看例子吧</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="for-in枚举"><a href="#for-in枚举" class="headerlink" title="for in枚举"></a>for in枚举</h3><p>我们都知道for in来枚举对象或者数组属性列表，如<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = &#123;name: <span class="string">"Qi"</span>,age: <span class="number">22</span>,job:<span class="string">"engineer"</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(var key in a)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(key)<span class="comment">// 打印 name  age  job</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，如果要直接打印属性值呢？一般我是下面这样做<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = &#123;name: <span class="string">"Qi"</span>,age: <span class="number">22</span>,job:<span class="string">"engineer"</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(var key in a)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(a[key])<span class="comment">// 打印 Qi 22 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>es6其实有个for of方法,使用上和for in差不多<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var b = ['Qi','22','engineer'];</span><br><span class="line"><span class="keyword">for</span>(var val in b)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(b);<span class="comment">// Qi 22 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里用数组举例，不用对象是因为对象并没有内置@@iterator迭代器，iterator迭代器只在数组、类数组对象、Map和Set结构中内置了，为什么对象没有内置？实际是因为对象的各成员并没有一个确定的顺序，所以谁先遍历谁后遍历就不确定了。给一个对象部署iterator接口，其实就是对该对象做一种线性转换。接下来看如何给对象部署迭代器。</p><h3 id="给对象部署iterator"><a href="#给对象部署iterator" class="headerlink" title="给对象部署iterator"></a>给对象部署iterator</h3><p>就用上面的例子，看看迭代器怎么工作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var b = ['Qi','22','engineer'];</span><br><span class="line">var it = b[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置的next方法</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'Qi',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: '22',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'engineer',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;done: true&#125;</span></span><br></pre></td></tr></table></figure></p><p>当然 如果直接这样连着打只会打印最后一行，这样只是展示了iterator的遍历顺序。我们使用ES6的Symbol.iterator来获取对象的@@iterator内部属性，要注意@@iterator本身不是一个迭代器对象，而是一个返回迭代器对象的函数</p><p>那么接下来看看如何给对象部署迭代器<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: <span class="string">"Zhou"</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    job: <span class="string">"engineer"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( obj,Symbol.iterator, &#123;</span><br><span class="line">    enumrable: <span class="literal">false</span>, <span class="comment">// 是否可枚举</span></span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 只读 writable 给的说明是如果设置为 false, 不可以采用 数据运算符 进行赋值</span></span><br><span class="line">    configurable: <span class="literal">true</span>, <span class="comment">// 可操作 为false的话不可以修改, 不可以删除.</span></span><br><span class="line">    value: function() &#123;</span><br><span class="line">        var _this = <span class="keyword">this</span>;</span><br><span class="line">        var idx = <span class="number">0</span>;</span><br><span class="line">        var ks = Object.keys( _this ); <span class="comment">// Object.keys()方法传入一个对象返回其属性名</span></span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            next: function() &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: _this[ks[idx++]],</span><br><span class="line">                    done: (idx &gt; ks.length)</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var it = obj[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置的next方法</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'Zhou',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: '22',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 'engineer',done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined,done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用for of 遍历我们的obj对象</span></span><br><span class="line"><span class="keyword">for</span>(var val of obj)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(val); <span class="comment">// Zhou 22 engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这实际上就是用强大的Object.defineProperty(vue中数据的双向绑定就是使用该方法)方法把Symbol.iterator写进了对象里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是iterator&quot;&gt;&lt;a href=&quot;#什么是iterator&quot; class=&quot;headerlink&quot; title=&quot;什么是iterator&quot;&gt;&lt;/a&gt;什么是iterator&lt;/h2&gt;&lt;p&gt;iterator就是迭代器的意思，在ES6里面，第一次看到的时候很懵
      
    
    </summary>
    
    
      <category term="学习" scheme="http://localhost:4000/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://localhost:4000/tags/ES6/"/>
    
      <category term="iterator" scheme="http://localhost:4000/tags/iterator/"/>
    
  </entry>
  
  <entry>
    <title>hbuilder打包vue项目遇到的布局以及图片路径问题坑</title>
    <link href="http://localhost:4000/2019/07/02/hbuilder%E6%89%93%E5%8C%85vue%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%9D%91/"/>
    <id>http://localhost:4000/2019/07/02/hbuilder%E6%89%93%E5%8C%85vue%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%9D%91/</id>
    <published>2019-07-02T11:55:26.000Z</published>
    <updated>2019-07-02T12:05:54.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们的项目用hbuilder打包成安卓app,最近主要遇到了两个问题:</p><ul><li>打包后登录页底部总是有空白，后面根据我仔细观察，发现那个空白的高度和手机状态栏是一样的</li><li>打包后高德地图的海量点icon图标不显示了？！在pc端调试的时候可都是没问题的！</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>要说都是小问题，可是对于我这样才入职的程序员小白来说还真花了一番功夫才解决<br>首先说下hbuilder打包后登录页留白的问题。原因我还没找到，我感觉可能是bug?因为我只有第一次进入登录页才会留白，从app登录后点退出回到登录页后就没有留白了。</p><ul><li>解决这个问题的核心是获取到当前手机的状态栏高度<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里可以算是获取状态栏高度吧，实际是获取的屏幕高度与非工作区域高度的差值</span></span><br><span class="line"><span class="keyword">const</span> stateHeight = window.screen.height - document.documentElement.clientHeight;</span><br><span class="line"><span class="comment">// 这里stateHeight为啥要除以2呢？这就是我觉得是bug的原因！hbuilder给我打包后登录页留白是因为出现了两个状态栏！只是其中一个在底部，而且是空白。</span></span><br><span class="line"><span class="keyword">this</span>.$refs.main.style.height = window.screen.height - stateHeight / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个问题就算解决了</p><p>再说第二个，为啥打包后高德地图海量点的图标不显示了？</p><ul><li>路径原因！下面看看我改之前的代码<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前我是这么写的海量点路径</span></span><br><span class="line">...</span><br><span class="line">style: [&#123;</span><br><span class="line">          url: '../../static/images/img.png',</span><br><span class="line">          anchor: <span class="keyword">new</span> AMap.Pixel(<span class="number">16</span>, <span class="number">35</span>),</span><br><span class="line">          size: <span class="keyword">new</span> AMap.Size(<span class="number">25</span>, <span class="number">32</span>),</span><br><span class="line">        &#125;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>这样似乎没问题，我其他页面的图都是这么写的，并且打包后能正常显示。但是高德地图的icon地址就不能这么写了<br>一定要写成<strong>static/images/img.png</strong>，也就是说不要前面的../!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;我们的项目用hbuilder打包成安卓app,最近主要遇到了两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包后登录页底部总是有空白，后面根据我仔细
      
    
    </summary>
    
    
      <category term="经验总结" scheme="http://localhost:4000/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="hbuilder" scheme="http://localhost:4000/tags/hbuilder/"/>
    
      <category term="app" scheme="http://localhost:4000/tags/app/"/>
    
  </entry>
  
</feed>
